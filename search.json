[{"title":"01简介至06矩阵运算","url":"/2022/01/23/01-06/","content":"\n\n\n筛选的Q&amp;A\n1、copy和clone的区别\ncopy分深拷贝和浅拷贝，不一定会复制内存；clone一定会复制内存。\n2、torch不区分行向量与列向量吗\n行向量 \\([1, 2, 3]\\) ， 列向量 $ [[1], [2], [3]]$，行向量的shape是 \\([n]\\)，列向量的shape是 \\([n,1]\\) .\n如果一个问题能够得到最优解，那么它就是p问题，机器学习不关心p问题，只关心np的问题。\n","categories":["动手学深度学习v2"]},{"title":"pyschools while 9-13","url":"/2022/01/24/pyschools%E4%B8%ADwhile-9-13/","content":"09 Square Root Approximation\nlink：http://www.pyschools.com/quiz/view_question/s5-q9\nCreate a function that takes in a positive number and return 2 integers such that the number is between the squares of the 2 integers. It returns the same integer twice if the number is a square of an integer.\nExamples\n&gt;&gt;&gt; sqApprox(2)(1, 2)&gt;&gt;&gt; sqApprox(4)(2, 2)&gt;&gt;&gt; sqApprox(5.1)(2, 3)\nAnswer 1\nimport mathdef sqApprox(num):    return (math.floor(num**0.5),math.ceil(num**0.5))\nAnswer 2\ndef sqApprox(num):    i = 0    minsq = 0             # set lower bound    maxsq = int(num) + 1  # set upper bound    while i &lt; maxsq:        if i * i &lt;= num and i &gt;= minsq:  # complete inequality condition            minsq = i        if i * i &gt;= num and i &lt;= maxsq:  # complete inequality condition            maxsq = i        i += 1                           # update i so that &#x27;while&#x27; will terminate    return (minsq, maxsq)\n10 Pi Approximation\nlink:http://www.pyschools.com/quiz/view_question/s5-q10\nCreate a function that computes the approximation of pi, based on the number of iterations specified.\npi can be computed by 4*(1-1/3+1/5-1/7+1/9- ...).\nExamples\n&gt;&gt;&gt; piApprox(1)4.0&gt;&gt;&gt; piApprox(10)3.04183961893&gt;&gt;&gt; piApprox(300)3.13825932952\nAnswer\ndef piApprox(num):    i = 1    pi = 0    while i &lt;= num:        pi += 4 * (-1) ** (i + 1) * (1.0 / (2 * i - 1))        i += 1    return pi\n11 Estimate Pi\nlink:http://www.pyschools.com/quiz/view_question/s5-q11\nWrite a function estimatePi() to estimate and return the value of pi based on the formula found by an Indian Mathematician Srinivasa Ramanujan. It should use a while loop to compute the terms of the summation until the last item is smaller than 1e -15. The formula for calculating distance is given below:\n\n\n\nExamples\n&gt;&gt;&gt; estimatePi()3.14159265359\nAnswer\ndef estimatePi():    import math    def factorial(n):        if n == 0:            return 1        else:            return n * factorial(n - 1)    item = 1103    k = 0    pi = 0    while item &gt; 1e-15:        item = (            (factorial(4 * k) * (1103.0 + 26390 * k))            / factorial(k) ** 4            / 396 ** (4 * k))        pi += 2 * 2 ** (0.5) / 9801 * item        k += 1    return 1 / pi\n12 Prime Factorization\nlink:http://www.pyschools.com/quiz/view_question/s5-q12\nGiven a positive integer, write a function that computes the prime factors that can be multplied together to get back the same integer.\nExamples\n&gt;&gt;&gt; primeFactorization(60)[2, 2, 3, 5]&gt;&gt;&gt; primeFactorization(1050)[2, 3, 5, 5, 7]&gt;&gt;&gt; primeFactorization(1)[]\nAnswer 1\ndef primeFactorization4(num):    def prime(num):        if num &lt; 2:            return 0        for i in range(2, int(num ** 0.5) + 1):            if num % i == 0:                return 0        else:            return 1    ls = []    start = 2    while prime(num) == 0 and num &gt; 1:        for i in range(start, int(num ** 0.5) + 1):          #if num % i == 0 and prime(i):            if num % i == 0:                ls.append(i)                num = num // i                start = i                break    if prime(num):        ls.append(num)    return ls\nAnswer 2 **\ndef primeFactorization(num):    possible = [2] + list(range(3, int(num ** 0.5) + 1, 2))    for p in possible:        if num % p == 0:            return [p] + primeFactorization(num / p)    if num &lt; 2:        return []    return [num]\nAnswer 3\ndef primeFactorization(num):     factor=[]    while num&gt;1:        for i in range(2,num+1):            if num%i==0:                factor.append(i)                num = num//i                break    return factor\nTime complexity comparison\nimport timedef primeFactorization1(num):    def prime(num):        if num &lt; 2:            return 0        for i in range(2, int(num ** 0.5) + 1):            if num % i == 0:                return 0        else:            return 1    ls = []    start = 2    while prime(num) == 0 and num &gt; 1:        for i in range(start, int(num ** 0.5) + 1):            if num % i == 0 and prime(i):                ls.append(i)                num = num // i                start = i                break    if prime(num):        ls.append(num)    return lsdef primeFactorization2(num):    possible = [2] + list(range(3, int(num ** 0.5) + 1, 2))    for p in possible:        if num % p == 0:            return [p] + primeFactorization2(num / p)    if num &lt; 2:        return []    return [num]for c in [100, 1e6, 1e10, 1e14]:    print(c)    t0 = time.time()    primeFactorization1(c)    t1 = time.time()    print(&#x27;%.10f&#x27; % (t1 - t0))    primeFactorization2(c)    t2 = time.time()    print(&#x27;%.10f&#x27; % (t2 - t1))# 100# 0.0000226498# 0.0000531673# 1e6# 0.0000638962# 0.0000970364# 1e10# 0.0000720024# 0.0017700195# 1e14# 0.0000679493# 0.2322161198\n\nleetcode:[剑指 Offer 49. 丑数]\nleetcode:[263. Ugly Number]\nleetcode:[264. Ugly Number II]\nleetcode:[1201. Ugly Number III]\nleetcode:[507. Perfect Number]\nleetcode:[1390. Four Divisors]\n\n13 Lowest Common Multiple\nlink:http://www.pyschools.com/quiz/view_question/s5-q13\nThe smallest common multiple of two or more numbers is called the lowest common multiple (LCM). Given a list of integers, find the lowest common multiple.\nExamples\n&gt;&gt;&gt; LCM([2, 3, 4])12&gt;&gt;&gt; LCM([3, 6, 9])18&gt;&gt;&gt; LCM([3, 3])3\nAnswer 1\ndef LCM(nums):     def lcm(a, b):        c = a        while True:            if c % a == 0 and c % b == 0:                return c                break            c += 1    l=lcm(nums[0],nums[1])    for i in nums[2:]:        l=lcm(l,i)    return l\nAnswer 2\nfrom math import gcd # Python versions 3.5 and above#from fractions import gcd # Python versions below 3.5from functools import reduce # Python version 3.xdef LCM(denominators):    return reduce(lambda a,b: a*b // gcd(a,b), denominators)\n\nfunctools.``reduce(function, iterable[, initializer])\n\nApply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the iterable. If the optional initializer is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If initializer is not given and iterable contains only one item, the first item is returned.Roughly equivalent to:\ndef reduce(function, iterable, initializer=None):    it = iter(iterable)    if initializer is None:        value = next(it)    else:        value = initializer    for element in it:        value = function(value, element)    return value\nSee itertools.accumulate() for an iterator that yields all intermediate values.\n\nAs of Python 3.9 lcm() function has been added in the math library. It can be called with the following signature:\n\nmath.lcm(*integers)\n\nReturn the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\n\nAnswer 3\ndef LCM(nums):  def gcd(n, m):      if m == 0:          return n      return gcd(m, n % m)  lcm = 1  for i in nums:      lcm = lcm * i // gcd(lcm, i)  return lcm\nAnswer 4\nimport numpy as npnp.lcm.reduce([40, 12, 20])\n","categories":["题解"]},{"title":"八大常见类型的行列式及其解法","url":"/2022/01/09/%E5%85%AB%E5%A4%A7%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%B3%95/","content":"来源：https://zhuanlan.zhihu.com/p/34685081\n\n本文记录了八大常见类型的行列式及其解法，解法从一般性到特殊性都有，分享给大家，例子都特别经典好用，希望对线代、高代初学者以及考研党有用。\n\n类型总览：\n\n箭型行列式\n两三角型行列式\n两条线型行列式\n范德蒙德型行列式\n\\(Hessenberg\\)型行列式\n三对角型行列式\n各行元素和相等型行列式\n相邻两行对应元素相差K倍型行列式\n\n方法总览：\n\n拆行法\n升阶法\n方程组法\n累加消点法\n累加法\n递推法（特征方程法）\n步步差法\n\n一：箭型行列式\n最常见最常用的行列式，特征很好辨识，必须掌握，请看下例：\n\\[\neg:D_n= \\left|\\begin{array}{cccc} x_1&amp;1&amp;1 &amp;... &amp;1\\\\ 1&amp;x_2&amp;&amp;&amp;\\\\ 1&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 1&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|(空白处都为0)\n\\]\n\\(Solution\\): 将第一列元素依次减去第$ i$ 列的\\(\\frac{1}{x_i}\\) ,$i=2...n $\n得：\n\\[\nD_n= \\left|\\begin{array}{cccc} x_1-\\frac{1}{x_2}-...-\\frac{1}{x_n}&amp;1&amp;1 &amp;... &amp;1\\\\ 0&amp;x_2&amp;&amp;&amp;\\\\ 0&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 0&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|\n\\]\n所以：\n\\[\nD_n=\\prod_{i=2}^{n}x_i(x_1-\\sum_{i=2}^{n}\\frac{1}{x_i})\n\\]\n二：两三角型行列式\n\n特征为对角线上方元素均为\\(a\\) ,下方元素均为\\(b\\)\n\n\n当 \\(a=b\\) 时可化为箭型行列式计算，当 \\(a\\not=b\\) 时采用拆行法计算，请看下面两例\n\n\\[\neg1(a=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b&amp;x_2&amp;b&amp;...&amp;b\\\\ b&amp;b&amp;x_3&amp;...&amp;b\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i，i=2...n\\) 行都减去第一行\n得： \\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b-x_1&amp;x_2-b&amp;0&amp;...&amp;0\\\\ b-x_1&amp;0&amp;x_3-b&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b-x_1&amp;0&amp;0&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n即化成了箭型行列式，所以：\n\\[\nD_n=[\\prod_{i=2}^{n}(x_i-b)]\\times[x_1-b(b-x_1)\\sum_{i=2}^{n}\\frac{1}{x_i-b}] \n\\]\n\n\\[\neg2(a\\not=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 采用拆行法，目的是为了降阶\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a+0\\\\ b&amp;x_2&amp;a&amp;...&amp;a+0\\\\ b&amp;b&amp;x_3&amp;...&amp;a+0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n+b-b \\end{array}\\right| \n\\]\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;b \\end{array}\\right|_{(*)}+\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;0\\\\ b&amp;x_2&amp;a&amp;...&amp;0\\\\ b&amp;b&amp;x_3&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n将第 \\(i,i=1...n-1\\) 列都减去最后一列，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1-a&amp;0&amp;0 &amp;... &amp;a\\\\ b-a&amp;x_2-a&amp;0&amp;...&amp;a\\\\ b-a&amp;b-a&amp;x_3-a&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;b \\end{array}\\right|+(x_n-b)D_{n-1} \n\\]\n所以： \\[\nD_n=b\\prod_{i=1}^{n-1}(x_i-a)+(x_n-b)D_{n-1}\n\\]\n再由行列式转置不变性得到：\n\\[\nD_n=a\\prod_{i=1}^{n-1}(x_i-b)+(x_n-a)D_{n-1}\n\\]\n联立\\((11)(12)\\) ,得通式：\n\\[\nD_n=\\frac{1}{a-b}[a\\prod_{i=1}^{n}(x_i-b)-b\\prod_{j=1}^{n}(x_j-a)]\n\\]\n\n通过适当变换可以化为两三角型行列式的，描述不如大家自己看例子揣摩，也很容易理解的，请看下例\n\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} d&amp;b&amp;b &amp;... &amp;b\\\\ c&amp;x&amp;a&amp;...&amp;a\\\\ c&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ c&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n\\(Solution\\): 将第一行乘上 \\(\\frac{a}{b}\\) ，第一列乘上 \\(\\frac{a}{c}\\)，得：\n\\[\nD_n=\\frac{bc}{a^2}\\left|\\begin{array}{cccc} \\frac{a^2d}{bc}&amp;a&amp;a &amp;... &amp;a\\\\ a&amp;x&amp;a&amp;...&amp;a\\\\ a&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n即化成了两三角型行列式\n\n一些每行上有公因子但是无法向上式那样在保持行列式不变得基础上能提出公因子的，采用升阶法，请看下例\n\n\\[\neg4:D_n=\\left|\\begin{array}{cccc} 1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n\\(Solution\\): 加边升阶，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ 0&amp;1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ 0&amp;x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ 0&amp;x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n再将第 \\(i,i=2...n+1\\) 都减去第一行的\\(x_i，i=1...n\\) 倍，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ -x_1&amp;1&amp;0&amp;0 &amp;... &amp;0\\\\ -x_2&amp;0&amp;1&amp;0&amp;...&amp;0\\\\ -x_3&amp;0&amp;0&amp;1&amp;...&amp;0\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -x_n&amp;0&amp;0&amp;0&amp;...&amp;1 \\end{array}\\right| \n\\]\n即又化成了箭型行列式，可得通式：\n\\[\nD_n=1+\\sum_{i=1}^{n}x_{i}^{2} \n\\]\n三：两条线型行列式\n特征是除了主(次)对角线或与其相邻得一条斜线所组成的任意一条线加四个顶点中的某个顶点外，其他元素均为\\(0\\)，这类行列式可以直接展开降阶。这段描述有点繁琐，但其实也并不复杂，请看下例理解\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} a_1&amp;b_1&amp; &amp;... &amp;\\\\ &amp;a_2&amp;b_2&amp;...&amp;\\\\ &amp;&amp;a_3&amp;...&amp;\\\\ &amp;&amp;&amp;\\\\ &amp;&amp;...&amp;a_{n-1}&amp;b_{n-1} \\\\ b_n&amp;&amp;...&amp;&amp;a_n \\end{array}\\right| (空白处都为0)\n\\]\n\\(Solution\\): 按照第一列两个非\\(0\\)元素拉普拉斯展开即可\n\\[\nD_n=\\prod_{i=1}^{n}a_i+(-1)^{n+1}\\prod_{i=1}^{n}b_i \n\\]\n四：范德蒙德型行列式\n范德蒙德行列式大家应该熟悉，而范德蒙德型行列式的特征就是有逐行(列)元素按幂递增(减)，可以将其转化为范德蒙德行列式来计算，请看下例\n\\[\neg:D_n=\\left|\\begin{array}{cccc} a_{1}^n&amp; a_{1}^{n-1}b_1&amp;... &amp;a_1b_1^{n-1}&amp;b_1^n\\\\ a_{2}^n&amp;a_{2}^{n-1}b_2&amp;...&amp;a_2b_2^{n-1}&amp;b_2^n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{n}^n&amp;a_{n}^{n-1}b_n&amp;...&amp;a_nb_n^{n-1}&amp;b_n^n\\\\ a_{n+1}^n&amp;a_{n+1}^{n-1}b_{n+1}&amp;...&amp;a_{n+1}b_{n+1}^{n-1}&amp;b_{n+1}^n \\end{array}\\right| \n\\]\n\\(Solution\\): 将每行都提出 \\(a_i^{n}\\),$i=1...n+1 $倍，得：\n\\[\nD_n=\\prod_{i=1}^{n+1}a_i^n\\left|\\begin{array}{cccc} 1&amp; \\frac{b_1}{a_1}&amp;... &amp;(\\frac{b_1}{a_1})^{n-1}&amp;(\\frac{b_1}{a_1})^{n}\\\\ 1&amp;\\frac{b_2}{a_2}&amp;...&amp;(\\frac{b_2}{a_2})^{n-1}&amp;(\\frac{b_2}{a_2})^{n}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 1&amp;\\frac{b_n}{a_n}&amp;...&amp;(\\frac{b_n}{a_n})^{n-1}&amp;(\\frac{b_n}{a_n})^{n}\\\\ 1&amp;\\frac{b_{n+1}}{a_{n+1}}&amp;...&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n-1}&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n} \\end{array}\\right| \n\\]\n上式即为范德蒙德行列式，所以通式为：\n\\[\nD_n=\\prod_{1\\le i&lt;j\\le n+1}(a_ib_j-b_ia_j)\n\\]\n五：\\(Hessenberg\\)型行列式\n特征为除了主(次)对角线及与其相邻的斜线，再加上第一行(列)或第\\(n\\)行(列)外，其余元素均为\\(0\\)。这类行列式有点像前面说的两条线型行列式，但是还是有一点区别的。这类行列式都用累加消点法，即通常将某一行(列)都化简到只有一个非\\(0\\)元素，以便于降阶计算，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 1&amp;-1&amp;&amp;&amp;&amp;\\\\ &amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ &amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ &amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n\\(Solution\\): 将各列都加到第一列，得到：\n\\[\nD_n= \\left|\\begin{array}{cccc} \\frac{n(n+1)}{2}&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 0&amp;-1&amp;&amp;&amp;&amp;\\\\ 0&amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ 0&amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n降阶之后再重复上述步骤即可得到通式：\n\\[\nD_n=(-1)^{n-1}\\frac{(n+1)!}{2} \n\\]\n注：需要说明的是，上面举的例子比较容易看出如何实施累加消点法就可以实现将某一行(列)都化简到只有一个非\\(0\\)元素从而达到降阶的目的，但是还有很多\\(Hessenberg\\)型行列式并不这么容易就做到，还需要大家找找技巧稍微变换一下，只要始终记得你要用累加消点法来消元来降阶就可以了\n六：三对角型行列式\n这是一种递推结构的行列式，特征为所有主子式都有相同的结构，从而以最后一列展开，将所得的\\((n-1)\\) 阶行列式再展开即得递推公式，即递推法(特征方程法)，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} a&amp;b&amp; &amp;&amp;... &amp;&amp;&amp;\\\\ c&amp;a&amp;b&amp;&amp;...&amp;&amp;&amp;\\\\ &amp;c&amp;a&amp;b&amp;...&amp;&amp;\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;\\\\ &amp;&amp;&amp;&amp;...&amp;a&amp;b\\\\ &amp;&amp;&amp;&amp;...&amp;c&amp;a \\end{array}\\right| \n\\]\n\\(Solution\\): 按第一列拉普拉斯展开，得：\n\\[\nD_n=aD_{n-1}-bcD_{n-2} \n\\]\n解特征方程： \\(x^2=ax-bc\\) ，得：\n\\[\nx_1=\\frac{a+\\sqrt{a^2-4bc}}{2}\n\\]\n\\[\nx_2=\\frac{a-\\sqrt{a^2-4bc}}{2} \n\\]\n即可得通式：\n\\[\nD_n = \\frac{x_1^{n+1}-x_2^{n+1}}{x_1-x_2} \n\\]\n注：特征方程法我没记错的话，应该是在高中将数列的时候用到的。\n七：各行元素和相等型行列式\n这个特征已经很清楚了吧，方法就是累加法，很简单，直接看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1+x_1&amp;x_1 &amp;... &amp;x_1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i,i=2...n\\)行都加到第一行去，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1+\\sum_{i=1}^{n}x_i&amp;1+\\sum_{i=1}^{n}x_i &amp;... &amp;1+\\sum_{i=1}^{n}x_i\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;1 &amp;... &amp;1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right|= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;0&amp;... &amp;0\\\\ x_2&amp;1&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;0&amp;...&amp;1 \\end{array}\\right|=1+\\sum_{i=1}^{n}x_i \n\\]\n八：相邻两行对应元素相差K倍型行列式\n这个要用步步差法\n(1)大部分元素为数字，且相邻两行对应元素相差为\\(1\\)，采用逐步作差的方法，即可出现大量 \\(\\pm1\\) 元素，进而出现大量\\(0\\)元素\n(2)若相邻两行相差\\(K\\)倍，采用逐步作\\(k\\)倍差得方法，即可出现大量\\(0\\)元素\n请看下面两个例子\n\\[\neg1:D_n= \\left|\\begin{array}{cccc} 0&amp;1&amp;2 &amp;...&amp;n-2 &amp;n-1\\\\ 1&amp;0&amp;1&amp;...&amp;n-3&amp;n-2\\\\ 2&amp;1&amp;0&amp;...&amp;n-4&amp;n-3\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ n-2&amp;n-3&amp;n-4&amp;...&amp;0&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行减去后一行，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;1&amp;1 &amp;...&amp;1 &amp;1\\\\ -1&amp;-1&amp;1&amp;...&amp;1&amp;1\\\\ -1&amp;-1&amp;-1&amp;...&amp;1&amp;1\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-1&amp;-1&amp;...&amp;-1&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n再将第一列加到第\\(i,i=2...n\\) 列，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;-2&amp;...&amp;0&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-2&amp;-2&amp;...&amp;-2&amp;0\\\\ n-1&amp;2n-3&amp;2n-4&amp;...&amp;n&amp;n-1 \\end{array}\\right|=(-1)^{n-1}(-2)^{n-2}(n-1) \n\\]\n\n\\[\neg2:D_n= \\left|\\begin{array}{cccc} 1&amp;a&amp;a^2 &amp;...&amp;a^{n-2} &amp;a^{n-1}\\\\ a^{n-1}&amp;1&amp;a&amp;...&amp;a^{n-3} &amp;a^{n-2} \\\\ a^{n-2} &amp;a^{n-1} &amp;1&amp;...&amp;a^{n-4} &amp;a^{n-3} \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ a^2&amp;a^3&amp;a^4&amp;...&amp;1&amp;a\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行加上后一行的\\((-a)\\) 倍，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1-a^n&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ a^{n-1}&amp;1-a^n&amp;0&amp;...&amp;0 &amp;0\\\\ 0 &amp;0 &amp;1-a^n&amp;...&amp;0&amp;0 \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;1-a^n&amp;0\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n=(1-a^n)^{n-1}\n\\]\n","categories":["机器学习数学基础"]},{"title":"07自动求导至08线性回归+基础优化算法","url":"/2022/02/06/07-08/","content":"筛选的Q&amp;A\n1、为什么深度学习中一般对标量求导而不是对矩阵或者向量？\n因为loss通常是一个标量，精度和loss在机器学习中都是一个标量。如果loss变成一个向量，那就会很麻烦。而且向量关于矩阵的loss就会变成一个矩阵，那么，矩阵再往下走，就会变成一个四维矩阵，那么神经网络一深，那就会变成一个特别特别大的张量，就算不出来了，所以loss通常是一个标量。\n2、多个loss分别反向的时候是不是要累计梯度？\n是的，假设在之后的神经网络有多个损失函数的话，是需要累积梯度的。也是为什么torch是默认累计梯度的。\n3、为什么获取grad前需要backward？\n不做backward的话不会去计算梯度，计算梯度是很贵的一件事情（时间和内存上）。\n4、求导过程一般来说是不是有向图？有没有环状的图结构？\n循环神经网络，但是计算上还是会展开，虽然逻辑上是有环的图。\n5、为什么用平方损失而不用绝对差值呢？\n因为绝对差值不可导。\n6、为什么机器学习优化算法都采用梯度下降，而不采用牛顿法？收敛速度更快，一般能算出一阶导，二阶导也能算。\n首先，二阶导不好算，不是总是能算出来的。 统计模型（损失函数），优化模型（我用什么算法优化），所以说把统计模型的最优解求出来的意义并不大，收敛快不快不那么关心。关心的是收敛导哪个地方，泛化性不一定比梯度下降好，不一定更实用。\n7、detach是什么作用\n告诉程序不用算梯度了。\n8、每次都随机取出一部分，怎么保证最后所有数据都被拿过了？\nbootstraping采样。次数多的情况下会遇到所有的数据，数据多的话也没必要所有的数据都用到。\n9、如果样本大小不是批量数的整数倍，那需要随机剔除多余的样本吗？\n\n改batch_size，使得epoch迭代完整\n忽略最后一次epoch的迭代\n不足部分从原有数据中抽出差额补齐\n\n08 线性回归 + 基础优化算法【动手学深度学习v2】\n","categories":["动手学深度学习v2"]},{"title":"如何做文献阅读汇报？","url":"/2022/02/14/%E5%A6%82%E4%BD%95%E5%81%9A%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E6%B1%87%E6%8A%A5%EF%BC%9F/","content":"青藤学术\n来源：知乎答案\n一篇文章又分成研究型文献和综述性文献。\n研究型文献\n针对一篇研究型文献，那么我们需要向读者讲清这篇文献的故事：\n\n这篇文献讲了个什么问题， 他的假设是什么？\n作者为什么要提出这个假设 （研究背景，他不可能凭空提出来做这个）？\n他证明了这个假设吗（大概率是的）？\n他怎么证明的（数据来源是什么，做了几组实验，什么被试，使用了什么器材，什么试剂，为什么要做几组实验，分别证明了什么）？\n作者的结论是什么？\n他还对研究提出了展望吗？他有没有声明研究的一些缺憾？\n最重要的： 你的看法（这就是 critical thinking了）， 具体可以包括：\n\n你同意作者提出的这个假设吗，有其他的文献支持或者反对作者的假设吗，为什么？\n作者的实验（数据）证明了假设吗，为什么？\n你同意作者的结论吗？为什么？\n你觉得可以在作者的基础上，有拓展空间吗？作者提出的展望值得我们研究吗？\n\n\n综述性文献\n综述文献和研究型文献有相似的地方，也有不同的地方。 相同的地方，文献都是讲一个故事，不同的地方是，综述里不涉及作者新的证明（实验），但是他会用已有的文献找到一个好的角度，这个角度是最重要的。\n我们对综述文献汇报：\n\n作者为什么要写这篇综述？\n这篇综述提出了一个什么问题或者几个问题？\n针对每个问题，作者是用哪些文献来佐证他的观点的？有没有反对的文献？\n接下来，你的想法：\n\n读完这些综述，你学习到了一些什么领域的知识？\n作者列出的这么多文献里，你觉得那些值得继续阅读？为什么？\n你觉得读完这篇综述，从作者提出的这些问题，你有启发吗？\n作者所列举的问题，你觉得值得拓展研究吗？\n\n\n综述一般是用来学习的，所以从汇报者的角度来说，如果能 Get 到能学习哪些东西，能继续阅读哪些文献，有没有启发，有没有一些 idea， 那就实现了目的。\n多篇文献\n第一种方法，如果文献不是很多，比如1-3篇，可以逐篇汇报，没有毛病，不扣分。当然控制时间，不要一个人讲了一个小时，其他人听得要睡觉。\n第二种方法，文献数量比较多，那么就要串一下，类似做个小综述，这就需要点本事。你得找到一个串的东西，我可以举一些例子，你大概会明白怎么串：\n​ 1） 这几个文献用了同一个研究方法，比如问卷，你发现他们其实挺难有因果关系；\n​ 2） 他们都用了相同的仪器，然后你觉得这个仪器你们也可以用，可以怎么在你们的实验中发挥重大的作用；\n​ 3） 他们都讨论了同一个问题，要么是时间先后顺序，要么是一个问题的不同角度，得出了不同的结论，这很有趣，我们也可以Follow。\n第二种方法需要的时间比较多一些，抽象一些，如果时间有，可以多试试看，毕竟你都读了好几篇。\n以上说的都是内容，汇报不仅包括内容，还包括内容的形式，以及报告本身（你的表演）。我稍微点一下，仁者见仁，这个需要本事。\n关于PPT\n写 PPT 的套路就很多了，但有一些guideline 和你share 一下：\n\n能用图就不要用文字；\n文字要少，不要和有些老师上课用的 PPT 那样，全部是字 ...\n列要点，说要点，不要遗漏即可。要点简要到你自己能想起来你要说啥就可以。\n风格不要洗剪吹，简洁，清爽，切记，看的人舒服。\n求你们英文不要用宋体，不要全角，不要用中文标点。反之一样，中文不要用英文标点。\n不要有拼写错误（现在 PPT 都有拼写检查），领域里的专业名词和缩小多检查几遍，不要出错。\n尽量不要有语法错误，找个英语好的同学帮忙 Check一下。\n不要最后一个晚上赶工，提前做准备。\n多检查几遍，会发现很多错误。\n\n\n这篇文章的目的是什么？研究的核心是什么？核心的结论有哪些？\n把文章的结论进行一个简要的翻译，起到最终收尾的作用\n\n车前草\n来源：知乎答案\n每个session一般有4-5篇必读文献，3篇左右选读文献。一般课上5-6人，一个人当leader，其他人都是discussant。leader是每周轮流换的。leader需要读全部的论文，discussant读必读的就可以。我们一般是三小时的课，每篇文献大概能讨论半小时到五十分钟。\nLeader通常会做PPT。内容不多，七八页左右就可以了。每页内容也很简单，大致包含以下标题：\n\nResearch Question(s). 本文研究了什么？解答了什么样的问题？\nTheoretical argument. 本文的主要argument是什么？具体说来，可以包括以下几个小的方面：a. 使用了什么理论作为依托。也就是说本文的论点是建立在什么理论上的。b. 对哪个理论/领域做出了贡献（因为使用的理论不一定要和做出贡献的理论一致。）c. 理论的推导是如何完成的。对于实证论文来说，就是自变量到因变量的逻辑是什么样的。d. argument的边界条件是什么。本文所提出的观点（即hypothesis）在什么样的条件下是立得住脚的。\nEmpirics. 本文使用了什么数据？数据是从哪里来的？取得数据的行业大致是什么样的情况？为什么这个数据有用？在方法上，为什么采用这种回归模型？为什么用零膨胀负二项回归（ZINB）而不是泊松回归（Poisson）？\nComments. 即你作为评论人对于这篇文章是怎么看的。好在哪里？差在哪里？\n\n我们老师在领域里有一定地位，提问题特别辛辣。他一般不喜欢学生在1和3方面集中太多精力。而是喜欢在2和4里挑战（challenge）学生。在讨论问题2时，他不喜欢学生把PPT里的东西念出来，而是希望你回答 “为什么这篇文章要用A理论不用B理论？”“这篇文章跟我们以前读过X文章有什么联系？”“这篇文章是如何和讨论C理论的Y、Z文章联系起来的？” 之类的问题。在回答问题4时，他希望你有建设性的批评（constructive critique）而不是光批评不提解决办法（criticizing）。总之，上文献讨论课会很辛苦。尤其对于没有参与过西方式课堂讨论的中国学生来说，第一年是一个大挑战。\n\n接下来说说为啥你觉得没什么好说的。这种事情非常正常。刚开始接触文献的时候会自然而然地把接收到的信息当做真理，大牛都已经做过了，好像都挺对，没啥意见…… 其实看多了文章之后就会知道，其实每篇文章都有或多或少的毛病。区别只在于毛病是否有损文章在领域内的贡献罢了。为了解决这个问题，还是要多看、多写。看完文章一定要写summary，research question写一段就够了，重点是constructive critique(s)。文章看多了，每篇文章在整个领域内的位置就清晰了。\n有一些速成问题可以思考的：\n理论方面：\n\n理论的假设（assumption）是什么？适用范围如何？对于本文的行业背景到底合适吗？为何本文讨论的事情不用A理论非要用B理论？\n理论的边界条件（boundary condition）是啥？假设是不是所有情况下一定成立的？\n\n实证方面：\n\n有没有遗漏变量、互为因果、测量误差等内生性问题？\n模型设定对吗？估计方法合适吗？\n假设有没有其他解释（alternative explanation）？排除了其他逻辑的干扰了吗？\n结果稳健吗？有没有P-hacking？\n\n\n最后说说汇报时的小技巧。我自己认为，写在slides上的东西其实并不重要，关键是观众听进去了多少。我一般会避免在slides上堆太多文字，一页五行字，一些关键词就差不多了。千万不要念PPT。听众期待的是脑力上的激荡，而不是一台复读机。为了激起观众的兴趣，在讲述过程中可以适当抛几个问题。（并不一定要点人回答，只要看到听众在想问题就可以了。）尽量跟听众有眼神接触，同时辅之以少量手势。不独中国人，东亚学生在做presentation上都不如北美学生熟练自信。掌握了这些讲述技巧，听众也容易弄懂你的内容。\nPPT 目录结构\n\nThe Summary of Wesley D. Sine &amp; Brandon H. Lee 2009.3 Tilting at Windmills? The Environmental Movement and the Emergence of the U.S. Wind Energy Sector Administrative Science Quarterly, 54(2009): 123-155\nExecutive Summary\n\nAbstract\n\nResearch Question\n\nGeneral Research Question\n\nHow …..?\n\nSpecific Research Question\n\nHow can …. ?\n\n\nTheory\n\nKey Theoretical Arguments\n\nEmpirics\n\nResearch Context : U.S. Wind energy sector\nSampling : 1978-1992, state-level data on entrepreneurial activity, environmental social movement organizations, and the regulatory environment in the U.S. wind energy sector.\n\nDependent Variable:\nExplanatory Variables:\nControl Variables:\n\nMethod:\n\nEvent history methods ….\n\nFindings:\n\nComments\nImportant Citations\n\nCitations that have direct theoretical impact to the focal paper\n\n\n","categories":["研究初成长"]},{"title":"一些解决方案","url":"/2022/01/09/%E4%B8%80%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"\n关于Hexo添加Mathjax相关问题及解决方法：https://d-veda.top/2018/11/11/Hexo-with-Mathjax/\nmarkdown中希腊字母加粗：https://blog.csdn.net/qq_28714865/article/details/103717900\n让公式中的某些数学符号加粗显示，可以使用\"​\"，比如 \\(\\mathbf{0123456789}\\) . 加粗希腊字母（比如书写向量或者矩阵时），使用\"\"，比如 \\(\\pmb{\\lambda}\\) .\nLaTeX输入单个点、横向多个点、竖向多个点、斜向多个点：https://blog.csdn.net/GarfieldEr007/article/details/51619866\n\n输入单个点：\n横向多个点：\n竖向多个点：\n斜向多个点：\n\n使用Markdown写矩阵：https://blog.csdn.net/qq_38228254/article/details/79469727\nJupyter notebook 运行时出现 “服务似乎挂掉了，但是会立刻重启的”：\n\nimport osos.environ[&#x27;KMP_DUPLICATE_LIB_OK&#x27;] = &#x27;TRUE&#x27;\n"},{"title":"Hello World","url":"/2022/01/04/hello-world/","content":"2022，你好。\n","categories":["hello"]},{"title":"机器学习数学基础：微积分","url":"/2022/01/08/%E5%BE%AE%E7%A7%AF%E5%88%86/","content":"本章介绍微积分中的函数、极限、导数、梯度及积分等基本概念。\n1 函数和极限\n1.1 函数的定义\n设 \\(A\\)，\\(B\\) 都是非空的数的集合，\\(f:x \\rightarrow y\\) 是从 \\(A\\) 到 \\(B\\) 到一个对应法则，那么从 \\(A\\) 到 \\(B\\) 的映射\\(f:x \\rightarrow y\\) 就叫做函数，记作 \\(y=f(x)\\) ，其中 \\(x \\in A\\)，\\(y \\in B\\) .\n1.2 反函数\n设函数 $ y =f(x) $ 的定义域是 \\(D\\)，值域是 \\(f(D)\\) 。如果对于值域 \\(f(D)\\) 中的每一个 \\(y\\) ，在 \\(D\\) 中有且仅有一个 \\(x\\) 使得 \\(g(y)=x\\) ，则按此对应法则得到了一个定义在 \\(f(D)\\) 上的函数，并把该函数称为函数 \\(y=f(x)\\) 的反函数，记作 \\(x=f^{-1}(y)\\)，\\(y \\in f(D)\\) .\n1.3 复合函数\n若 \\(y\\) 是 \\(u\\) 的函数：\\(y=f(u)\\) ，而 $u $ 又是 \\(x\\) 的函数：\\(u=g(x)\\) ，且 \\(g(x)\\) 的函数值的全部或部分在 \\(f(u)\\) 的定义域内，则 \\(y\\) 通过 \\(u\\) 成为 \\(x\\) 的函数，这种函数称为由函数 \\(u=g(x)\\) 和函数 \\(y=f(u)\\) 构成的复合函数，记作 \\(y=f[g(x)]\\) ，其中 \\(u\\) 叫作中间变量。\n1.4 多元函数\n设有两个独立的变量 \\(x\\) 与 \\(y\\) 在其给定的变域 $ D$ 中，任取一组数值时，第 \\(3\\) 个变量 $ z$ 就以某一确定的法则有唯一确定的值与其对应，那么变量 \\(z\\) 称为 \\(x\\) 和 \\(y\\) 的二元函数，记作 \\(z=f(x,y)\\) ，其中 \\(x\\) 与 \\(y\\) 称为自变量，函数 \\(z\\) 也叫作因变量，自变量 \\(x\\) 与 \\(y\\) 的变域 \\(D\\) 称为函数的定义域。\n1.5 函数极限的性质\n数列极限的定义：给定数列 $ {x_n}$ ，实常数 \\(a\\) ，若对任意给定的 \\(\\epsilon&gt;0\\) ，可以找到正整数 \\(N\\) ，使得当 \\(n&gt;N\\) 时，$ |x_n-a|&lt;$ 成立，则称数列 $ {x_n}$收敛于 \\(a\\) （或称 \\(a\\) 是数列 $ {x_n}$ 的极限）。\n自变量趋向于无穷大时函数极限的定义： 类似数列极限的定义。\n自变量趋向有限值时函数极限的定义：设函数 \\(f(x)\\) 在某点 \\(x_0\\) 的某个去心邻域内有定义，后面类似数列极限的定义。\n一些懒得敲公式的知识概念：数列极限的夹逼定理、函数极限的夹逼定理、函数极限的运算法则（加减乘除幂）、无穷大量和无穷小量。\n两个公式： \\[\n\\lim\\limits_{x\\rightarrow0}\\frac{\\text{sin} x}{x}=1\\\\\n\\lim\\limits_{x\\rightarrow0}(1+x)^{\\frac{1}{x}}=e\n\\]\n1.6 洛必达法则\n适用于 \\(\\large\\frac{0}{0}\\) 和 \\(\\large\\frac{\\infty}{\\infty}\\) 及其变式。\n1.7 函数的连续性\n一些懒得敲公式的知识概念：函数连续性定义、最值定理、介值定理、零点存在定理（勘根定理）\n1.8 拉格朗日乘数法\n拉格朗日乘数法可以解决约束优化问题。其基本思想是通过引入拉格朗日乘子来将含有 \\(n\\) 个变量和 \\(k\\) 个约束条件的约束优化问题转化成含有 \\(n+k\\) 个变量的无约束优化问题。是解决带等式约束优化问题的常用方法。\n详见：\n好久不见的拉格朗日乘数法：https://zhuanlan.zhihu.com/p/149104728\n如何理解拉格朗日乘子法？：https://www.zhihu.com/question/38586401\n1.9 函数间断点\n即不满足函数连续定义的条件。分为：\n\n第一类间断点：左右极限有定义\n\n跳跃间断点：左右极限不相等\n可去间断点：左右极限相等\n\n第二类间断点：左右极限不全有定义\n\n习题\n利用 \\(SymPy^{[1]}\\) 库实现 \\(\\lim\\limits_{a\\rightarrow 0}\\frac{sin(a)}{a}\\) 和 \\(\\lim\\limits_{n\\rightarrow\\infty}(\\frac{n+3}{n+2})^n\\) 的求解。\n#coding:utf-8import sympysympy.init_printing()from sympy import oo# 1.求sin(a) / a在a=0处的极限a = sympy.Symbol(&#x27;a&#x27;)b = sympy.sin(a) / aresult = sympy.limit(b,a,0)print(&#x27;sin(a) / a在a趋近于0处的极限:&#x27;,result)#2.求[(n+3)/(n+2)]^n ,n趋紧无穷大时的极值n = sympy.Symbol(&#x27;n&#x27;)y = ((n+3)/(n+2))**nprint ( &#x27;[(n+3)/(n+2)]^n ,n趋紧无穷大的极值：&#x27;,sympy.limit(y, n, sympy.oo) )\n2 导数\n2.1 导数的概念\n有定义，有增量，极限存在。是一种变化率\n2.2 偏导数、全导数\n偏导数相对于多元函数，全导数相对于复合函数。\n2.3 高阶导数\n多次连续求导。\n2.4 函数的基础求导法则\n一些懒得敲公式的知识概念：常用的求导公式、和与差的求导法则、复合函数的求导规则、反函数的求导法则、隐函数的求导法则等各种求导法则。\n2.5 链式法则及复杂函数的求导\n假设 \\(z = f(u, v)\\)的每一个自变量都是二元函数，也就是说，\\(u=h(x, y)\\) ，\\(v = g(x, y)\\) ，且这些函数都是可微的。那么，\\(z\\) 的偏导数为： \\[\n\\frac {\\delta z}{dx}  =  \\frac {\\delta z}{du}  \\frac {du}{dx}  +  \\frac {\\delta z}{dv} \\frac {\\delta v}{dx} \\\\\\\n \\frac {\\delta z}{dy}= \\frac {\\delta z}{du} \\frac {\\delta u}{dy}+\\frac {\\delta z}{dv} \\frac {\\delta v}{dy}\n\\] 如果我们考虑 $  =(u,v)$，为一个向量函数，我们可以用向量的表示法把以上的公式写成 \\(f\\) 的梯度与 \\(\\overrightarrow {r}\\) 的偏导数的数量积:\n\\[\n\\frac {\\delta f}{dx}  =  \\overrightarrow {V}  f  \\cdot   \\frac {\\theta r}{dx}\n\\] 更一般地,对于从向量到向量的函数,求导法则为: \\[\n\\frac {\\delta (z_ {1},\\cdots ,z_ {m})}{o(x_ {1},\\cdots ,x_ {p})} =  \\frac {d(z_ {1},\\cdots ,z_ {m})}{d(y_ {1},\\cdots ,y_ {n})}  \\frac {o(y_ {1},\\cdots ,y_ {n})}{o(x_ {1},\\cdots ,x_ {p})}\n\\]\n2.6 导数的应用\n一些懒得敲公式的知识概念：极值与最值、曲线的凸凹、拐点（凹弧的分界点）、泰勒公式和泰勒展开式、泰勒定理、中值定理（拉格朗日、罗尔和柯西中值定理）\n3 方向导数和梯度\n3.1 向量\n一些懒得敲公式的知识概念：向量的模、数量积（内积、点积、标量积 $ |a||b|cos$）、向量积（外积、叉积，它的模是 \\(|a||b|sin\\theta\\)）\n3.2 方向导数、梯度\n带有方向（极值方向，一般是取最大值的方向）的导数。\n3.3 雅可比矩阵与局部最优问题\n详见：雅可比矩阵和雅可比行列式：https://zhuanlan.zhihu.com/p/39762178\n3.4 黑塞矩阵\n二阶偏导数矩阵就是黑塞矩阵（Hessian Matrix）。它是一个自变量为向量的实值函数的二阶偏导数组成的方阵。\n\n如果H(M)是 正定矩阵，则临界点M处是一个局部的极小值。\n如果H(M)是 负定矩阵，则临界点M处是一个局部的极大值。\n如果H(M)是 不定矩阵，则临界点M处不是极值。\n\n习题\n调用 SymPy的库函数求解出雅可比矩阵的形式，调用Theano的库函数计算雅可比矩阵和黑塞矩阵的值。\n#实例01：用SymPy库函数求解出的雅克比矩阵的形式。import sympym,n,i,j = sympy.symbols(&quot;m n i j&quot;)m = i**4-2*j**3-1 #设置变量（符号）n = j-i*j**2+5funcs = sympy.Matrix([m,n])#矩阵的维度m,nargs = sympy.Matrix([i,j])res = funcs.jacobian(args)#调用jacobian函数求解print(res)#实例02：Theano库实现雅克比矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as T# 计算雅克比矩阵x=T.dvector(&#x27;x&#x27;)y=x**3+x**4# 调用scan构建循环GraphJ,updates=theano.scan(lambda i,y,x:T.grad(y[i],x),sequences=T.arange(y.shape[0]),non_sequences=[y,x])f1=function([x],J,updates=updates)print(&quot;f1=&quot;,f1([5, 5]))#实例03：Theano库实现海森矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as Tx=T.dvector(&#x27;x&#x27;)# 计算hessian矩阵y=x**3+x**4cost=y.sum()gy=T.grad(cost,x) #求梯度# 调用scan构建循环GraphH,updates=theano.scan(lambda i,gy,x:T.grad(gy[i],x),sequences=T.arange(gy.shape[0]),non_sequences=[gy,x])f2=function([x],H,updates=updates)print(&quot;f2=&quot;,f2([5, 5]))\n4 积分\n4.1 不定积分\n一些懒得敲公式的知识概念：原函数（定义、存在定理、原函数族 \\(F(x)+C\\)）\n4.2 求不定积分的方法\n一些懒得敲公式的知识概念：积分基本公式、换元法、分部积分法\n4.3 定积分\n一些懒得敲公式的知识概念：定积分定义、性质（和差、与常数乘积、单调性、极值）、积分中值定理\n","categories":["机器学习数学基础"]},{"title":"栈和递归","url":"/2022/01/17/%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92/","content":"栈（Stack）\n栈对数据 \"存\" 和 \"取\" 的过程有特殊的要求：\n\n栈只能从表的一端存取数据，另一端是封闭的。\n在栈中，无论是存数据还是取数据，都必须遵循\"先进后出\"的原则，即最先进栈的元素最后出栈。\n\n因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 \"先进后出\" 原则的线性存储结构。通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。栈的最重要一个特点——后进先出（LIFO，Last In First Out），也可以说是先进后出（FILO，First In Last Out），我们无论如何只能从一端去操作元素。\n栈又叫作堆栈，这里说明一下不要将它和堆混淆。实际上堆和栈是两个不同的概念，栈是一种只能在一端进行插入和删除的线性数据结构。\n一般来说，栈主要有两个操作：一个是进栈（PUSH），又叫作入栈、压栈；另一个是出栈（POP），或者叫作退栈。\nclass Stack:    def __init__(self):        self.stack = []        self.size = 0    def push(self, item):        self.stack.append(item) # 添加元素        self.size += 1 # 栈元素数量加 1    def pop(self):        pop = self.stack.pop() # 删除栈顶元素        self.size -= 1 # 栈元素数量减 1        return pop    def isEmpty(self):        return self.stack == []    def sizes(self):        return self.size    def peek(self):        return self.stack[-1]if __name__ = &#x27;__main__&#x27;:    # 这里假定 A 是 4，B 是 &#x27;dog&#x27;,建议每一步的结果用 print() 输出看一下    s = Stack()    s.isEmpty()    s.push(4)    s.push(&#x27;dog&#x27;)    s.peek()    s.pop()    s.isEmpty()\n递归函数\n递归函数（recursive function）是指会调用自身的函数。为了防止函数无限地重复调用自身，代码中必须至少有一条选择语句。这条用来查验条件的语句被称为基本情况（base case），用于确定接下来要继续递归还是停止递归。\ndef displayRange(lower, upper):     &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;     while lower &lt;= upper:         print(lower)         lower = lower + 1\n如何将这个函数转换为递归函数呢？首先，需要注意如下两点重要的情况。\n\nlower &lt;= upper时，循环的主体会继续执行。\n执行这个函数时，lower会不断地加1，但是upper不会有任何改变。\n\n等价的递归函数可以执行类似的基本操作，区别在于：循环被替换成了if语句；赋值语句被替换成了函数的递归调用。修改后的代码如下：\ndef displayRange(lower, upper):     &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;     if lower &lt;= upper:         print(lower)         displayRange(lower + 1, upper)\n尽管这两个函数的语法和设计是不一样的，但是它们执行的算法过程相同。递归函数的每次调用都像在迭代版本函数里的循环一样，每次都会访问整个序列里的下一个数。\n通常来说，递归函数至少有一个参数。这个参数的值会被用来对递归过程的基本情况进行判定，从而决定是否要结束整个调用。在每次递归调用之前，这个值也会被进行某种方式的修改。每次对这个值的修改，都应该产生一个新数据值，可以让函数最终达到基本情况。在displayRange这个示例里，每次递归调用之前都会增加参数lower的值，从而让它最终能够超过参数upper的值。\ndef ourSum(lower, upper, margin = 0):     &quot;&quot;&quot;Returns the sum of the numbers from lower to upper,     and outputs a trace of the arguments and return values     on each call.&quot;&quot;&quot;     blanks = &quot; &quot; * margin     print(blanks, lower, upper)         # Print the arguments    if lower &gt; upper:         print(blanks, 0)                # Print the returned value        return 0    else:        result = lower + ourSum(lower + 1, upper, margin + 4)        print(blanks, result)           # Print the returned value        return result&gt;&gt;&gt; ourSum(1, 4) 1 4   2 4       3 4          4 4             5 4             0          4       7    9 10 10\n从结果可以看出，随着对ourSum调用的进行，参数会不断向右缩进。注意，每次调用时，lower的值都增加1，而upper的值始终保持不变。对ourSum的最后一次调用返回0。随着递归的返回，所返回的每个值都与其上面的值对齐，并且会增加上lower的当前值。这样的跟踪，对于递归函数来说，是非常有用的调试工具。\n递归的三大要素\n整理自知乎\n第一要素：明确你这个函数想要干什么\n对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。\n例如，我定义了一个函数\n#算n的阶乘(假设n不为0)def f(n):\t\tpass\n这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。\n第二要素：寻找递归结束条件\n所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。\n例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下\n#算 n 的阶乘(假设n不为0)def f(n):\t\tif n == 1:        return 1\n有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？\n当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。\n#算 n 的阶乘(假设n&gt;=2)def f(n):\t\tif n == 2:        return 2\n注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样：\n# 算 n 的阶乘(假设n不为0)def f(n):\t\tif n &lt;= 2:        return n\n第三要素：找出函数的等价关系式\n第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。\n例如，\\(f(n)\\) 这个范围比较大，我们可以让 \\(f(n) = n * f(n-1)\\)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。\n说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即\n\\(f(n) = n * f(n-1)\\)。\n找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：\n# 算 n 的阶乘(假设n不为0)def f(n):\t\tif n &lt;= 2:        return n\t\treturn f(n-1) * n\n至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。\n这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。\n还是不懂？没关系，我再按照这个模式讲一些题。\n\n有些有点小基础的可能觉得我写的太简单了，没耐心看？少侠，请继续看，我下面还会讲\n如何优化递归\n\n案例1：斐波那契数列\n\n斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34....，即第一项 f(1) = 1,第二项 f(2) = 1.....,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。\n\n1、第一递归函数功能\n假设 f(n) 的功能是求第 n 项的值，代码如下：\n2、找出递归结束的条件\n显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) = f(2) = 1。所以递归结束条件可以为 n &lt;= 2。代码如下：\ndef f(n):    if n &lt;= 2:        return 1\n3、找出函数的等价关系式\n题目已经把等价关系式给我们了，所以我们很容易就能够知道 \\(f(n) = f(n-1) + f(n-2)\\)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。\n所以最终代码如下：\ndef f(n):    # 1.先写递归结束条件    if n &lt;= 2:        return 1    # 2.接着写等价关系式    return f(n - 1) + f(n - 2)\n搞定，是不是很简单？\n\n零基础的可能还是不大懂，没关系，之后慢慢按照这个模式练习！好吧，有大佬可能在吐槽太简单了。\n\n案例2：小青蛙跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n1、第一递归函数功能\n假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：\ndef f(n):\t\tpass\n2、找出递归结束的条件\n我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：\ndef f(n):    if n == 1:        return 1\n第三要素：找出函数的等价关系式\n每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。\n第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。\n第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。\n所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：\ndef f(n):    if n == 1:        return 1    return f(n - 1) + f(n - 2)\n大家觉得上面的代码对不对？\n答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。\n这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：\ndef f(n):    if n &lt;= 2:        return n    return f(n - 1) + f(n - 2)\n递归的缺点\n虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。\n1、递归堆栈溢出\n▉ 理解堆栈溢出\n1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。\n2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。\n3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。\n#报错def f(i):    if i == 1:        return 1    return i + f(i -1) result = f(200000)print(result)\n▉ 解决办法\n通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。\ndepth=1def f(n):    global depth    depth+=1    if(depth &gt; 1000):        raise Exception(&#x27;堆栈溢出&#x27;)    if(n == 1):        return 1    print(depth)    return f(n-1) + 1\n解决方案 tail recursion\n2、递归重复元素\n有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。\n▉ 解决办法\n重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表（hash）或者键值对来保存。\n3、递归高空间复杂度\n因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。\nhttps://leetcode-cn.com/problems/unique-paths/\nhttps://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/\n","categories":["数据结构"]},{"title":"爬虫：电子阅读权限保存电子书","url":"/2022/02/09/%E7%94%B5%E5%AD%90%E9%98%85%E8%AF%BB%E6%9D%83%E9%99%90%E4%BF%9D%E5%AD%98%E7%94%B5%E5%AD%90%E4%B9%A6/","content":"在文泉书局上买了本《统计学习必学的十个问题》，但是只有网上的阅读权限，不是很方便做笔记。电子阅读后发现，每一页其实都是一张图片，因此可以把图片保存下来，然后再合成PDF。再HTML进行解析获得左边目录对应的书签，对PDF进行添加书签，然后一本带书签的PDF文件就下载完毕了。\n本文代码参考：\n\n文泉书局的电子书下载方法-c++\n文泉学堂PDF(带书签)下载原理详细讲解_python脚本实现\n\n问题\n所有的电子书内容都是以图片进行传输和显示的，那么只要能获取图片的url或者直接获取图片内容就可以把图片保存下来。但是，在图片的url请求地址中包含有一个key，不要这个key就只能获取到一张非常模糊的图片，只有key值对上了才能请求到清晰的图片，而且这个请求地址好像还是有时间限制的，估计是在key里面有个时间戳\\(^{[1]}\\)。（只有留在那一页才会有清晰的图片，否则只会有缩略图或者模糊版本，而且图片采用的是base64加密。）\n\n\n\n解决方案\n登陆\n因为是登陆后买的书籍，所以需要登陆（懒得写验证码等等，直接分开运行好了）。\nBEGIN_PAGE = 1url = &quot;https://wqbook.wqxuetang.com/read/pdf?bid=3224478&quot;# 图片路径，mac路径_image_path = &quot;./img/&quot;start = time.time()  # 开始时间browser = webdriver.Chrome() #这里也可以加路径，通过chrome://settings/help了解版本号，下载对应的web driver即可browser.get(url=url)  # 访问\n然后手动登陆。\n下载高清图片\n可以在页码框中依次输入页码1，3...（也可以改成1，2，3...），每次输入完之后保存图片再进行下一次输入。采用python的selenium模块进行模拟，然后用webdriver.Chrome()对象的page_source来获取当前页面的html文档，之后再用BeautifulSoup获取加密的图片数据，然后base64解密，获取图片的分辨率，如果\\(&gt;500\\)（判断是不是缩略图）就保存图片。\nmain-code\ndataQueue = queue.Queue(155)  # 初始化队列try :    time.sleep(4)    pages = 155    print(&quot;总页数为%d&quot; % pages)  # 获取书本总页数    for i in range(BEGIN_PAGE, pages, 2) :        list = input_action(browser, i, False)        download_image(list[0], i, dataQueue)        download_image(list[1], i + 1, dataQueue)        print(&quot;下载进度: %f%%   \\r&quot; % ((i / pages) * 100))    if pages % 2 == 1 :  # 如果是奇数的话，最后一页没有下载        text = input_action(browser, pages, True)        download_image(text, pages, dataQueue)    while not dataQueue.empty() :        index = dataQueue.get(False)        b_text = input_action(browser, index, True)        download_image(b_text, index, dataQueue)    end = time.time()    print(&quot;-------------下载图片完毕-------------&quot;)\ndef-code\n函数：get_image_size，delay，input_action，download_image .\ndef get_image_size(content) :    &quot;&quot;&quot;    :param content: 图片的二进制数据    :return: 图片的宽高    &quot;&quot;&quot;    tmpIm = BytesIO(content)    im = Image.open(tmpIm)    w = im.size[0]  # 宽    h = im.size[1]  # 高    return w, h  def delay(browser, page, is_last) :    &quot;&quot;&quot;    此函数非常关键，它等待两个页面全部加载完毕    原理是根据此页面的图片是否高清    输入页码之后，一次加载的是2页，比如输入3，加载的是3,4两页的图片    :param browser:webdriver.Chrome()    :param page:页数    :param is_last: 是否是最后一页    :return:图片字节流    &quot;&quot;&quot;    start_tm = datetime.datetime.now()    while True :        try :            # 如果长时间没反应就刷新当前页面，并且把当前下载页面输入进去            end_tm = datetime.datetime.now()            if (end_tm - start_tm).seconds &gt; 8 :                start_tm = datetime.datetime.now()                browser.refresh()                time.sleep(1)                input_ = browser.find_element_by_id(&#x27;input&#x27;)                input_.clear()                input_.send_keys(&#x27;1&#x27;)                time.sleep(0.5)                input_.clear()                input_.send_keys(str(page))                input_.send_keys(Keys.ENTER)            html = browser.page_source            soup = BeautifulSoup(html, &quot;html.parser&quot;)            help_contents = soup.find_all(&#x27;div&#x27;, class_=&quot;page-img-box&quot;)            text1 = help_contents[page].find(&#x27;img&#x27;)[&#x27;src&#x27;]            index1 = text1.find(&quot;,&quot;)            img_byte1 = base64.b64decode(text1[index1 + 1 :].encode(&quot;utf-8&quot;))            num1, tmp = get_image_size(img_byte1)            if not is_last :  # 如果不是最后一个                text2 = help_contents[page + 1].find(&#x27;img&#x27;)[&#x27;src&#x27;]                index2 = text2.find(&quot;,&quot;)                img_byte2 = base64.b64decode(text2[index2 + 1 :].encode(&quot;utf-8&quot;))                num2, tmp = get_image_size(img_byte2)                if num1 &gt; 500 and num2 &gt; 500 :                    return [img_byte1, img_byte2]                time.sleep(0.5)            else :  # 如果是最后一个                if num1 &gt; 500 :                    return img_byte1        except :            passdef input_action(browser, page_num, is_last) :    &quot;&quot;&quot;    开始模拟自动输入页码，加载    &quot;&quot;&quot;    input = browser.find_element_by_id(&#x27;input&#x27;)    input.clear()    input.send_keys(str(page_num))    input.send_keys(Keys.ENTER)    # 延迟，等待页面加载完毕    _list = delay(browser, page_num, is_last)    return _listdef download_image(text, page, dataQueue) :    &quot;&quot;&quot;    :param text: 图片字节流    :param page: 页码，防止保存失败的时候，加入到dataQueue中方便最后重新下载    :param dataQueue:    :return:    &quot;&quot;&quot;    try :        byte_text = text        img_name = str(page) + &quot;.jpeg&quot;        with open(_image_path + img_name,&#x27;wb&#x27;) as f:            f.write(byte_text)    except :        print(&quot;第%d页下载失败&quot; % page)        print(_image_path+img_name)        dataQueue.put(page)\n下载书签\nmain-code\nbookmark = download_bookmark(bookmark_action(browser))  # 打开目录，准备下载书签print(&quot;下载书签完毕&quot;)\ndef-code\n函数：bookmark_action，download_bookmark .\ndef bookmark_action(browser) :    &quot;&quot;&quot;    开始模拟打开所有目录(经过测试，只有打开所有目录之后，子书签才会出现在html文档中)    :param browser:    :return:返回包含子书签的html文档，以便后期用BeautifulSoup获取保存书签    &quot;&quot;&quot;    mulu = browser.find_element_by_css_selector(&quot;[class=&#x27;iconfont2 icon-wq-catalog&#x27;]&quot;)    mulu.click()    # 打开所有的三角形    sjxs = browser.find_elements_by_css_selector(&quot;[class=&#x27;el-tree-node__expand-icon el-icon-caret-right&#x27;]&quot;)    for sjx in sjxs :        sjx.click()        time.sleep(0.5)    time.sleep(2)  # 等待2秒，开始    html = browser.page_source.encode(&quot;utf-8&quot;)    return html  def download_bookmark(html) :    &quot;&quot;&quot;    爬取书签保存为列表,格式如下    无子书签： [name, num, 0]    有子书签: [name, num, [[child_name1, child_num1],[child_name2, child_num2]...... ]]    :param html: html字符串    :return:返回书签列表    &quot;&quot;&quot;    soup = BeautifulSoup(html, &quot;html.parser&quot;)    help_contents = soup.find(&#x27;div&#x27;, role=&quot;tree&quot;)    xs = help_contents.contents    parent_tag_list = []    for i in range(len(xs)) :  # 筛选出父节点        try :            if xs[i][&#x27;role&#x27;] == &quot;treeitem&quot; :                parent_tag_list.append(xs[i])        except :            pass    bookmark = []    for i in range(len(parent_tag_list)) :        temp_bookmark = [0, 0, 0]  # 名字，序号，子节点        temp_bookmark[0] = parent_tag_list[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-left&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;)        temp_bookmark[1] = parent_tag_list[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-pagenum&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;)        a = parent_tag_list[i].find(&quot;div&quot;, class_=&quot;el-tree-node__children&quot;)        if a :  # 如果存在子节点            tag_children = a.find_all(&#x27;div&#x27;, role=&quot;treeitem&quot;)            children_bookmark = []            for i in range(len(tag_children)) :                child_bookmark = [0, 0]  # 名字，序号                child_bookmark[0] = tag_children[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-left&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;)                child_bookmark[1] = tag_children[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-pagenum&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;)                children_bookmark.append(child_bookmark)            temp_bookmark[2] = children_bookmark        else :            temp_bookmark[2] = 0        bookmark.append(temp_bookmark)    return bookmark\n合成pdf\nmain-code\npdf_name = &quot;统计学习必学的十个问题&quot;img_path = _image_pathpdf_path = pdf_name + &quot;.pdf&quot;convert_images_to_pdf(img_path, pdf_path, get_size(), pages)\ndef-code\ndef get_size() :    &quot;&quot;&quot;    获取图片的宽高，来计算比例，用来合成PDF    :return:PDF的尺寸    &quot;&quot;&quot;    with open(_image_path + &quot;1.jpeg&quot;, &quot;rb&quot;) as f :        A4_MY = [0, 297 * mm]        f.seek(16)        w = bytes_to_long(f.read(4))        h = bytes_to_long(f.read(4))    bili = h / w    A4_MY[0] = (297 // bili) * mm    return A4_MYdef convert_images_to_pdf(img_path, pdf_path, size, pdf_count) :    &quot;&quot;&quot;    将图片合成为PDF    :param img_path:图片文件夹路径    :param pdf_path:PDF文件路径(包含PDF文件名)    :param size: PDF的尺寸    :param pdf_count: PDF的总页数    :return:    &quot;&quot;&quot;    pages = 0    (w, h) = size    c = canvas.Canvas(pdf_path, pagesize=portrait((w, h)))    l = os.listdir(img_path)    l.sort(key=lambda x : int(x[:-5]))      # 因为后缀都是.jpeg，所以是-5，对图片进行排序    for i in l :        f = img_path + os.sep + str(i)        c.drawImage(f, 0, 0, w, h)        c.showPage()        pages = pages + 1        print(&quot;添加进度: %f%%   \\r&quot; % ((pages / pdf_count) * 100))    c.save()\n添加书签\nmain-code\nadd_bookmark(bookmark, pdf_path)print(&quot;下载完成，时间:%.2f秒&quot; % (end - start))\ndef-code\ndef add_bookmark(bookmark, pdf_path) :    &quot;&quot;&quot;    书签的列表格式    无子书签： [name, num, 0]    有子书签: [name, num, [[child_name1, child_num1],[child_name2, child_num2]...... ]]    根据bookmark列表来对PDF文件添加书签    :param bookmark:    :return:    &quot;&quot;&quot;    # 读取PDF文件，创建PdfFileReader对象    book = PdfFileReader(pdf_path)    # 创建PdfFileWriter对象，并用拷贝reader对象进行初始化    pdf = PdfFileWriter()    pdf.cloneDocumentFromReader(book)    # 添加书签    # 注意：页数是从0开始的，中文要用unicode字符串，否则会出现乱码    # 如果这里的页码超过文档的最大页数，会报IndexError异常    for i in range(len(bookmark)) :        parent = pdf.addBookmark(bookmark[i][0], int(bookmark[i][1]) - 1)        if bookmark[i][2] != 0 :  # 如果有子书签            for j in range(len(bookmark[i][2])) :                pdf.addBookmark(bookmark[i][2][j][0], int(bookmark[i][2][j][1]) - 1, parent=parent)    # 保存修改后的PDF文件内容到文件中    # 注意：这里必须用二进制的&#x27;wb&#x27;模式来写文件，否则写到文件中的内容都为乱码    with open(pdf_path, &#x27;wb&#x27;) as fout :        pdf.write(fout)\n运行登陆模块后的main代码\ndataQueue = queue.Queue(155)  # 初始化队列try :    time.sleep(4)    pages = 155    print(&quot;总页数为%d&quot; % pages)  # 获取书本总页数    for i in range(BEGIN_PAGE, pages, 2) :        list = input_action(browser, i, False)        download_image(list[0], i, dataQueue)        download_image(list[1], i + 1, dataQueue)        print(&quot;下载进度: %f%%   \\r&quot; % ((i / pages) * 100))    if pages % 2 == 1 :  # 如果是奇数的话，最后一页没有下载        text = input_action(browser, pages, True)        download_image(text, pages, dataQueue)    while not dataQueue.empty() :        index = dataQueue.get(False)        b_text = input_action(browser, index, True)        download_image(b_text, index, dataQueue)    end = time.time()    print(&quot;-------------下载图片完毕-------------&quot;)    # 开始获取尺寸    bookmark = download_bookmark(bookmark_action(browser))  # 打开目录，准备下载书签    print(&quot;下载书签完毕&quot;)    pdf_name = &quot;统计学习必学的十个问题&quot;    img_path = _image_path    pdf_path = pdf_name + &quot;.pdf&quot;    convert_images_to_pdf(img_path, pdf_path, get_size(), pages)    # 添加书签    add_bookmark(bookmark, pdf_path)    print(&quot;下载完成，时间:%.2f秒&quot; % (end - start))finally :    browser.close()\n","categories":["爬虫"]},{"title":"流程图与伪代码","url":"/2022/02/11/%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%8E%E4%BC%AA%E4%BB%A3%E7%A0%81/","content":"流程图 Flowchart\nWhat is flowchart?\nA flowchart is a schematic representation of an algorithm or process that tell how to complete a task.\n程序流程图又称程序框图，是用统一规定的标准符号描述程序运行具体步骤的图形表示。\nHow to use flowchart?——symbol\n\n\n\n\n\n\nHow to use flowchart?——structure\n1）顺序结构\n这种结构最简单，各个步骤是按先后顺序执行的。如图，A、B、C是三个连续的步骤，它们是按顺序执行的，即完成上一个框中指定的操作才能再执行下一个动作。\n\n\n\n2） 选择结构\n选择结构又称分支结构，用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。\n\n\n\n3）循环结构\n循环结构又称为重复结构，指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。\n根据判断条件，循环结构又可细分为以下两种形式：先判断后执行的循环结构（当型结构），和先执行后判断的循环结构（直到型结构）。\n\n\n\nHow to use flowchart?——path/arrow\n除了符号规划、结构规划，绘制流程图过程中还要注意一些约定俗成的路径规划，比如\n1）绘制流程图时，为了提高流程图的逻辑性，应遵循从左到右、从上到下的顺序排列。\n2）一个流程从开始符开始，以结束符结束。开始符号只能出现一次，而结束符号可出现多次。若流程足够清晰，可省略开始、结束符号。\n3）同一流程图内，符号大小需要保持一致，同时连接线不能交叉，连接线不能无故弯曲。\n4）流程处理关系为并行关系的，需要将流程放在同一高度。\n5）处理流程须以单一入口和单一出口绘制，同一路径的指示箭头应只有一个。\n\n\n\nAnnotation\n\n\n\nParallel\n\n\n\nExample\n\n\n\n制作软件\n\nvisio\nprocesson\n\n伪代码 Pseudocode\nWhat is Pseudocode?\nPseudocode is a simpler version of a programming code in plain English before it is implemented in a specific programming language. Pseudocode is often referred to as a syntactical representation of a program and it doesn't have a strict syntax since it only represents the way we're thinking.\n\n伪代码是在以特定编程语言实现之前的简单英语编程代码的更简单版本。 伪代码通常被称为程序的语法表示，它没有严格的语法，因为它只表示我们的思维方式。\n\nWhy use pseudocode?\nPseudocode abstracts away syntax to let you focus on solving the problem in front of you. So instead of getting bogged down in the exact syntax of a language, pseudocode allows you to work almost impure programming logic. This way you don't actually have to know what exact built-in functions a programming language provides, you can simply write down in plain English what it is you're trying to do.\n\n伪代码抽象出语法，让您专注于解决您面前的问题。 因此，伪代码可以让您使用几乎不纯的编程逻辑，而不是陷入语言的确切语法中。 这样，您实际上不必知道编程语言提供了哪些确切的内置函数。 您可以简单地用日常的英语写下您想要做什么。\n\nIt essentially helps us break down large problems into smaller manageable pieces through this. Running pseudocode allows you to think through a problem with some foresight and lets you anticipate important questions before they arise. It is actually saving some time and headaches along the way and breaking things down with pure programming logic, and then googling or researching what you need to look for will essentially help you in becoming a better programmer.\n\n它本质上帮助我们把大问题分解成更小的可管理的部分。 运行伪代码可以让您有远见地思考问题，并在重要问题出现之前预测它们。 它实际上节省了一些时间和痛苦，并用纯编程逻辑分解事情，然后谷歌搜索或研究你需要寻找的内容将帮助你成为一个更好的程序员。\n\nHow to write pseudocode?\n\nCapitalize key commands (IF numbers is &gt; 10 THEN) \\(\\rightarrow\\)​ create code blocks and actually spots some of the logic\nWrite one statement per line\nUse indentation keep \\(\\rightarrow\\) different components of your pseudocode isolated\nBe specific\nKeep it simple \\(\\rightarrow\\) even for a layman or a client\n\nExample\nWrite a program that prints the number from 1 to 20 . For multiples of three print \"Fizz\" instead of the number. For the multples of five print \"Buzz\" instead of the number. For numbers which are multiples of both three and five print \"FizzBuzz\". For numbers not divisible by 3, or 5, or both, print the number as is.\nFOR LOOP:Set counter to 1Break when counter reaches 20Increment counter by 1\tIF number MOD 15  == 0\t\tprint &#x27;FizzBuzz&#x27;\tELSE IF number MOD 3 == 0\t\tprint &#x27;Fizz&#x27;\tELSE IF number MOD 5 == 0\t\tprint&#x27;Buzz&#x27;\tELSE\t\tprint number\nAnother version\n规则：\n\n在伪代码中，每一条指令占一行(else if 例外)，指令后不跟任何符号；\n“缩进”表示程序中的分支程序结构（同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进）；\n通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上行号，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤；\n每一行可以加上编号（也可不加）。\n\n1.变量的声明\n算法中出现的数组、变量可以是以下类型：整数、实数、字符、字符串或指针。定义变量的语句不用写出来，但必须在注释中给出。\n2.指令的表示\n在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。\n3.表达式\n算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符 = 、≠、&lt;、&gt;、≤ 和 ≥，以及逻辑运算符与(and)、或（or）、非（not）。\n4.赋值语句\n赋值语句是如下形式的语句：a←b。 这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。\n变量交换：若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。\n5.goto语句\ngoto语句具有形式：\ngoto label（goto标号）\n它将导致转向具有指定标号的语句。\n6.分支结构\n条件语句：\nif i=10    then xxxx    else xxxx //else 和 then 要对齐       //或者if i=10    then xxxx //if 后面必定跟上then，else后面不用跟then    else if i=9 //elseif 要连在一起写        then xxxx        yyyy    else  xxxx //else 跟在 elseif 的 then 对齐\n7.循环结构\n有两种循环指令：while和for。\nwhile语句的形式是：\nwhile time&lt;10    do  xxxxx //while后面必定要紧跟缩进的do    xxxxx    end\nfor语句的形式是：\nfor var init to limit by incr \tdo send\n这里var是变量，init、limit和incr都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若incr≥0，则只要var≤limit，就执行s并且将incr加到var上。（假若incr&lt;0，则只要var≥limit，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。\n8.程序的结束\nexit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。exit导致转向到紧接在包含exit的（最内层）while或者for循环后面的一个语句。\nreturn用来指出一个算法执行的终点；如果算法在最后一条指令之后结束，它通常是被省略的；它被用得最多的场合是检测到不合需要的条件时。return的后面可以紧接被括在引号的信息。\n9.注释风格\n算法中的注释被括在 /* */ 之中。\n10.函数的编写\n函数的伪代码格式例子为：search（A，name）， 参数类型可以不给出，但必须在注释中说明。\nExample\n//伪代码x ← 0y ← 0z ← 0while x &lt; Ndo x ← x + 1y ← x + yfor t ← 0 to 10do z ← ( z + x * y ) / 100repeaty ← y + 1z ← z - yuntil z &lt; 0z ← x * yy ← y / 2  //代码x = y = z = 0;while( z &lt; N )&#123;   x ++;　　y += x;　　for( t = 0; t &lt; 10; t++ )　　&#123;　　     z = ( z + x * y ) / 100;　　     do 　　     &#123;\t\t\ty ++;\t\t\tz -= y;　　     &#125; while( z &gt;= 0 );    &#125;　　z = x * y;&#125;y /= 2;\n参考自\n\nYoutube：Introduction to Creating Flowcharts\n专栏：知乎专栏：流程图绘制\nYouTube: What is pseudocode and how do you use it?\n博客：学会写伪代码\n博客：科研基础3-伪代码规范-latex\n\n","categories":["编程思维"]},{"title":"第1章 日常用语的骗局","url":"/2022/02/13/%E7%AC%AC1%E7%AB%A0-%E6%97%A5%E5%B8%B8%E7%94%A8%E8%AF%AD%E7%9A%84%E9%AA%97%E5%B1%80/","content":"\n  我只知道它言之无理，却讲不出所以然。\n\n基本原则\n首先是一些基本原则。我们不能称之为规律，它们不过是一些行为模式的描述，大致概括了人类反应和思考的倾向方式。比如，人们会：\n\n倾向于相信自己愿意相信的事物。\n倾向于将自身的偏爱或经验投射于现实生活。\n倾向于对特殊事件进行普遍化概括。\n倾向于身临其境地分析事件并且让自身情感超越客观理性。\n不能作为很好的聆听者。人们会有选择地听，并且常常只听自己想听的内容。\n拥有对所观察到的事物进行合理化(文饰)的冲动。\n常常无法从无关紧要的事物中提取相关、重要的事物。\n很容易从正在处理的特定事情上转移注意力。\n通常不愿意彻底地探索主题的盘根错节，倾向于过度简单化。\n一般都以貌取人。人们观察事物时，曲解自己的观察，然后做出可怕的误判。\n总是不知所谓，尤爱泛泛而谈。说话之前很少审慎思考，却让情感、偏见、成见、好恶、希望和挫折代替审慎思考。\n很少坚持一贯的行为准则。人们很少仔细检查证据然后得出结论。相反，人们更倾向于想怎么做就怎么做，想相信什么就相信什么，然后找出能够支持自己行动或信念的证据。人们的思考具有选择性：在评估现实情况时，热衷于寻找支持自己所支持事物的理由，同样热衷于忽视或者漠视不支持他们所支持事物的理由。\n人们往往不会将内心的本意宣之于口，而说出的话通常别有深意。\n\n观察评论\n针对这些原则，我们再加上由J.A.C.布朗 (J.A.C.Brown) 在《说服的技巧》(Techniques of Persuasion)一书中所引用的四条观察评论：\n①大多数人宁愿觉得事情简单而不复杂。\n②希望自己的偏见得到证实。\n③想要体验其他人无法企及的“归属感”。\n④需要为自己的挫败精确指定背黑锅的假想敌。\n未经训练的大脑更容易选择阻力最小的道路。阻力最小的道路就是几乎从不运用理性思考。\n","categories":["有毒的逻辑"]},{"title":"矩阵求导与分子、分母布局","url":"/2022/02/05/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E4%B8%8E%E5%88%86%E5%AD%90%E3%80%81%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80/","content":"原文见：矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇）\n1 函数与标量、向量、矩阵\n考虑一个函数 \\[\n\\text{function}(\\text{input})\n\\]\n针对 \\(function\\) 的类型、\\(input\\) 的类型，我们可以将这个函数分为 \\(function\\) 不同的种类。\n1、 \\(function\\) 是一个标量\n我们称 \\(function\\) 是一个实值标量函数。用细体小写字母 \\(f\\) 表示。\n1.1 \\(input\\) 是一个标量\n我们称 \\(function\\) 的变元是标量。用细体小写字母 \\(x\\) 表示。\n例1： \\[\nf(x)=x+2\n\\]\n1.2 \\(input\\) 是一个向量\n我们称 \\(function\\) 的变元是向量。用粗体小写字母 \\(\\pmb{x}\\) 表示。\n例2：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\nf(\\pmb{x})=a_1x_1^2+a_2x_2^2+a_3x_3^2+a_4x_1x_2\n\\]\n1.3 \\(input\\) 是一个矩阵\n我们称 \\(function\\) 的变元是矩阵。用粗体大写字母 \\(\\pmb{X}\\) 表示。\n例3：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\nf(\\pmb{X})=a_1x_{11}^2+a_2x_{12}^2+a_3x_{21}^2+a_4x_{22}^2+a_5x_{31}^2+a_6x_{32}^2\n\\]\n\\[\n\\left\\{ \\begin{align*} \\frac{\\partial f}{\\partial x_1} &amp; = 2x_1+x_2 \\\\\\\\ \\frac{\\partial f}{\\partial x_2} &amp; = x_1+x_3 \\\\\\\\ \\frac{\\partial f}{\\partial x_3} &amp; = x_2 \\end{align*} \\right.\n\\]\n2、\\(function\\) 是一个向量\n我们称 \\(function\\) 是一个实向量函数 。用粗体小写字母表 \\(\\pmb{f}\\) 示。\n含义： \\(\\pmb{f}\\) 是由若干个 \\(f\\) 组成的一个向量。\n同样地，变元分三种：标量、向量、矩阵。这里的符号仍与上面相同。\n2.1 标量变元\n例4： \\[\n\\pmb{f}_{3\\times1}(x)= \\left[ \\matrix{ f_1(x)\\\\ f_2(x)\\\\ f_3(x)\\\\ } \\right] = \\left[  \\matrix{ x+1\\\\ 2x+1\\\\ 3x^2+1 } \\right]\n\\]\n2.2 向量变元\n例5：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\n\\pmb{f}_{3\\times1}(\\pmb{x})= \\left[ \\matrix{ f_1(\\pmb{x})\\\\ f_2(\\pmb{x})\\\\ f_3(\\pmb{x})\\\\ } \\right] = \\left[  \\matrix{ x_{1}+x_{2}+x_{3}\\\\ x_{1}^2+2x_{2}+2x_{3}\\\\ x_{1}x_{2}+x_{2}+x_{3} } \\right] \n\\]\n2.3 矩阵变元\n例6：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\n\\pmb{f}_{3\\times1}(\\pmb{X})= \\left[ \\matrix{ f_1(\\pmb{X})\\\\ f_2(\\pmb{X})\\\\ f_3(\\pmb{X})\\\\ } \\right] = \\left[  \\matrix{ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}+x_{11}x_{12}\\\\ 2x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}+x_{11}x_{12} } \\right]\n\\]\n3、\\(function\\) 是一个矩阵\n我们称 \\(function\\) 是一个实矩阵函数 。用粗体大写字母 \\(\\pmb{F}\\) 表示。\n含义： \\(\\pmb{F}\\) 是由若干个 \\(f\\) 组成的一个矩阵。\n同样地，变元分三种：标量、向量、矩阵。这里的符号仍与上面相同。\n3.1 标量变元\n例7： \\[\n\\pmb{F}_{3\\times2}(x)= \\left[ \\matrix{ f_{11}(x) &amp; f_{12}(x)\\\\ f_{21}(x) &amp; f_{22}(x)\\\\ f_{31}(x) &amp; f_{32}(x)\\\\ } \\right] = \\left[  \\matrix{ x+1 &amp; 2x+2\\\\ x^2+1 &amp; 2x^2+1\\\\ x^3+1 &amp; 2x^3+1 } \\right]\n\\]\n3.2 向量变元\n例8：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\n\\pmb{F}_{3\\times2}(\\pmb{x})= \\left[ \\matrix{ f_{11}(\\pmb{x}) &amp; f_{12}(\\pmb{x})\\\\ f_{21}(\\pmb{x}) &amp; f_{22}(\\pmb{x})\\\\ f_{31}(\\pmb{x}) &amp; f_{32}(\\pmb{x})\\\\ } \\right] = \\left[  \\matrix{ 2x_{1}+x_{2}+x_{3} &amp; 2x_{1}+2x_{2}+x_{3} \\\\ 2x_{1}+2x_{2}+x_{3} &amp; x_{1}+2x_{2}+x_{3} &amp; \\\\ 2x_{1}+x_{2}+2x_{3} &amp; x_{1}+2x_{2}+2x_{3} &amp; } \\right]\n\\]\n3.3 矩阵变元\n例9：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\n\\begin{align*} \\pmb{F}_{3\\times2}(\\pmb{X})&amp;= \\left[ \\matrix{ f_{11}(\\pmb{X}) &amp; f_{12}(\\pmb{X})\\\\ f_{21}(\\pmb{X}) &amp; f_{22}(\\pmb{X})\\\\ f_{31}(\\pmb{X}) &amp; f_{32}(\\pmb{X})\\\\ } \\right]\\\\\\\\ &amp;= \\left[  \\matrix{ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 2x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ 3x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 4x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ 5x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 6x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} } \\right] \\end{align*}\n\\]\n4、总结\n\n\n\nFunction\\input\n标量变元\n向量变元\n矩阵变元\n\n\n\n\n实值标量函数\n\\(f(x)\\)\n\\(f(\\pmb{x})\\)\n\\(f(\\pmb{X})\\)\n\n\n实向量函数\n\\(\\pmb{f}(x)\\)\n\\(\\pmb{f}(\\pmb{x})\\)\n\\(\\pmb{f}(\\pmb{X})\\)\n\n\n实矩阵函数\n\\(\\pmb{F}(x)\\)\n\\(\\pmb{F}(\\pmb{x})\\)\n\\(\\pmb{F}(\\pmb{X})\\)\n\n\n\n2 矩阵求导的本质\n对于一个多元函数\n例10： \\[\nf(x_1,x_2,x_3)=x_1^2+x_1x_2+x_2x_3\n\\] 我们可以将 \\(f\\) 对 \\(x_1,x_2,x_3\\) 偏导分别求出来，即： \\[\n\\left\\{ \\begin{align*} \\frac{\\partial f}{\\partial x_1} &amp; = 2x_1+x_2 \\\\\\\\ \\frac{\\partial f}{\\partial x_2} &amp; = x_1+x_3 \\\\\\\\ \\frac{\\partial f}{\\partial x_3} &amp; = x_2 \\end{align*} \\right. \n\\]\n矩阵求导也是一样的，本质就是 \\(function\\) 中的每个 \\(f\\) 分别对变元中的每个元素逐个求偏导，只不过写成了向量、矩阵形式而已。\n我们把得出的3个结果写成列向量形式： \\[\n\\frac{\\partial f(\\pmb{x})}{\\partial \\pmb{x}_{3\\times1}}= \\left[ \\matrix{ \\frac{\\partial f}{\\partial x_1}\\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\frac{\\partial f}{\\partial x_3}\\\\ } \\right] = \\left[  \\matrix{ 2x_1+x_2\\\\ x_1+x_3\\\\ x_2 } \\right]\n\\] 一个矩阵求导以列向量形式展开的雏形就出现了。\n当然我们也可以以行向量形式展开： \\[\n\\frac{\\partial f(\\pmb{x})}{\\partial \\pmb{x}_{3\\times1}^T}=  \\left[  \\frac{\\partial f}{\\partial x_1}, \\frac{\\partial f}{\\partial x_2}, \\frac{\\partial f}{\\partial x_3}  \\right]  =  \\left[   2x_1+x_2, x_1+x_3, x_2  \\right]\n\\] 所以，如果 \\(function\\) 中有 \\(m\\) 个 \\(f\\) ，变元中有 \\(n\\) 个元素，那么，每个 \\(f\\) 对变元中的每个元素逐个求偏导后，我们就会产生 \\(m\\times n\\) 个结果。至于结果的布局，是写成行向量，还是写成列向量，还是写成矩阵，就是我们接下来要讨论的事情。\n3 矩阵求导结果的布局\n不严谨地说，从直观上看：分子布局，就是分子是列向量形式，分母是行向量形式；分母布局，就是分母是列向量形式，分子是行向量形式。\n不同类型的变元，严谨的布局说明见原文：矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇）\n补充：来自机器学习中的矩阵和向量的求导\nx表示n维向量，X表示m×n维度的矩阵,y表示m维向量，Y表示p×q 维度的矩阵。\n\n\n\n解释几点：\n\n对于一个复杂的变量求导的时候，比如复合函数求导涉及到后面要讲的链式求导时候，只能选一种求导布局，不能同时出现分子布局和分母布局,分子布局与分母布局算出的结果只相差一个转置\n列向量y对列向量x的求导的分子布局形式可以理解为，分子向量y对分母向量x的第一个标量元素求导后排在第一列，对第二个标量元素求导后排在第二列，以此类推，排成一个m×n的矩阵。 也被称为雅克比矩阵：\n\n\n\n图中的默认布局是指常用的布局形式(向量和矩阵在分子上就用分子布局，否则用分母布局)，也是符合大家习惯的写法。\n\n4 分子布局、分母布局的本质\n总结：\n1、分子布局的本质：分子是标量、列向量、矩阵向量化后的列向量；分母是标量、列向量转置后的行向量、矩阵的转置矩阵、矩阵向量化后的列向量转置后的行向量。\n2、分母布局的本质：分子是标量、列向量转置后的行向量、矩阵向量化后的列向量转置后的行向量；分母是标量、列向量、矩阵自己、矩阵向量化后的列向量。\n思考一下，其实可以再简洁一些：谁转置了，就是另一方的布局。分子转置了，就是分母布局；分母转置了，就是分子布局。\n","categories":["数学基础"]},{"title":"第2章 感性的语言","url":"/2022/02/14/%E7%AC%AC2%E7%AB%A0%E6%84%9F%E6%80%A7%E7%9A%84%E8%AF%AD%E8%A8%80/","content":"\n  越是坏事，越能说出好的道理来。\n\n我们都有情感的需要：爱的需要、被爱的需要、被接受的需要、体验成就感的需要、体验自我价值的需要、体会自身重要性的需要、感到被人需要的需要、能够保护自己的需要、获取自己眼中的相应地位和其他人眼中的相应地位的需要，以及安全感的需要。这些需要依次隐含了其他情感：爱、恨、恐惧、嫉妒、愤怒、愧疚、贪婪、希望和忠诚。情感既脆弱又敏感。它们很容易被入侵，也很容易被操纵。只要有人懂得如何诉诸我们的情感，就能欺骗我们，操纵我们，并且让我们把谬误当作真理来接受。\n以下就是为达到欺骗理性的目的而蹂躏情感的几种手段。如果我们能够辨认出它们，就有可能避免受到欺骗和操纵。\n诉诸怜悯\n有人求助于我们的同情心、慈悲和友爱，而不是拿出有案可查的严密推理、证据或事实。他们给我们展示一张瘦骨嶙峋的儿童的照片、一位营养不良的受害者，使得我们不得不拿出一大笔钱捐献给为养活饥饿儿童而建立的基金会。如今这样的诉求并没有什么本质上的错误。但是我们不应该太天真，居然相信我们的捐赠都能实实在在地用来养活饥饿的儿童。那些捐赠有多少会用于行政管理，有多少会用于其他广告宣传，又有多少会用于支付基金高管们的高薪？此种诉诸怜悯的关键问题在于，它并没有告诉我们捐赠会被如何使用，甚至都不能保证我们的捐赠能被用于当初所诉求的目的。\n诉诸罪恶感\n让我们回顾前一个例子。有人给我们展示了一张饥饿儿童的图片，然后又给我们展示了另一张温馨的家庭聚餐图片。“你们衣食无忧，”宣传语这样写着，“你们什么都不缺。比起全世界上百万的挨饿人群，你们心安理得。”我们因为生活舒适而被动地产生罪恶感。此外，它还暗示甚至可以说是明示：如果不捐款，我们的罪恶感更强。以后享用晚餐时，我们会不自觉地想起饥饿的儿童。这样的情景会一直萦绕在心中，直到我们捐款为止。\n对于这样的诉诸罪恶感有三点需要说明。\n第一，任何人无权践踏我们的情感天平。\n第二，除非能给出充足的理由支持我们应该有罪恶感的推测，否则此种推测无足轻重。\n第三，就算我们有罪恶感，也没有任何理由去做宣传所鼓吹的事情，因为仍然无法保证我们的捐赠会带来任何明显的好处。\n诉诸恐惧则试图恐吓我们，让我们做出特定的行为或者接受特定的信念。“如果你不照做X事情，就会发生Y事情。”当然，Y事情的后果非常可怕。“如果你不先杀死敌人，敌人就会先干掉你。”但是，为证明此命题正确有效，表述者有义务证明X事件和Y事件之间的确切因果关系。有时候诉诸恐惧是私下形成的。\n诉诸希望\n“如果你做了X事情，Y事情就有可能发生；如果你想要Y事情发生，就去做X事情吧。”但是，说这话的人既无法保证Y事情一定会发生，也没有任何好的理由证明X事情对Y事情有显著影响。州彩票活动就是利用这一手段。人人都想赢得十万美金，一旦听说有人中了奖，尤其是当配合使用“这也能发生在你身上”的营销说辞，这种希望所带来的感觉会令人忘记真正买到中奖彩票的机会是多么渺茫。\n诉诸恭维\n如果有人恭维我们，我们就会容易混淆对于恭维者的好感和恭维者真正表达的意思。贝丝恭维乔治，乔治享受贝丝的恭维，因此乔治对贝丝的一切都有正面倾向，也更加容易顺从贝丝的立场。但是，请注意，贝丝并没有提供任何正当的理由让乔治接受她的观点。\n诉诸地位\n有些人非常在意社会地位。他们炫耀这个是Gucci牌的，那个是Pucci牌的，他们开国外名车，他们无论买什么东西，名牌商标总是最重要的。这些人觉得，财富外露会让他们显得更加重要、更加与众不同、更加优雅或更加精明老练。这些人更容易受到声称能提高社会地位的诉求蛊惑：“充分彰显你独一无二的品位”是为一支150美元的圆珠笔打广告。毋庸置疑，一个人独特地位的取得是靠他的行为而不是靠他使用的产品。但这些人对烤鸡配米饭不屑一顾，却对arrozconpollo（西班牙语：西班牙米烧鸡）趋之若鹜。\n诉诸潮流\n此种诉求有些类似于诉诸地位，但不同之处在于，它诉诸我们内心渴望的归属感、不落人后。我们被鼓励到国外旅游，因为一切有品位的人都这么做。我们被鼓励到乡村买宅邸，因为我们的邻居有乡间别墅。日常生活中，“如果有一千万的家庭主妇使用Sparkle产品，你不是也应该使用Sparkle产品吗！”又是如此，像所有的感性诉求一样，我们去国外、买乡间别墅或者使用Sparkle的产品并没有合理的理由。唯一的理由就是不甘人后。\n诉诸信任\n有人说你不赞同他就意味着你不爱他或者不信任他。“要么与我同一阵线，要么与我为敌！”“如果你以前真正地信任我，你早该和我在一起了。”这种手段并不公平。你赞成一个人与否，与你对此人的喜爱毫无瓜葛。不与某人为伍并不意味着你不爱某人或者不信任某人。在接受任何思想路线或者同意任何行动方案之前，你应该首先确定接受或者同意的理由。否则你的行为可能是不负责任的。此类感性诉求有个共同的名称——诉诸友情。我们应该记得，真正的友情有时候需要我们投反对票。\n诉诸自豪或忠诚\n“如果你真的为自己的国家感到自豪，真的想看到它繁荣富强，那就买储蓄债券吧。”“你什么意思——你一张教会抽奖券都不买吗？你想干什么，反对教会吗？”“你再也不带我出去吃饭了，你就是嫌弃我，你再也不爱我了。”诉诸自豪或忠诚通常是一种令人眩目的过度简单化。不购买储蓄债券并不意味着对国家不忠诚。不购买抽奖券并不意味着对教会不忠诚。不带妻子出去吃饭并不意味着你不再以她为荣，或者不再爱她。诉诸真诚。此种诉求非常有效，尤其适用于演技派。这种人采用认真、诚挚、不出风头且绝对谦卑的语气，看上去此人说话绝对发自肺腑，他频频止声，仿佛很难找到合适的词语表达他的下一想法。他的感情是如此深沉，以至于一般的语言无法表达。他不断地重复字词以示强调。加强语气的动词形式（以语气助词does和do的形式）和副词——真实地（really）、千真万确地（genuinely）、实实在在地（truly）、绝对无疑地（absolutely）、实事求是地（actually）——都是用来加强真诚感。\n诉诸群众\n最后一个感性诉求可能涵盖了许多本章提到的其他诉求，也许是大部分诉求。这是对群众的诉求，对暴民的诉求，对议会旁听者的诉求。一概而论、陈腔滥调、标语口号、老生常谈、道貌岸然地哗众取宠以及歌颂大众等泛滥成灾。\n最后，有一点必须反复申明，感性诉求并非本身有错。有时候，这样的诉求只是反映了内心深处的感受或者信念。那位妻子也许真的被她心里认为“丈夫冷落自己”给伤害了，在她对自尊进行感性诉求时，情感自然流露出来。那位机修工有可能真的认为你的传动装置即将导致严重问题，他可能把诉诸恐惧作为一种便捷的手段，让你做出他认为必要的防备。而道奇欧米尼也许就是一部绝世好车。重要的是，你要认识到感性诉求可能反映了某些未言明的感受或信念，还留有一条底线未被明确地表达，或者还有一条隐藏的事项未被确认。一方面，也许那位试图说服你购买教会抽奖券的人是真的很想帮助教会；另一方面，也许他只是想完成抽奖券配额任务。永远记得找出什么是底线，或者探明隐藏的事项。感觉很重要，但人不能只依赖感觉行事。行动必须要有理性。正是由于理性的含糊不清，感性诉求才变得危险。\n","categories":["有毒的逻辑"]},{"title":"第3章 感性的语言：宣传鼓动","url":"/2022/02/15/%E7%AC%AC3%E7%AB%A0%20%E6%84%9F%E6%80%A7%E7%9A%84%E8%AF%AD%E8%A8%80-%E5%AE%A3%E4%BC%A0%E9%BC%93%E5%8A%A8/","content":"\n  我了解你们人类。你们都是乖乖听话的羔羊。\n\n在广泛意义上，宣传鼓动只不过是一种说服手段，一种诉诸感性而非诉诸理性的形式。它依赖于人们对暗示的感受。它企图诱使我们以特 定的方式来行动或思考；它企图影响我们的信念并最终影响我们的态度。它的手段通常狡猾而隐秘。鼓吹者不会当面摊开他的手牌；有一个隐藏的动机，一条底线，隐而不发。\n成功的鼓吹者善于俘获我们的情感。他大量运用第2章所提到的感性诉求。他说着我们想听的话，赢取我们的信任，然后开始巧妙地影响我们的态度。鼓吹者几乎从不为其所倡导的内容提供完好的理由。即使他提供证据，也是精心选择之后的一面之词。他将事情过度简单化，并且常常任意歪曲事实。\n以下详细说明鼓吹者可能采取的一些策略。\n随波逐流。\n“大家都这么做。所以，你也应该这样做。”显然，此命题过度简单化，并不是大家都这么做。随波逐流策略至少发挥了两方面作用。\n\n第一，它企图造成一种印象，有许多人都在做某件事情或者支持某种立场；然后它暗示群众的判断是合理的：如果这么多人都这么做，那它一定是对的。\n第二，更重要的一点，随波逐流策略是满足我们内心归属需要的一种情感诉求。我们不想被别人抛弃。“所以，跳到乐队花车上来。融入狂欢的人潮，享受快乐和安全感。”\n\n不断重复。\n鼓吹者反复地诉说某事。他每次可能使用不同的措辞，但主题却始终如一。此种理论就是，如果你重复诉说的次数足够多，人们终究会相信你。\n自信。\n鼓吹者的谈吐也是自信满满的。他留给人的印象是知道自己在说什么。他的声音铿锵有力，他的表情大义凛然，他的肢体动作坚毅果敢。此处的理论如下：如果有人如此自信，如果他对自己的立场如此确信无疑，那他肯定是对的。人们喜欢支持胜利者，而自信的姿态使人看起来像个胜利者。\n认真和真诚。\n一个人外表看起来越是认真和真诚，越容易获得人们的信任。\n过度简单化。\n鼓吹者选取事物的一个方面，并且把它视为宛如仅有的一个方面。比如参与党派竞选的候选人可能只会提及对手的弱点，完全忽略对手的优势所在。他选取一个复杂的问题，然后将其简化到极致，通常以“要么......要么......”二者择其一的方式呈现该问题：“要么你跟随我，那样对大家都好，要么你不跟随我，那样必定损失惨重。”\n污名辱骂。\n鼓吹者对不喜欢的人物或者观点冠以污辱性的绰号，或者使用引起强烈贬损意味的名称；对喜欢的人物或观点，则致以谄媚般的称呼，或者使用引起强烈褒扬意味的名称。他打算用他的命名来影响我们的态度。他们有时候也会使用“标签”：“种族主义者”“无政府主义者”“社会主义者”“激进分子”“反动派”。\n刻板印象(心理定式)。\n这是污名辱骂和过度简单化的一种变式。鼓吹者抓住对方的某一性格特征，经过夸张变形，然后视之为唯一的性格特征。这个技巧曾被用来反对已故前副总统休伯特·汉弗莱，不断有人把他画成漫画形象的风囊(比喻饶舌之人)来进行讽刺。刻板印象剥夺一个人的复杂性和独特性，将其简化为一种品质。\n光芒万丈的泛泛而谈。\n鼓吹者发表大而无当、概括笼统的言论，通常这种言论会带来盘根错节、影响深远的复杂后果，而他却故意忽略这种复杂性和纠纷。他痛斥在野党剥削穷人，没有争取到有效的税制改革立法，但他本身却开不出良方。他沉浸在泛泛而谈的满足中，自鸣得意。光芒万丈的泛泛而谈很安全：如果连具体规划都没提供，又怎么会受到批评呢?\n标语口号。\n受众会记住讨巧的标语口号，而不去质疑标语口号本身的意义——实际上，甚至不会思考标语口号的意义：美国——要么爱，要么走开。要爱情而不要战争。如果枪械是不合法的，那只有不法之徒才能拥有枪械。\n传递。\n这个技巧鼓励我们将情感传递下去。香烟广告经常使用这种技巧。香烟总是一成不变地设计在一些豪华的田园风光里，放在一片深绿之中。然后还有万宝路牛仔和维珍妮香烟女郎：“宝贝，你真是远道而来。”传递的技巧在于它了解我们对自己土地的自豪感，我们向往田园的美丽风光，我们崇拜粗犷的万宝路牛仔和苗条的维珍妮香烟女郎，它邀请我们将积极正面的情感传递至所推销的主体上。\n代言。\n这是传递策略的一种变式。重要或杰出的人物或组织为一个观念或者产品代言。我们仅仅因为杰出的人物为其代言，而被鼓励去支持这种观念或者产品。该理论如下：X是一位重要人物；除非X更杰出或者比我们更有见识，否则他不会如此重要；既然X如此重要，因此他更杰出或者比我们更有见识；因此，他知道自己在说什么；因此，我们应该相信他。我们被鼓励将对此人的肯定传递至他背书的观念或者产品。\n平民百姓。\n“我和你们一样。”鼓吹者有时候企图通过我们对他的身份认同，从而赢得我们的支持。他参加镇民大会，拜访医院，不拘礼节地摆姿势拍照片。吉米·卡特总统就使用过这种技巧，当他在电视上露面时，他穿便装毛衣而不穿正装。这里的技巧被用于高尚的目标：节约能源。如果总统都能通过明智地选择穿衣而节约能源，我们难道不应该这样吗?\n宣传鼓动可以用于不光彩的目的，也可以用于高尚的目标。因此我需要再重复一遍定义：宣传鼓动仅仅是一种说服手段。平民百姓策略背后的理论认为，如果我们认同某人，我们就会支持他的说法。该策略是传递策略的一种变式。\n讲究派头的诉求。\n另一方面，宣传鼓动可能利用人们对社会地位的需求，或者利用人们对特殊待遇的渴望：“适合具有独特鉴赏能力的人群”“并非所有人都能拥有”“品质专为有品位的人”“一探高雅”“为在意的人，奉献最好的”......\n缺少背景知识的统计数据。\n鼓吹者可能给你提供大量的统计数据，但很少会告诉你这些数据的背景知识。他几乎不会告诉你他是如何收集这些数据的，数据来自哪里，或者有多少人参与了投票。只要找对五个人，你几乎可以让任何事情都收获80%的支持率。\n大数字。\n这是随波逐流(乐队花车)策略的一种变式。欧莱雅染发剂广告宣称：“全世界超过25万名美发师相信欧莱雅染发剂适合你，还需要多说什么?欧莱雅，25万名美发师绝不会错。”\n**人为捏造的困难——坏人，替罪羊。\n鼓吹者人为捏造困难或者夸大困难，企图让你相信问题如何严重，然后通过将问题归咎于某人，或者暗示他的建议可以解决困难，来为你排忧解难。鼓吹者常常需要一个坏人，一个牺牲品或替罪羊，供其强烈谴责。他的义愤填膺使其听起来真诚可靠，也让他所谈及的问题听起来越发严重而紧急。\n彻底扭曲。\n有时候鼓吹者筛选信息以呈现片面的观点；有时候他甚至编造数据以达到个人目的；有时候他就直接撒谎。由于我们不知道事实真相，我们就无法质疑他。由于我们无能为力，就像他背对着我们洗牌，而他却能看到底牌；因此，这个策略有时候被称为作弊洗牌法。\n指挥命令。\n这种策略有危险，因为它很容易适得其反。有些人很乐意按照指令行事。当鼓吹者发出指令，他就在诉诸渴望权威的需求。\n再次说明，这一点必须着重强调，就像感性诉求并非本身有错一样，宣传鼓动也无本质错误。但是，我们必须认识到宣传鼓动的本质，拒绝任其摆布。\n[1]刻板印象主要指人们对某个事物形成一种概括固定的看法，并把这种看法推而广之，认为这个事物或整体都具有该特征，而忽视个体差异。——译者注\n","categories":["有毒的逻辑"]},{"title":"机器学习数学基础：线性代数","url":"/2022/01/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","content":"本章介绍线性代数中向量、内积、范数、矩阵、线性变换、二次型、矩阵分解等基本知识。\n1 行列式\n线性代数中，行列式是一个函数，和矩阵有一定的关系。几何上，行列式可以看作有向面积或体积的概念在一般的欧几里得空间中的推广。\n1.1 二阶与三阶行列式\n可用来解决线性方程求解的问题，同时注意对角线法则只适用于二阶和三阶的行列式。\n表达式 \\[\nD=a_{11}a_{22}-a_{12}a_{21}=\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12}\\\\\n   a_{21} &amp; a_{22} \n  \\end{matrix}\n  \\right]\n\\] 称为数表的二阶行列式，记作 \\(D=det(a_{ij})\\) .\n三阶行列式定义为 \\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}\n\\]\n1.2 全排列和对换\n全排列的定义：由 \\(1\\) 到 \\(n\\) 个数组成的一个有序数组称为一个n级全排列，通常用 $ P_n$ 表示。 \\[\nP_n=n\\times (n-1)\\times \\dots\\times3\\times2\\times1=n!\n\\] 逆序数的定义：在一个排列中，如果两个数（称为数对）的前后位置与大小顺序相反，即前面的数大于后面的数，那么称它们构成一个逆序（反序）。一个排列中所有逆序的总数称为此排列的逆序数。分别计算出排在 \\(1,2,\\dots,n-1,n\\) 前面比它大的数码之和。 \\[\nt=t_1+t_2+\\dots+t_n=\\sum_{i=1}^nt_i\n\\] 此外，还有奇排列和偶排列的概念，即奇排列为逆序数为奇数的排列。\n对换的定义：在排列中，将任意两个元素对调，其余元素不动，就得到另一个排列，这样的一个变换叫作对换。将相邻的两个元素对换，叫作相邻对换。其中，一个排列中任意两个元素对换，排列改变奇偶性。\n1.3 n阶行列式\n\\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=\\sum(-1)^ta_{11}a_{22}a_{33}\n\\]\n可推广至n阶，其中 \\(t\\) 为列标排列的逆序数。\n1.4 几种特殊行列式的值\n上、下三角行列式，对角行列式，特殊行列式（类似反的下三角行列式）\n如果是计算的是主对角线的值，则直接连乘；如果是副对角线，则需加一个系数 \\((-1)^{\\frac{n(n-1)}{2}}\\).\n一些其他的见知乎：https://zhuanlan.zhihu.com/p/34685081。\n1.5 n阶行列式的性质\n\n性质1：行列式与它的转置行列式相等。\n性质2：互换行列式的两列，行列式变号。（推论：两行或两列相同，此行列式等于零）。\n性质3：行列式的某一行（列）中所有元素都乘同一数 \\(k\\)，等于用数 \\(k\\) 乘此行列式。\n性质4：行列式中如果有两行（列）元素成比例，则此行列式等于零。\n性质5：若行列式的某一列（行）的元素都是两数 之和，则该行列式等于两个行列式之和。\n性质6：把行列式的某一列（行）的各个元素乘同一个数，然后加到另一列（行）对应的元素上去，行列式的值不变。\n\n2 用向量描述空间\n2.1 向量及其运算\n\\(n\\) 维空间用 \\(\\pmb{R}^n\\) 表示，上标 \\(n\\) 表示空间的维度。\n2.2 向量组的线性组合\n若干个同纬度的列向量（或同纬度的行向量）所组成的集合叫作向量组。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和一组实数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，那么表达式 \\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)称为向量组 $ $ 的一个线性组合。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和向量 \\(\\pmb{b}\\)，如果存在一组数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得 \\(\\pmb{b}=\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)，则向量 \\(\\pmb{b}\\) 是向量组 \\(\\pmb{A}\\) 的线性组合，这时称向量 \\(\\pmb{b}\\) 能由向量组 \\(\\pmb{A}\\) 线性表示，也就是对应的方程组有解。\n2.3 向量组的线性相关性\n向量组的线性相关性的定义：给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) ，如果存在不全为0的数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得\\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m=0\\)，则称向量组 \\(\\pmb{A}\\) 是线性相关的。\n线性相关的充要条件是：向量组中至少有一个向量可以由其他所有向量线性表示。\n3 内积、正交向量组和范数\n3.1 内积\n向量之间的乘法可分为内积和外积，一般用内积比较多。内积的直接描述为某一向量在另一个向量方向上的投影长度。\n内积的定义：设有 \\(n\\) 维向量 \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，\\(\\pmb{y}=\\left(\\begin{matrix}  y_1 \\\\  y_2\\\\ \\vdots \\\\ y_n  \\end{matrix}\\right)\\)，令\\(（\\pmb{x},\\pmb{y}）=x_1y_1+x_2y_2+\\dots+x_ny_n\\)，\\(（\\pmb{x},\\pmb{y}）\\)称为向量 \\(\\pmb{x}\\) 和向量 \\(\\pmb{y}\\) 的内积，也可以表示为 \\(\\pmb{x·}\\pmb{y}\\).\n3.2 正交向量组和施密特正交化\n正交向量的定义：如果两向量的内积为零，则称它们正交。\n正交向量组的定义：如果向量组中任意两个向量都正交且不含零向量，则称为正交向量组，并且正交向量组是线性无关的。\n标准正交向量：向量组内向量彼此之间的点积为 \\(0\\)，与自身的点积为 \\(1\\)。\n施密特正交化详见：\n如何理解施密特（Schmidt）正交化：https://zhuanlan.zhihu.com/p/136627868。\n3.3 范数\nwiki——矩阵范数\n向量范数的定义：如果向量 \\(\\pmb{a} \\in \\pmb{R}^n\\) 的某个实值函数 $f()=|||| $ 满足\n\n非负性：\\(||\\pmb{a}||\\geq 0\\) ，且\\(||\\pmb{a}||=0\\) 当且仅当 \\(\\pmb{a}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{a}||=|\\lambda|||\\pmb{a}||\\)\n三角不等式：对于任意 \\(\\pmb{a,b}\\in\\pmb{R}^n\\)，都有 \\(||\\pmb{a+b}||\\leq||\\pmb{a}||+||\\pmb{b}||\\)\n\n常用的向量范数有 $ 1$ -范数、\\(2\\) -范数和 \\(\\infty\\) -范数。\n\n$ 1$ -范数：也称为曼哈顿距离 \\[\n  ||\\pmb{a}||_1=\\sum_i^n|\\pmb{a}_i|\n  \\]\n\\(2\\) -范数：也称为欧几里得范数\n\n\\[\n||\\pmb{a}||_2=\\sqrt{\\sum_{i=1}^n\\pmb{a}_i^2}\n\\]\n\n\\(\\infty\\) -范数：所有向量元素中的最大值 \\[\n  ||\\pmb{a}||_\\infty=\\max_i|a_i|\n  \\]\n\n矩阵范数的定义：如果矩阵 \\(\\pmb{A} \\in \\pmb{R}^{n\\times n}\\) ，若按某一确定的法则对应于一个非负实数 $|||| $ 满足\n\n非负性：\\(||\\pmb{A}||\\geq 0\\) ，且\\(||\\pmb{A}||=0\\) 当且仅当 \\(\\pmb{A}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{A}||=|\\lambda|||\\pmb{A}||\\)\n三角不等式：对于任意 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{A+B}||\\leq||\\pmb{A}||+||\\pmb{B}||\\)\n相容性：对于任意的 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{AB}||\\leq||\\pmb{A}||||\\pmb{B}||\\)\n\n常用的矩阵范数有 $ 1$ -范数、\\(2\\) -范数、 \\(\\infty\\) -范数和 \\(F\\) -范数。\n\n$ 1$ -范数：又称为列和范数。顾名思义，即矩阵列向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_1=\\max_j\\sum_i^m|a_{ij}|\n  \\]\n\\(2\\) -范数：又称为谱范数，计算方法为 \\(\\pmb{A^TA}\\) 矩阵的最大特征值开平方。\n\n\\[\n||\\pmb{A}||_2=\\sqrt{\\lambda_1}\n\\]\n\n\\(\\infty\\) -范数：又称为行和范数。顾名思义，即矩阵行向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_\\infty=\\max_i\\sum_j^n|a_{ij}|\n  \\]\n\\(F\\) -范数：又称为Frobenius范数，计算方法为矩阵元素的绝对值的平方和再开方。 \\[\n||\\pmb{A}||_F=\\sqrt{\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|}\n\\]\n\n习题：Python编程实现求向量范数和矩阵范数。\n# -*- coding: UTF-8 -*-import numpy as npa=np.array([2,4,5,8,-3])print(&#x27;向量a：&#x27;,a)print (&#x27;向量a的1-范数:&#x27;)print(np.linalg.norm(a,ord=1))print (&#x27;向量a的2-范数:&#x27;)print(np.linalg.norm(a,ord=2))print (&#x27;向量a的∞-范数:&#x27;)print(np.linalg.norm(a,ord=np.inf))# -*- coding: UTF-8 -*-import numpy as npA=np.arange(3,15).reshape(3,4)print(&#x27;矩阵A：&#x27;,A)print(&#x27;矩阵A的1-范数:&#x27;)print(np.linalg.norm(A,ord=1))print(&#x27;矩阵A的2-范数:&#x27;)print(np.linalg.norm(A,ord=2))print(&#x27;矩阵的∞-范数:&#x27;)print(np.linalg.norm(A,ord=np.inf))print(&#x27;矩阵A的F-范数:&#x27;)print(np.linalg.norm(A,ord=&#x27;fro&#x27;))print(&#x27;矩阵A列向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=0))print(&#x27;矩阵A行向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=1))\n4 矩阵和线性变换\n4.1 矩阵及其运算\n一些不想敲的概念：\n\n矩阵的定义。\n特殊的矩阵：行矩阵（也叫行向量）、列矩阵（也叫列向量）、方阵（\\(\\pmb{A}_n\\)），三角矩阵、单位矩阵、对称矩阵、对角矩阵、实对称矩阵、零矩阵、正交矩阵。\n矩阵的运算：加法、数乘、乘法、转置、行列式（\\(|\\pmb{A}|\\) 或 \\(det(\\pmb{A})\\)).\n\n4.2 逆矩阵\n对于 \\(n\\) 阶矩阵 \\(\\pmb{A}\\) ，如果有一个 \\(n\\) 阶矩阵 \\(\\pmb{B}\\) ，使得 \\(\\pmb{AB=BA=E}\\)，则称矩阵 \\(\\pmb{A}\\) 是可逆的，并把矩阵 \\(\\pmb{B}\\) 称为 \\(\\pmb{A}\\) 的逆矩阵，记作 \\(\\pmb{A}^{-1}\\) .\n\n若矩阵 \\(\\pmb{A}\\) 可逆，则 \\(|\\pmb{A}| \\neq 0\\) .\n若 \\(|\\pmb{A}| \\neq 0\\)，则矩阵 \\(\\pmb{A}\\) 可逆，且 \\(\\pmb{A}^{-1}=\\frac{1}{|\\pmb{A}|}\\pmb{A}^*\\)，其中 \\(\\pmb{A}^*\\) 为矩阵 \\(\\pmb{A}\\) 的伴随矩阵。\n\n4.3 矩阵的初等变换\n\n对调两行\n数乘\n数乘再相加\n\n4.4 标量对向量的导数、最小二乘法\n\nxxds\n\n详见：\n系列：机器学习中的矩阵向量求导\n单列一个：机器学习中的矩阵向量求导(二) 矩阵向量求导之定义法\n最小二乘法及python代码：最小二乘法（least sqaure method）\n4.5 线性变换\n线性变换的定义：设 \\(\\pmb{V}\\) 为一个线性空间，映射 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个变换，若 \\(f\\) 保持 \\(\\pmb{V}\\) 的加法与数乘运算，则称 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个线性变换。\n线性变换把一个向量空间里的向量映射到了另一个向量空间里的另一个向量，因此，我们可以把线性变换理解成输入一个向量，然后输出一个向量的特殊函数。\n它可以看成一个动态的过程，比如旋转、伸缩或者投影之类的升降维的操作。\n常见的线性变换还有：恒等变换（单位变换）、求微商（线性空间 \\(P[x]\\) 内）、求定积分。\n详见：线性变换（一）【直观理解线性变换】\n4.6 矩阵的秩\n一些概念：矩阵的秩、行秩、列秩和极大无关向量组。\n定理：设 \\(n\\) 元线性方程组 \\(\\pmb{Ax=b}\\) ，\\(R(\\pmb{A})\\) 表示系数矩阵 \\(\\pmb{A}\\) 的秩，\\(R(\\pmb{A,b})\\) 表示增广矩阵 \\(\\pmb{B=(A,b)}\\) 的秩，则该线性方程组\n\n无解的充要条件是 : \\(R(\\pmb{A})&lt;R(\\pmb{A,b})\\)；\n有唯一解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})=n\\)；\n有无限多解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})&lt;n\\) .\n\n一些概念：线性方程组的解、方阵的特征值和特征向量\n习题：Python编程实现求逆矩阵、行列式的值、秩\nimport numpy as np# a=np.array([[1,4,7],[2,5,8],[3,6,9]])# a=np.array([[1,2,3],[4,5,6]])A=np.array([[1,4,9],[2,5,8],[3,6,9]])print(&quot;A矩阵为：&quot;)print(A)print(&#x27;*&#x27;*40)F = np.linalg.inv(A)print(&quot;A矩阵的逆矩阵为：&quot;)print(F)print(&#x27;*&#x27;*40)print(&quot;A矩阵与其逆矩阵乘积为：&quot;)print(np.dot(A,np.linalg.inv(A)))print(np.dot(A,np.linalg.inv(A)).astype(int))print(&#x27;*&#x27;*40)print(&quot;A矩阵的行列式的值为：&quot;)print(np.linalg.det(A))print(&#x27;*&#x27;*40)print(&quot;A矩阵的秩为：&quot;)print(np.linalg.matrix_rank(A))\n5 二次型\n5.1 二次型的定义\n即二次齐次函数（\\(x^2,x_1x_2,\\dots\\)，类似平方项展开加上系数）。二次型的标准型可理解为只含平方项的二次型。\n若 \\(\\pmb{A}\\) 为对称矩阵， \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，则 \\(f=\\pmb{x^TAx}\\) 也是二次型的一种形式，对成矩阵 \\(\\pmb{A}\\) 叫作二次型 \\(f\\) 的矩阵，也把 \\(f\\) 叫作对称矩阵 \\(\\pmb{A}\\) 的二次型。对称矩阵 \\(\\pmb{A}\\) 的秩就叫做二次型 \\(f\\) 的秩。\n5.2 用正交变换化二次型为标准型\n\n将二次型 \\(f=\\sum_\\limits{i=1}^n\\sum_\\limits{j=1}^na_{ij}x_ix_j\\)，写成矩阵形式 \\(f=\\pmb{x^TAx}\\) .\n由 \\(|\\pmb{A-\\lambda E}|=0\\)，求出 \\(\\pmb{A}\\) 的全部特征值。\n由 \\((\\pmb{A-\\lambda E})\\pmb{x}=0\\)，求出 \\(\\pmb{A}\\) 的特征向量。\n\n对于求出的不同特征值所对应的特征向量已正交，只需要单位化；对于 \\(k\\) 冲特征值 \\(\\lambda\\) 所对应的 \\(k\\) 个线性无关的特征向量，用施密特正交化方法把它们化成 \\(k\\) 个两两正交的单位向量。\n\n把求出的n个两两正交的单位向量拼成正交矩阵 \\(\\pmb{P}\\)，作正交变换 \\(\\pmb{x=Py}\\).\n用 \\(\\pmb{x=Py}\\) ，把 \\(f\\) 化成标准型 \\(f=\\lambda_1y_1^2+\\lambda_2y_2^2+\\dots+\\lambda_ny_n^2\\)，其中 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_n\\)是矩阵 \\(\\pmb{A}=(a_{ij})\\) 的特征值。\n\n5.3 二次型的正定型\n正定二次型、惯性定理、和赫尔维茨定理（后两个是判定定理）。\n麻省理工线性代数笔记（二十四）-正定矩阵\n6 矩阵分解\n矩阵分解有很多种，如 \\(LU\\) 分解、\\(QR\\) 分解、特征值分解（\\(EVD\\) ）和奇异值分解（\\(SVD\\) ）。\\(LU\\) 分解是将满秩矩阵分解为两个倒扣的三角形，即分解成下三角矩阵和上三角矩阵的乘积，它的意义在于求解大型方程组。QR分解经常用来解线性最小二乘法问题，它和机器学习的相关算法密切。特征值分解的方法也非常有效，但有一些局限性，即要求矩阵必须是方阵且能够被对角化。奇异值分解可以对任意形状的矩阵进行分解，实用性更广。\n麻省理工线性代数笔记（二十六）-奇异值分解\n【学长小课堂】什么是奇异值分解SVD--SVD如何分解时空矩阵\n\n\n\n李航统计学习之奇异值分解（SVD）\n习题：实现矩阵的QR分解\nimport numpy as npM= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)Q=np.zeros((4, 3))j = 0for a in M.T:    b = np.copy(a)    for i in range(0, j):        b = b - np.dot(np.dot(Q[:, i].T, a), Q[:, i])    e = b / np.linalg.norm(b)    Q[:, j] = e    j += 1R = np.dot(Q.T, M)np.set_printoptions(precision=3,suppress=True)print(&#x27;Gram-schmidt正交化变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))#方法二import numpy as npnp.set_printoptions(precision=4, suppress=True)M= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)s = 4t = 3Q = np.identity(s)R = np.copy(M)for j in range(s - 1):    x = R[j:, j]    E = np.zeros((4, 3))    E = np.zeros_like(x)    b = x - E    d = b / np.linalg.norm(b)    Q_j = np.identity(s)    Q_j[j:, j:] -= 2.0 * np.outer(d, d)    R = np.dot(Q_j, R)    Q = np.dot(Q, Q_j)np.set_printoptions(precision=3,suppress=True)print(&#x27;Householder变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))\nQ：奇异值分解的应用场景有哪些?\n\\(SVD\\) 的应用有很多，可以说，\\(SVD\\) 是矩阵分解、降维、压缩、特征学习的一个基础工具，所以 \\(SVD\\) 在机器学习领域相当的重要。\n\\(SVD\\) 在降维中作用如何呢？通过 \\(SVD\\) 的公式可以看出，原来矩阵 $ $ 的特征有 \\(n\\) 维，经过 \\(SVD\\) 后，可以用前 \\(r\\) 个非零奇异值对应的奇异向量表示矩阵\\(\\pmb{A}\\) 的主要特征，这样就把矩阵 $ $ 进行了降维。\n\\(SVD\\) 在压缩中作用如何呢？机器学习最基本和最有趣的特征之一是数据压缩概念的相关性。如果我们能提取有用的数据，我们就能用更少的比特位来表达数据。从信息论的观点来看，数据之间存在相关性，则有可压缩性。通过 \\(SVD\\) 的公式可以看出，矩阵 $ $ 经过 \\(SVD\\) 后，要表示原来的大矩阵 $ $ ，我们只需要存储 \\(\\pmb{U,\\Delta,V}\\) 三个较小的矩阵即可。而这 \\(3\\) 个较小规模的矩阵占用内存上也是远远小于原有矩阵 $ $ 的，这样 \\(SVD\\) 就起到了压缩的作用。\n\\(SVD\\) 和主成分分析有什么关系呢？\\(PCA\\) 即主成分分析方法，是一种使用最广泛的数据降维算法。\\(PCA\\) 的主要思想是将n维特征映射到 $ m$ 维上，这 \\(m\\) 维是全新的正交特征，也被称为主成分，是在原有 \\(n\\) 维特征的基础上重新构造出来的 \\(m\\) 维特征。\\(PCA\\) 的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。\\(PCA\\) 算法有两种实现方法，即基于特征值分解协方差矩阵实现 \\(PCA\\) 算法和基于 \\(SVD\\) 协方差矩阵实现 \\(PCA\\) 算法。所以，\\(SVD\\) 是 \\(PCA\\) 算法的一种实现方法。\n我们再来看一下潜在语义索引，它是一种简单实用的主题模型。潜在语义索引是一种利用 \\(SVD\\) 方法获得在文本中术语和概念之间关系的索引和获取方法。该方法的主要依据是在相同文章中的词语一般有类似的含义，可以从一篇文章中提取术语关系，从而建立起主要概念内容。潜在语义索引不同于 \\(PCA\\) ，至少不是实现了 \\(SVD\\) 就可以直接用的，但它也是一个高度依赖 \\(SVD\\) 的算法。\n","categories":["机器学习数学基础"]},{"title":"Bonuses","url":"/2022/02/18/Bonuses/","content":"Bonuses\nJohn wants to give a total bonus of $851 to his three employees taking fairly as possible into account their number of days of absence during the period under consideration. Employee A was absent 18 days, B 15 days, and C 12 days.\nThe more absences, the lower the bonus ...\nHow much should each employee receive? John thinks A should receive $230, B $276, C $345 since 230 * 18 = 276 * 15 = 345 * 12 and 230 + 276 + 345 = 851.\nTask\nGiven an array arr (numbers of days of absence for each employee) and a number s (total bonus) the function bonus(arr, s) will follow John's way and return an array of the fair bonuses of all employees in the same order as their numbers of days of absences.\ns and all elements of arr are positive integers.\nExamples\nbonus([18, 15, 12], 851) -&gt; [230, 276, 345]bonus([30, 27, 8, 14, 7], 34067) -&gt; [2772, 3080, 10395, 5940, 11880]\nNotes\n\nSee Example Test Cases for more examples.\nPlease ask before translating.\nIn some tests the number of elements of arr can be big.\n\nAnswer\ndef bonus(arr, s):    # your code    s=s/(sum(1/n for n in arr))    return [round(s/n) for n in arr]  def bonus2(arr, s):  \tls=[]\t\td=sum([1/x for x in arr])\t\tfor i in arr:\t\t\t\tls.append(s/i/d)\t\treturn list(map(round, ls))\nTimeerror or Overflowerror\ndef bonus(arr, s):\t\tmul = reduce(lambda x, y:x * y, arr)\t\tdenominator = 0\t\tfor i in arr:      \tdenominator = denominator + mul//i     ls=[]    for i in arr:        ls.append(mul*s/i/denominator)    return list(map(round,ls))\nSomething else\n- inverse variation\nIn Maths, inverse variation is the relationships between variables that are represented in the form of y = k/x, where x and y are two variables and k is the constant value. It states if the value of one quantity increases, then the value of the other quantity decreases.\n\n\n\n- Overflowerror：integer division result too large for a float\nIn Python 3, number / 10 will try to return a float. However, floating point values can't be of arbitrarily large size in Python and if number is large an OverflowError will be raised.\nYou can find the maximum that Python floating point values can take on your system using the sys module:\n&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.float_info.max1.7976931348623157e+308\nTo get around this limitation, instead use // to get an integer back from the division of the two integers:\nnumber // 10\nThis will return the int floor value of number / 10 (it does not produce a float). Unlike floats, int values can be as large as you need them to be in Python 3 (within memory limits).\n- cyc（Cyclic Sum）\n\\[\n\\sum _{cyc}f(x_1,x_2,\\cdots,x_n)=f(x_1,x_2,\\cdots,x_{n-1},x_n)+f(x_2,x_3,\\cdots,x_{n},x_1)+\\cdots +f(x_n,x_1,\\cdots,x_{n-2},x_{n-1})\\\\\n\\sum_{cyc}{f(a,b,c)}=f(a,b,c)+f(b,c,a)+f(c,a,b)\n\\]\n- sym（Symmetric Sum）\n\\[\n\\sum _{sym}f(x_1,x_2,\\cdots,x_n)=\\sum _{\\sigma}f(x_{\\sigma{(1)}},x_{\\sigma{(2)}},\\cdots,x_{\\sigma{(n)}})\n\\\\ \\sum\\limits_{sym}{f(a,b,c)}=f(a,b,c)+f(b,c,a)+f(c,a,b)+f(b,a,c)+f(c,b,a)+f(a,c,b)\n\\]\nwhere \\(\\sigma\\) is the permutation of \\((1,2,...,n)\\).\n","categories":["题解"]},{"title":"Ugly Number","url":"/2022/02/18/Ugly-Number/","content":"Definition\n\n\\(ugly\\) \\(number\\)：把只包含质因子 \\(2\\)，\\(3\\) 和 \\(5\\) 的数称作丑数（\\(Ugly\\) \\(Number\\)）。例如 \\(6\\)、 \\(8\\) 都是丑数，但 \\(7\\) 、\\(14\\) 不是，因为它们包含质因子 \\(7\\) 。 习惯上我们把 \\(1\\) 当做是第一个丑数。\n\\(humble\\) \\(number\\)：对于一给定的素数集合 \\(S = {p_1, p_2, ..., p_K}\\) , 考虑一个正整数集合，该集合中任一元素的质因数全部属于 \\(S\\) 。这个正整数集合包括，\\(p_1、p_1*p_2、p_1*p_1、p_1*p_2*p_3...\\) 。该集合被称为 \\(S\\) 集合的 “丑数集合” 。\n\nLeetCode 263. Ugly Number\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\nExample 1\nInput: n = 6Output: trueExplanation: 6 = 2 × 3\nExample 2\nInput: n = 1Output: trueExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nExample 3\nInput: n = 14Output: falseExplanation: 14 is not ugly since it includes the prime factor 7. \nConstraints\n\n\\(-2^{31} &lt;= n &lt;= 2^{31} - 1\\)\n\nAnswer 1\n来源：LeetCode-Solution\n根据丑数的定义，0 和负整数一定不是丑数。\n当 \\(n&gt;0\\) 时，若 \\(n\\) 是丑数，则 \\(n\\) 可以写成 $n = 2^a ^b ^c $ 的形式，其中 \\(a,b,c\\) 都是非负整数。特别地，当 \\(a,b,c\\) 都是 \\(0\\) 时，\\(n=1\\)。\n为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5 ，直到 nn 不再包含质因数 2,3,5。若剩下的数等于 1，则说明 nn 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。\nclass Solution:    def isUgly(self, n: int) -&gt; bool:        if n &lt;= 0:            return False        factors = [2, 3, 5]        for factor in factors:            while n % factor == 0:                n //= factor                return n == 1\n复杂度分析\n时间复杂度：\\(O(\\log n)\\)。时间复杂度取决于对 \\(n\\) 除以 \\(2,3,5\\) 的次数，由于每次至少将 \\(n\\) 除以 \\(2\\)，因此除法运算的次数不会超过 \\(O(\\log n)\\)。\n空间复杂度：\\(O(1)\\)。\nAnswer 2\nclass Solution:    def isUgly(self, n: int) -&gt; bool:        if n &lt;= 0:            return False        while n % 2 == 0:            n //= 2        while n % 3 == 0:            n //= 3        while n % 5 == 0:            n //= 5        return n == 1\nLeetCode 264. Ugly Number II / 剑指 Offer 49. 丑数 LCOF\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.\nExample 1\nInput: n = 10Output: 12Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\nExample 2\nInput: n = 1Output: 1Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nConstraints\n\n\\(1 &lt;= n &lt;= 1690\\)\n\nAnswer\n来源：剑指 Offer 49. 丑数（动态规划，清晰图解）\nclass Solution:    def nthUglyNumber(self, n: int) -&gt; int:        dp, a, b, c = [1] * n, 0, 0, 0        for i in range(1, n):            n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5            dp[i] = min(n2, n3, n5)            if dp[i] == n2: a += 1            if dp[i] == n3: b += 1            if dp[i] == n5: c += 1        return dp[-1]\n","categories":["题解"]},{"title":"Look and say numbers","url":"/2022/02/19/Look-and-say-numbers/","content":"Look and say numbers\nThere exists a sequence of numbers that follows the pattern\n     1    11    21   1211  111221  312211 131122211113213211     .     .     .\nStarting with \"1\" the following lines are produced by \"saying what you see\", so that line two is \"one one\", line three is \"two one(s)\", line four is \"one two one one\".\nWrite a function that given a starting value as a string, returns the appropriate sequence as a list. The starting value can have any number of digits. The termination condition is a defined by the maximum number of iterations, also supplied as an argument.\nExample\nexpected = [&#x27;11&#x27;, &#x27;21&#x27;, &#x27;1211&#x27;, &#x27;111221&#x27;, &#x27;312211&#x27;, &#x27;13112221&#x27;, &#x27;1113213211&#x27;, &#x27;31131211131221&#x27;, &#x27;13211311123113112211&#x27;, &#x27;11131221133112132113212221&#x27;]result = look_and_say(&#x27;1&#x27;, 10)test.assert_equals(result, expected)expected = [&#x27;111312&#x27;, &#x27;31131112&#x27;, &#x27;1321133112&#x27;, &#x27;11131221232112&#x27;, &#x27;31131122111213122112&#x27;, &#x27;13211321223112111311222112&#x27;, &#x27;1113122113121122132112311321322112&#x27;, &#x27;311311222113111221221113122112132113121113222112&#x27;]result = look_and_say(&#x27;132&#x27;, 8)test.assert_equals(result, expected)\nAnswer 1 - groupby\nfrom itertools import groupbydef look_and_say(data=&#x27;1&#x27;, maxlen=5):    L = []    for i in range(maxlen):        data = &quot;&quot;.join(str(len(list(g)))+str(n) for n, g in groupby(data))        L.append(data)    return L\nfrom itertools import groupbydef look_and_say(data=&#x27;1&#x27;, maxlen=5):    data = &quot;&quot;.join(str(len(list(n))) + c for c, n in groupby(data))    return [data] + look_and_say(data, maxlen - 1) if maxlen else []\nAnswer 2 - two pointers\ndef say(string):  current, count, res = string[0], 0, &#x27;&#x27;  for char in string:    if char == current: count += 1    else:      res += str(count) + current      current, count = char, 1  res += str(count) + current  return resdef look_and_say(data=&#x27;1&#x27;, maxlen=5):  res = list()  for x in range(maxlen):    if x == 0: res.append(say(data))    else: res.append(say(res[x - 1]))  return res\ndef look_and_say(data=&#x27;1&#x27;, maxlen=5):    last = data[0]    cnt = 1    say = &quot;&quot;    for idx in range(1, len(data)):        if last != data[idx]:            say += str(cnt) + last            last = data[idx]            cnt = 1        else:            cnt += 1    say += str(cnt) + last    if maxlen == 1:        return [say]        return [say] + look_and_say(say, maxlen - 1)\ndef look_and_say(data=&#x27;1&#x27;, maxlen=5):    ls = list(data)    result = []    while maxlen:        num = ls[0]        s = &#x27;&#x27;        cnt = 0        while ls:            if ls[0] == num:                cnt += 1            else:                if cnt !=0:                    s = s + str(cnt) + num                num = ls[0]                cnt = 1            ls.pop(0)        if cnt !=0:            s = s + str(cnt) + num        maxlen -= 1        ls = list(s)        result.append(s)    return result\nAnswer 3 - re\nfrom re import subdef look_and_say(data=&#x27;1&#x27;, maxlen=5):    result = []    for _ in range(maxlen):        data = sub(r&#x27;(.)\\1*&#x27;, lambda m: str(len(m.group(0))) + m.group(1), data)        result.append(data)    return result\nimport redef look_and_say(data=&#x27;1&#x27;, maxlen=5):  l = [data]  for i in range(maxlen):    numstrs = re.findall(&#x27;1+|2+|3+|4+|5+|6+|7+|8+|9+&#x27;, l[i])    s = &#x27;&#x27;    for numstr in numstrs:      s += str(len(numstr)) + numstr[0]    l.append(s)  return l[1:]\nSomething else\n- itertools.groupby() in Python\nPrerequisites: Python Itertools\nPython’s Itertool is a module that provides various functions that work on iterators to produce complex iterators. This module works as a fast, memory-efficient tool that is used either by themselves or in combination to form iterator algebra.\nItertools.groupby()\nThis method calculates the keys for each element present in iterable. It returns key and iterable of grouped items.\nSyntax: itertools.groupby(iterable, key_func)Parameters:iterable: Iterable can be of any kind (list, tuple, dictionary).key: A function that calculates keys for each element present in iterable.Return type: It returns consecutive keys and groups from the iterable. If the key function is not specified or is None, key defaults to an identity function and returns the element unchanged.\nExample 1\n# Python code to demonstrate# itertools.groupby() methodimport itertoolsL = [(&quot;a&quot;, 1), (&quot;a&quot;, 2), (&quot;b&quot;, 3), (&quot;b&quot;, 4)]# guess L = [(&quot;a&quot;, 1),(&quot;b&quot;, 3),(&quot;b&quot;, 4),(&quot;a&quot;, 2)] , sort first？# Key functionkey_func = lambda x: x[0]for key, group in itertools.groupby(L, key_func):\tprint(key + &quot; :&quot;, list(group))\nOutput\na : [(&#x27;a&#x27;, 1), (&#x27;a&#x27;, 2)]b : [(&#x27;b&#x27;, 3), (&#x27;b&#x27;, 4)]\nExample 1\n# Python code to demonstrate# itertools.groupby() methodimport itertoolsa_list = [(&quot;Animal&quot;, &quot;cat&quot;),\t\t(&quot;Animal&quot;, &quot;dog&quot;),\t\t(&quot;Bird&quot;, &quot;peacock&quot;),\t\t(&quot;Bird&quot;, &quot;pigeon&quot;)]an_iterator = itertools.groupby(a_list, lambda x : x[0])for key, group in an_iterator:\tkey_and_group = &#123;key : list(group)&#125;\tprint(key_and_group)\nOutput\n&#123;&#x27;Animal&#x27;: [(&#x27;Animal&#x27;, &#x27;cat&#x27;), (&#x27;Animal&#x27;, &#x27;dog&#x27;)]&#125;&#123;&#x27;Bird&#x27;: [(&#x27;Bird&#x27;, &#x27;peacock&#x27;), (&#x27;Bird&#x27;, &#x27;pigeon&#x27;)]&#125;\n- RE (Regular Expression)\nYouTube：python基础 36 RegEx 正则表达式 (教学教程tutorial)\n","categories":["题解"]}]