[{"title":"Hello World","url":"/2022/01/04/hello-world/","content":"2022，你好。\n","categories":["hello"]},{"title":"一些解决方案","url":"/2022/01/09/%E4%B8%80%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"\n关于Hexo添加Mathjax相关问题及解决方法：https://d-veda.top/2018/11/11/Hexo-with-Mathjax/\nmarkdown中希腊字母加粗：https://blog.csdn.net/qq_28714865/article/details/103717900\n让公式中的某些数学符号加粗显示，可以使用\"​\"，比如 \\(\\mathbf{0123456789}\\) . 加粗希腊字母（比如书写向量或者矩阵时），使用\"\"，比如 \\(\\pmb{\\lambda}\\) .\nLaTeX输入单个点、横向多个点、竖向多个点、斜向多个点：https://blog.csdn.net/GarfieldEr007/article/details/51619866\n\n输入单个点：\n横向多个点：\n竖向多个点：\n斜向多个点：\n\n使用Markdown写矩阵：https://blog.csdn.net/qq_38228254/article/details/79469727\nJupyter notebook 运行时出现 “服务似乎挂掉了，但是会立刻重启的”：\n\nimport osos.environ[&#x27;KMP_DUPLICATE_LIB_OK&#x27;] = &#x27;TRUE&#x27;\n"},{"title":"八大常见类型的行列式及其解法","url":"/2022/01/09/%E5%85%AB%E5%A4%A7%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%B3%95/","content":"来源：https://zhuanlan.zhihu.com/p/34685081\n\n本文记录了八大常见类型的行列式及其解法，解法从一般性到特殊性都有，分享给大家，例子都特别经典好用，希望对线代、高代初学者以及考研党有用。\n\n类型总览：\n\n箭型行列式\n两三角型行列式\n两条线型行列式\n范德蒙德型行列式\n\\(Hessenberg\\)型行列式\n三对角型行列式\n各行元素和相等型行列式\n相邻两行对应元素相差K倍型行列式\n\n方法总览：\n\n拆行法\n升阶法\n方程组法\n累加消点法\n累加法\n递推法（特征方程法）\n步步差法\n\n一：箭型行列式\n最常见最常用的行列式，特征很好辨识，必须掌握，请看下例：\n\\[\neg:D_n= \\left|\\begin{array}{cccc} x_1&amp;1&amp;1 &amp;... &amp;1\\\\ 1&amp;x_2&amp;&amp;&amp;\\\\ 1&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 1&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|(空白处都为0)\n\\]\n\\(Solution\\): 将第一列元素依次减去第$ i$ 列的\\(\\frac{1}{x_i}\\) ,$i=2...n $\n得：\n\\[\nD_n= \\left|\\begin{array}{cccc} x_1-\\frac{1}{x_2}-...-\\frac{1}{x_n}&amp;1&amp;1 &amp;... &amp;1\\\\ 0&amp;x_2&amp;&amp;&amp;\\\\ 0&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 0&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|\n\\]\n所以：\n\\[\nD_n=\\prod_{i=2}^{n}x_i(x_1-\\sum_{i=2}^{n}\\frac{1}{x_i})\n\\]\n二：两三角型行列式\n\n特征为对角线上方元素均为\\(a\\) ,下方元素均为\\(b\\)\n\n\n当 \\(a=b\\) 时可化为箭型行列式计算，当 \\(a\\not=b\\) 时采用拆行法计算，请看下面两例\n\n\\[\neg1(a=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b&amp;x_2&amp;b&amp;...&amp;b\\\\ b&amp;b&amp;x_3&amp;...&amp;b\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i，i=2...n\\) 行都减去第一行\n得： \\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b-x_1&amp;x_2-b&amp;0&amp;...&amp;0\\\\ b-x_1&amp;0&amp;x_3-b&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b-x_1&amp;0&amp;0&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n即化成了箭型行列式，所以：\n\\[\nD_n=[\\prod_{i=2}^{n}(x_i-b)]\\times[x_1-b(b-x_1)\\sum_{i=2}^{n}\\frac{1}{x_i-b}] \n\\]\n\n\\[\neg2(a\\not=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 采用拆行法，目的是为了降阶\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a+0\\\\ b&amp;x_2&amp;a&amp;...&amp;a+0\\\\ b&amp;b&amp;x_3&amp;...&amp;a+0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n+b-b \\end{array}\\right| \n\\]\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;b \\end{array}\\right|_{(*)}+\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;0\\\\ b&amp;x_2&amp;a&amp;...&amp;0\\\\ b&amp;b&amp;x_3&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n将第 \\(i,i=1...n-1\\) 列都减去最后一列，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1-a&amp;0&amp;0 &amp;... &amp;a\\\\ b-a&amp;x_2-a&amp;0&amp;...&amp;a\\\\ b-a&amp;b-a&amp;x_3-a&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;b \\end{array}\\right|+(x_n-b)D_{n-1} \n\\]\n所以： \\[\nD_n=b\\prod_{i=1}^{n-1}(x_i-a)+(x_n-b)D_{n-1}\n\\]\n再由行列式转置不变性得到：\n\\[\nD_n=a\\prod_{i=1}^{n-1}(x_i-b)+(x_n-a)D_{n-1}\n\\]\n联立\\((11)(12)\\) ,得通式：\n\\[\nD_n=\\frac{1}{a-b}[a\\prod_{i=1}^{n}(x_i-b)-b\\prod_{j=1}^{n}(x_j-a)]\n\\]\n\n通过适当变换可以化为两三角型行列式的，描述不如大家自己看例子揣摩，也很容易理解的，请看下例\n\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} d&amp;b&amp;b &amp;... &amp;b\\\\ c&amp;x&amp;a&amp;...&amp;a\\\\ c&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ c&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n\\(Solution\\): 将第一行乘上 \\(\\frac{a}{b}\\) ，第一列乘上 \\(\\frac{a}{c}\\)，得：\n\\[\nD_n=\\frac{bc}{a^2}\\left|\\begin{array}{cccc} \\frac{a^2d}{bc}&amp;a&amp;a &amp;... &amp;a\\\\ a&amp;x&amp;a&amp;...&amp;a\\\\ a&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n即化成了两三角型行列式\n\n一些每行上有公因子但是无法向上式那样在保持行列式不变得基础上能提出公因子的，采用升阶法，请看下例\n\n\\[\neg4:D_n=\\left|\\begin{array}{cccc} 1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n\\(Solution\\): 加边升阶，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ 0&amp;1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ 0&amp;x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ 0&amp;x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n再将第 \\(i,i=2...n+1\\) 都减去第一行的\\(x_i，i=1...n\\) 倍，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ -x_1&amp;1&amp;0&amp;0 &amp;... &amp;0\\\\ -x_2&amp;0&amp;1&amp;0&amp;...&amp;0\\\\ -x_3&amp;0&amp;0&amp;1&amp;...&amp;0\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -x_n&amp;0&amp;0&amp;0&amp;...&amp;1 \\end{array}\\right| \n\\]\n即又化成了箭型行列式，可得通式：\n\\[\nD_n=1+\\sum_{i=1}^{n}x_{i}^{2} \n\\]\n三：两条线型行列式\n特征是除了主(次)对角线或与其相邻得一条斜线所组成的任意一条线加四个顶点中的某个顶点外，其他元素均为\\(0\\)，这类行列式可以直接展开降阶。这段描述有点繁琐，但其实也并不复杂，请看下例理解\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} a_1&amp;b_1&amp; &amp;... &amp;\\\\ &amp;a_2&amp;b_2&amp;...&amp;\\\\ &amp;&amp;a_3&amp;...&amp;\\\\ &amp;&amp;&amp;\\\\ &amp;&amp;...&amp;a_{n-1}&amp;b_{n-1} \\\\ b_n&amp;&amp;...&amp;&amp;a_n \\end{array}\\right| (空白处都为0)\n\\]\n\\(Solution\\): 按照第一列两个非\\(0\\)元素拉普拉斯展开即可\n\\[\nD_n=\\prod_{i=1}^{n}a_i+(-1)^{n+1}\\prod_{i=1}^{n}b_i \n\\]\n四：范德蒙德型行列式\n范德蒙德行列式大家应该熟悉，而范德蒙德型行列式的特征就是有逐行(列)元素按幂递增(减)，可以将其转化为范德蒙德行列式来计算，请看下例\n\\[\neg:D_n=\\left|\\begin{array}{cccc} a_{1}^n&amp; a_{1}^{n-1}b_1&amp;... &amp;a_1b_1^{n-1}&amp;b_1^n\\\\ a_{2}^n&amp;a_{2}^{n-1}b_2&amp;...&amp;a_2b_2^{n-1}&amp;b_2^n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{n}^n&amp;a_{n}^{n-1}b_n&amp;...&amp;a_nb_n^{n-1}&amp;b_n^n\\\\ a_{n+1}^n&amp;a_{n+1}^{n-1}b_{n+1}&amp;...&amp;a_{n+1}b_{n+1}^{n-1}&amp;b_{n+1}^n \\end{array}\\right| \n\\]\n\\(Solution\\): 将每行都提出 \\(a_i^{n}\\),$i=1...n+1 $倍，得：\n\\[\nD_n=\\prod_{i=1}^{n+1}a_i^n\\left|\\begin{array}{cccc} 1&amp; \\frac{b_1}{a_1}&amp;... &amp;(\\frac{b_1}{a_1})^{n-1}&amp;(\\frac{b_1}{a_1})^{n}\\\\ 1&amp;\\frac{b_2}{a_2}&amp;...&amp;(\\frac{b_2}{a_2})^{n-1}&amp;(\\frac{b_2}{a_2})^{n}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 1&amp;\\frac{b_n}{a_n}&amp;...&amp;(\\frac{b_n}{a_n})^{n-1}&amp;(\\frac{b_n}{a_n})^{n}\\\\ 1&amp;\\frac{b_{n+1}}{a_{n+1}}&amp;...&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n-1}&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n} \\end{array}\\right| \n\\]\n上式即为范德蒙德行列式，所以通式为：\n\\[\nD_n=\\prod_{1\\le i&lt;j\\le n+1}(a_ib_j-b_ia_j)\n\\]\n五：\\(Hessenberg\\)型行列式\n特征为除了主(次)对角线及与其相邻的斜线，再加上第一行(列)或第\\(n\\)行(列)外，其余元素均为\\(0\\)。这类行列式有点像前面说的两条线型行列式，但是还是有一点区别的。这类行列式都用累加消点法，即通常将某一行(列)都化简到只有一个非\\(0\\)元素，以便于降阶计算，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 1&amp;-1&amp;&amp;&amp;&amp;\\\\ &amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ &amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ &amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n\\(Solution\\): 将各列都加到第一列，得到：\n\\[\nD_n= \\left|\\begin{array}{cccc} \\frac{n(n+1)}{2}&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 0&amp;-1&amp;&amp;&amp;&amp;\\\\ 0&amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ 0&amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n降阶之后再重复上述步骤即可得到通式：\n\\[\nD_n=(-1)^{n-1}\\frac{(n+1)!}{2} \n\\]\n注：需要说明的是，上面举的例子比较容易看出如何实施累加消点法就可以实现将某一行(列)都化简到只有一个非\\(0\\)元素从而达到降阶的目的，但是还有很多\\(Hessenberg\\)型行列式并不这么容易就做到，还需要大家找找技巧稍微变换一下，只要始终记得你要用累加消点法来消元来降阶就可以了\n六：三对角型行列式\n这是一种递推结构的行列式，特征为所有主子式都有相同的结构，从而以最后一列展开，将所得的\\((n-1)\\) 阶行列式再展开即得递推公式，即递推法(特征方程法)，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} a&amp;b&amp; &amp;&amp;... &amp;&amp;&amp;\\\\ c&amp;a&amp;b&amp;&amp;...&amp;&amp;&amp;\\\\ &amp;c&amp;a&amp;b&amp;...&amp;&amp;\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;\\\\ &amp;&amp;&amp;&amp;...&amp;a&amp;b\\\\ &amp;&amp;&amp;&amp;...&amp;c&amp;a \\end{array}\\right| \n\\]\n\\(Solution\\): 按第一列拉普拉斯展开，得：\n\\[\nD_n=aD_{n-1}-bcD_{n-2} \n\\]\n解特征方程： \\(x^2=ax-bc\\) ，得：\n\\[\nx_1=\\frac{a+\\sqrt{a^2-4bc}}{2}\n\\]\n\\[\nx_2=\\frac{a-\\sqrt{a^2-4bc}}{2} \n\\]\n即可得通式：\n\\[\nD_n = \\frac{x_1^{n+1}-x_2^{n+1}}{x_1-x_2} \n\\]\n注：特征方程法我没记错的话，应该是在高中将数列的时候用到的。\n七：各行元素和相等型行列式\n这个特征已经很清楚了吧，方法就是累加法，很简单，直接看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1+x_1&amp;x_1 &amp;... &amp;x_1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i,i=2...n\\)行都加到第一行去，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1+\\sum_{i=1}^{n}x_i&amp;1+\\sum_{i=1}^{n}x_i &amp;... &amp;1+\\sum_{i=1}^{n}x_i\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;1 &amp;... &amp;1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right|= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;0&amp;... &amp;0\\\\ x_2&amp;1&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;0&amp;...&amp;1 \\end{array}\\right|=1+\\sum_{i=1}^{n}x_i \n\\]\n八：相邻两行对应元素相差K倍型行列式\n这个要用步步差法\n(1)大部分元素为数字，且相邻两行对应元素相差为\\(1\\)，采用逐步作差的方法，即可出现大量 \\(\\pm1\\) 元素，进而出现大量\\(0\\)元素\n(2)若相邻两行相差\\(K\\)倍，采用逐步作\\(k\\)倍差得方法，即可出现大量\\(0\\)元素\n请看下面两个例子\n\\[\neg1:D_n= \\left|\\begin{array}{cccc} 0&amp;1&amp;2 &amp;...&amp;n-2 &amp;n-1\\\\ 1&amp;0&amp;1&amp;...&amp;n-3&amp;n-2\\\\ 2&amp;1&amp;0&amp;...&amp;n-4&amp;n-3\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ n-2&amp;n-3&amp;n-4&amp;...&amp;0&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行减去后一行，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;1&amp;1 &amp;...&amp;1 &amp;1\\\\ -1&amp;-1&amp;1&amp;...&amp;1&amp;1\\\\ -1&amp;-1&amp;-1&amp;...&amp;1&amp;1\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-1&amp;-1&amp;...&amp;-1&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n再将第一列加到第\\(i,i=2...n\\) 列，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;-2&amp;...&amp;0&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-2&amp;-2&amp;...&amp;-2&amp;0\\\\ n-1&amp;2n-3&amp;2n-4&amp;...&amp;n&amp;n-1 \\end{array}\\right|=(-1)^{n-1}(-2)^{n-2}(n-1) \n\\]\n\n\\[\neg2:D_n= \\left|\\begin{array}{cccc} 1&amp;a&amp;a^2 &amp;...&amp;a^{n-2} &amp;a^{n-1}\\\\ a^{n-1}&amp;1&amp;a&amp;...&amp;a^{n-3} &amp;a^{n-2} \\\\ a^{n-2} &amp;a^{n-1} &amp;1&amp;...&amp;a^{n-4} &amp;a^{n-3} \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ a^2&amp;a^3&amp;a^4&amp;...&amp;1&amp;a\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行加上后一行的\\((-a)\\) 倍，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1-a^n&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ a^{n-1}&amp;1-a^n&amp;0&amp;...&amp;0 &amp;0\\\\ 0 &amp;0 &amp;1-a^n&amp;...&amp;0&amp;0 \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;1-a^n&amp;0\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n=(1-a^n)^{n-1}\n\\]\n","categories":["机器学习数学基础"]},{"title":"机器学习数学基础：微积分","url":"/2022/01/08/%E5%BE%AE%E7%A7%AF%E5%88%86/","content":"本章介绍微积分中的函数、极限、导数、梯度及积分等基本概念。\n1 函数和极限\n1.1 函数的定义\n设 \\(A\\)，\\(B\\) 都是非空的数的集合，\\(f:x \\rightarrow y\\) 是从 \\(A\\) 到 \\(B\\) 到一个对应法则，那么从 \\(A\\) 到 \\(B\\) 的映射\\(f:x \\rightarrow y\\) 就叫做函数，记作 \\(y=f(x)\\) ，其中 \\(x \\in A\\)，\\(y \\in B\\) .\n1.2 反函数\n设函数 $ y =f(x) $ 的定义域是 \\(D\\)，值域是 \\(f(D)\\) 。如果对于值域 \\(f(D)\\) 中的每一个 \\(y\\) ，在 \\(D\\) 中有且仅有一个 \\(x\\) 使得 \\(g(y)=x\\) ，则按此对应法则得到了一个定义在 \\(f(D)\\) 上的函数，并把该函数称为函数 \\(y=f(x)\\) 的反函数，记作 \\(x=f^{-1}(y)\\)，\\(y \\in f(D)\\) .\n1.3 复合函数\n若 \\(y\\) 是 \\(u\\) 的函数：\\(y=f(u)\\) ，而 $u $ 又是 \\(x\\) 的函数：\\(u=g(x)\\) ，且 \\(g(x)\\) 的函数值的全部或部分在 \\(f(u)\\) 的定义域内，则 \\(y\\) 通过 \\(u\\) 成为 \\(x\\) 的函数，这种函数称为由函数 \\(u=g(x)\\) 和函数 \\(y=f(u)\\) 构成的复合函数，记作 \\(y=f[g(x)]\\) ，其中 \\(u\\) 叫作中间变量。\n1.4 多元函数\n设有两个独立的变量 \\(x\\) 与 \\(y\\) 在其给定的变域 $ D$ 中，任取一组数值时，第 \\(3\\) 个变量 $ z$ 就以某一确定的法则有唯一确定的值与其对应，那么变量 \\(z\\) 称为 \\(x\\) 和 \\(y\\) 的二元函数，记作 \\(z=f(x,y)\\) ，其中 \\(x\\) 与 \\(y\\) 称为自变量，函数 \\(z\\) 也叫作因变量，自变量 \\(x\\) 与 \\(y\\) 的变域 \\(D\\) 称为函数的定义域。\n1.5 函数极限的性质\n数列极限的定义：给定数列 $ {x_n}$ ，实常数 \\(a\\) ，若对任意给定的 \\(\\epsilon&gt;0\\) ，可以找到正整数 \\(N\\) ，使得当 \\(n&gt;N\\) 时，$ |x_n-a|&lt;$ 成立，则称数列 $ {x_n}$收敛于 \\(a\\) （或称 \\(a\\) 是数列 $ {x_n}$ 的极限）。\n自变量趋向于无穷大时函数极限的定义： 类似数列极限的定义。\n自变量趋向有限值时函数极限的定义：设函数 \\(f(x)\\) 在某点 \\(x_0\\) 的某个去心邻域内有定义，后面类似数列极限的定义。\n一些懒得敲公式的知识概念：数列极限的夹逼定理、函数极限的夹逼定理、函数极限的运算法则（加减乘除幂）、无穷大量和无穷小量。\n两个公式： \\[\n\\lim\\limits_{x\\rightarrow0}\\frac{\\text{sin} x}{x}=1\\\\\n\\lim\\limits_{x\\rightarrow0}(1+x)^{\\frac{1}{x}}=e\n\\]\n1.6 洛必达法则\n适用于 \\(\\large\\frac{0}{0}\\) 和 \\(\\large\\frac{\\infty}{\\infty}\\) 及其变式。\n1.7 函数的连续性\n一些懒得敲公式的知识概念：函数连续性定义、最值定理、介值定理、零点存在定理（勘根定理）\n1.8 拉格朗日乘数法\n拉格朗日乘数法可以解决约束优化问题。其基本思想是通过引入拉格朗日乘子来将含有 \\(n\\) 个变量和 \\(k\\) 个约束条件的约束优化问题转化成含有 \\(n+k\\) 个变量的无约束优化问题。是解决带等式约束优化问题的常用方法。\n详见：\n好久不见的拉格朗日乘数法：https://zhuanlan.zhihu.com/p/149104728\n如何理解拉格朗日乘子法？：https://www.zhihu.com/question/38586401\n1.9 函数间断点\n即不满足函数连续定义的条件。分为：\n\n第一类间断点：左右极限有定义\n\n跳跃间断点：左右极限不相等\n可去间断点：左右极限相等\n\n第二类间断点：左右极限不全有定义\n\n习题\n利用 \\(SymPy^{[1]}\\) 库实现 \\(\\lim\\limits_{a\\rightarrow 0}\\frac{sin(a)}{a}\\) 和 \\(\\lim\\limits_{n\\rightarrow\\infty}(\\frac{n+3}{n+2})^n\\) 的求解。\n#coding:utf-8import sympysympy.init_printing()from sympy import oo# 1.求sin(a) / a在a=0处的极限a = sympy.Symbol(&#x27;a&#x27;)b = sympy.sin(a) / aresult = sympy.limit(b,a,0)print(&#x27;sin(a) / a在a趋近于0处的极限:&#x27;,result)#2.求[(n+3)/(n+2)]^n ,n趋紧无穷大时的极值n = sympy.Symbol(&#x27;n&#x27;)y = ((n+3)/(n+2))**nprint ( &#x27;[(n+3)/(n+2)]^n ,n趋紧无穷大的极值：&#x27;,sympy.limit(y, n, sympy.oo) )\n2 导数\n2.1 导数的概念\n有定义，有增量，极限存在。是一种变化率\n2.2 偏导数、全导数\n偏导数相对于多元函数，全导数相对于复合函数。\n2.3 高阶导数\n多次连续求导。\n2.4 函数的基础求导法则\n一些懒得敲公式的知识概念：常用的求导公式、和与差的求导法则、复合函数的求导规则、反函数的求导法则、隐函数的求导法则等各种求导法则。\n2.5 链式法则及复杂函数的求导\n假设 \\(z = f(u, v)\\)的每一个自变量都是二元函数，也就是说，\\(u=h(x, y)\\) ，\\(v = g(x, y)\\) ，且这些函数都是可微的。那么，\\(z\\) 的偏导数为： \\[\n\\frac {\\delta z}{dx}  =  \\frac {\\delta z}{du}  \\frac {du}{dx}  +  \\frac {\\delta z}{dv} \\frac {\\delta v}{dx} \\\\\\\n \\frac {\\delta z}{dy}= \\frac {\\delta z}{du} \\frac {\\delta u}{dy}+\\frac {\\delta z}{dv} \\frac {\\delta v}{dy}\n\\] 如果我们考虑 $  =(u,v)$，为一个向量函数，我们可以用向量的表示法把以上的公式写成 \\(f\\) 的梯度与 \\(\\overrightarrow {r}\\) 的偏导数的数量积:\n\\[\n\\frac {\\delta f}{dx}  =  \\overrightarrow {V}  f  \\cdot   \\frac {\\theta r}{dx}\n\\] 更一般地,对于从向量到向量的函数,求导法则为: \\[\n\\frac {\\delta (z_ {1},\\cdots ,z_ {m})}{o(x_ {1},\\cdots ,x_ {p})} =  \\frac {d(z_ {1},\\cdots ,z_ {m})}{d(y_ {1},\\cdots ,y_ {n})}  \\frac {o(y_ {1},\\cdots ,y_ {n})}{o(x_ {1},\\cdots ,x_ {p})}\n\\]\n2.6 导数的应用\n一些懒得敲公式的知识概念：极值与最值、曲线的凸凹、拐点（凹弧的分界点）、泰勒公式和泰勒展开式、泰勒定理、中值定理（拉格朗日、罗尔和柯西中值定理）\n3 方向导数和梯度\n3.1 向量\n一些懒得敲公式的知识概念：向量的模、数量积（内积、点积、标量积 $ |a||b|cos$）、向量积（外积、叉积，它的模是 \\(|a||b|sin\\theta\\)）\n3.2 方向导数、梯度\n带有方向（极值方向，一般是取最大值的方向）的导数。\n3.3 雅可比矩阵与局部最优问题\n详见：雅可比矩阵和雅可比行列式：https://zhuanlan.zhihu.com/p/39762178\n3.4 黑塞矩阵\n二阶偏导数矩阵就是黑塞矩阵（Hessian Matrix）。它是一个自变量为向量的实值函数的二阶偏导数组成的方阵。\n\n如果H(M)是 正定矩阵，则临界点M处是一个局部的极小值。\n如果H(M)是 负定矩阵，则临界点M处是一个局部的极大值。\n如果H(M)是 不定矩阵，则临界点M处不是极值。\n\n习题\n调用 SymPy的库函数求解出雅可比矩阵的形式，调用Theano的库函数计算雅可比矩阵和黑塞矩阵的值。\n#实例01：用SymPy库函数求解出的雅克比矩阵的形式。import sympym,n,i,j = sympy.symbols(&quot;m n i j&quot;)m = i**4-2*j**3-1 #设置变量（符号）n = j-i*j**2+5funcs = sympy.Matrix([m,n])#矩阵的维度m,nargs = sympy.Matrix([i,j])res = funcs.jacobian(args)#调用jacobian函数求解print(res)#实例02：Theano库实现雅克比矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as T# 计算雅克比矩阵x=T.dvector(&#x27;x&#x27;)y=x**3+x**4# 调用scan构建循环GraphJ,updates=theano.scan(lambda i,y,x:T.grad(y[i],x),sequences=T.arange(y.shape[0]),non_sequences=[y,x])f1=function([x],J,updates=updates)print(&quot;f1=&quot;,f1([5, 5]))#实例03：Theano库实现海森矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as Tx=T.dvector(&#x27;x&#x27;)# 计算hessian矩阵y=x**3+x**4cost=y.sum()gy=T.grad(cost,x) #求梯度# 调用scan构建循环GraphH,updates=theano.scan(lambda i,gy,x:T.grad(gy[i],x),sequences=T.arange(gy.shape[0]),non_sequences=[gy,x])f2=function([x],H,updates=updates)print(&quot;f2=&quot;,f2([5, 5]))\n4 积分\n4.1 不定积分\n一些懒得敲公式的知识概念：原函数（定义、存在定理、原函数族 \\(F(x)+C\\)）\n4.2 求不定积分的方法\n一些懒得敲公式的知识概念：积分基本公式、换元法、分部积分法\n4.3 定积分\n一些懒得敲公式的知识概念：定积分定义、性质（和差、与常数乘积、单调性、极值）、积分中值定理\n","categories":["机器学习数学基础"]},{"title":"机器学习数学基础：线性代数","url":"/2022/01/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","content":"本章介绍线性代数中向量、内积、范数、矩阵、线性变换、二次型、矩阵分解等基本知识。\n1 行列式\n线性代数中，行列式是一个函数，和矩阵有一定的关系。几何上，行列式可以看作有向面积或体积的概念在一般的欧几里得空间中的推广。\n1.1 二阶与三阶行列式\n可用来解决线性方程求解的问题，同时注意对角线法则只适用于二阶和三阶的行列式。\n表达式 \\[\nD=a_{11}a_{22}-a_{12}a_{21}=\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12}\\\\\n   a_{21} &amp; a_{22} \n  \\end{matrix}\n  \\right]\n\\] 称为数表的二阶行列式，记作 \\(D=det(a_{ij})\\) .\n三阶行列式定义为 \\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}\n\\]\n1.2 全排列和对换\n全排列的定义：由 \\(1\\) 到 \\(n\\) 个数组成的一个有序数组称为一个n级全排列，通常用 $ P_n$ 表示。 \\[\nP_n=n\\times (n-1)\\times \\dots\\times3\\times2\\times1=n!\n\\] 逆序数的定义：在一个排列中，如果两个数（称为数对）的前后位置与大小顺序相反，即前面的数大于后面的数，那么称它们构成一个逆序（反序）。一个排列中所有逆序的总数称为此排列的逆序数。分别计算出排在 \\(1,2,\\dots,n-1,n\\) 前面比它大的数码之和。 \\[\nt=t_1+t_2+\\dots+t_n=\\sum_{i=1}^nt_i\n\\] 此外，还有奇排列和偶排列的概念，即奇排列为逆序数为奇数的排列。\n对换的定义：在排列中，将任意两个元素对调，其余元素不动，就得到另一个排列，这样的一个变换叫作对换。将相邻的两个元素对换，叫作相邻对换。其中，一个排列中任意两个元素对换，排列改变奇偶性。\n1.3 n阶行列式\n\\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=\\sum(-1)^ta_{11}a_{22}a_{33}\n\\]\n可推广至n阶，其中 \\(t\\) 为列标排列的逆序数。\n1.4 几种特殊行列式的值\n上、下三角行列式，对角行列式，特殊行列式（类似反的下三角行列式）\n如果是计算的是主对角线的值，则直接连乘；如果是副对角线，则需加一个系数 \\((-1)^{\\frac{n(n-1)}{2}}\\).\n一些其他的见知乎：https://zhuanlan.zhihu.com/p/34685081。\n1.5 n阶行列式的性质\n\n性质1：行列式与它的转置行列式相等。\n性质2：互换行列式的两列，行列式变号。（推论：两行或两列相同，此行列式等于零）。\n性质3：行列式的某一行（列）中所有元素都乘同一数 \\(k\\)，等于用数 \\(k\\) 乘此行列式。\n性质4：行列式中如果有两行（列）元素成比例，则此行列式等于零。\n性质5：若行列式的某一列（行）的元素都是两数 之和，则该行列式等于两个行列式之和。\n性质6：把行列式的某一列（行）的各个元素乘同一个数，然后加到另一列（行）对应的元素上去，行列式的值不变。\n\n2 用向量描述空间\n2.1 向量及其运算\n\\(n\\) 维空间用 \\(\\pmb{R}^n\\) 表示，上标 \\(n\\) 表示空间的维度。\n2.2 向量组的线性组合\n若干个同纬度的列向量（或同纬度的行向量）所组成的集合叫作向量组。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和一组实数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，那么表达式 \\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)称为向量组 $ $ 的一个线性组合。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和向量 \\(\\pmb{b}\\)，如果存在一组数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得 \\(\\pmb{b}=\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)，则向量 \\(\\pmb{b}\\) 是向量组 \\(\\pmb{A}\\) 的线性组合，这时称向量 \\(\\pmb{b}\\) 能由向量组 \\(\\pmb{A}\\) 线性表示，也就是对应的方程组有解。\n2.3 向量组的线性相关性\n向量组的线性相关性的定义：给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) ，如果存在不全为0的数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得\\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m=0\\)，则称向量组 \\(\\pmb{A}\\) 是线性相关的。\n线性相关的充要条件是：向量组中至少有一个向量可以由其他所有向量线性表示。\n3 内积、正交向量组和范数\n3.1 内积\n向量之间的乘法可分为内积和外积，一般用内积比较多。内积的直接描述为某一向量在另一个向量方向上的投影长度。\n内积的定义：设有 \\(n\\) 维向量 \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，\\(\\pmb{y}=\\left(\\begin{matrix}  y_1 \\\\  y_2\\\\ \\vdots \\\\ y_n  \\end{matrix}\\right)\\)，令\\(（\\pmb{x},\\pmb{y}）=x_1y_1+x_2y_2+\\dots+x_ny_n\\)，\\(（\\pmb{x},\\pmb{y}）\\)称为向量 \\(\\pmb{x}\\) 和向量 \\(\\pmb{y}\\) 的内积，也可以表示为 \\(\\pmb{x·}\\pmb{y}\\).\n3.2 正交向量组和施密特正交化\n正交向量的定义：如果两向量的内积为零，则称它们正交。\n正交向量组的定义：如果向量组中任意两个向量都正交且不含零向量，则称为正交向量组，并且正交向量组是线性无关的。\n标准正交向量：向量组内向量彼此之间的点积为 \\(0\\)，与自身的点积为 \\(1\\)。\n施密特正交化详见：\n如何理解施密特（Schmidt）正交化：https://zhuanlan.zhihu.com/p/136627868。\n3.3 范数\nwiki——矩阵范数\n向量范数的定义：如果向量 \\(\\pmb{a} \\in \\pmb{R}^n\\) 的某个实值函数 $f()=|||| $ 满足\n\n非负性：\\(||\\pmb{a}||\\geq 0\\) ，且\\(||\\pmb{a}||=0\\) 当且仅当 \\(\\pmb{a}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{a}||=|\\lambda|||\\pmb{a}||\\)\n三角不等式：对于任意 \\(\\pmb{a,b}\\in\\pmb{R}^n\\)，都有 \\(||\\pmb{a+b}||\\leq||\\pmb{a}||+||\\pmb{b}||\\)\n\n常用的向量范数有 $ 1$ -范数、\\(2\\) -范数和 \\(\\infty\\) -范数。\n\n$ 1$ -范数：也称为曼哈顿距离 \\[\n  ||\\pmb{a}||_1=\\sum_i^n|\\pmb{a}_i|\n  \\]\n\\(2\\) -范数：也称为欧几里得范数\n\n\\[\n||\\pmb{a}||_2=\\sqrt{\\sum_{i=1}^n\\pmb{a}_i^2}\n\\]\n\n\\(\\infty\\) -范数：所有向量元素中的最大值 \\[\n  ||\\pmb{a}||_\\infty=\\max_i|a_i|\n  \\]\n\n矩阵范数的定义：如果矩阵 \\(\\pmb{A} \\in \\pmb{R}^{n\\times n}\\) ，若按某一确定的法则对应于一个非负实数 $|||| $ 满足\n\n非负性：\\(||\\pmb{A}||\\geq 0\\) ，且\\(||\\pmb{A}||=0\\) 当且仅当 \\(\\pmb{A}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{A}||=|\\lambda|||\\pmb{A}||\\)\n三角不等式：对于任意 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{A+B}||\\leq||\\pmb{A}||+||\\pmb{B}||\\)\n相容性：对于任意的 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{AB}||\\leq||\\pmb{A}||||\\pmb{B}||\\)\n\n常用的矩阵范数有 $ 1$ -范数、\\(2\\) -范数、 \\(\\infty\\) -范数和 \\(F\\) -范数。\n\n$ 1$ -范数：又称为列和范数。顾名思义，即矩阵列向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_1=\\max_j\\sum_i^m|a_{ij}|\n  \\]\n\\(2\\) -范数：又称为谱范数，计算方法为 \\(\\pmb{A^TA}\\) 矩阵的最大特征值开平方。\n\n\\[\n||\\pmb{A}||_2=\\sqrt{\\lambda_1}\n\\]\n\n\\(\\infty\\) -范数：又称为行和范数。顾名思义，即矩阵行向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_\\infty=\\max_i\\sum_j^n|a_{ij}|\n  \\]\n\\(F\\) -范数：又称为Frobenius范数，计算方法为矩阵元素的绝对值的平方和再开方。 \\[\n||\\pmb{A}||_F=\\sqrt{\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|}\n\\]\n\n习题：Python编程实现求向量范数和矩阵范数。\n# -*- coding: UTF-8 -*-import numpy as npa=np.array([2,4,5,8,-3])print(&#x27;向量a：&#x27;,a)print (&#x27;向量a的1-范数:&#x27;)print(np.linalg.norm(a,ord=1))print (&#x27;向量a的2-范数:&#x27;)print(np.linalg.norm(a,ord=2))print (&#x27;向量a的∞-范数:&#x27;)print(np.linalg.norm(a,ord=np.inf))# -*- coding: UTF-8 -*-import numpy as npA=np.arange(3,15).reshape(3,4)print(&#x27;矩阵A：&#x27;,A)print(&#x27;矩阵A的1-范数:&#x27;)print(np.linalg.norm(A,ord=1))print(&#x27;矩阵A的2-范数:&#x27;)print(np.linalg.norm(A,ord=2))print(&#x27;矩阵的∞-范数:&#x27;)print(np.linalg.norm(A,ord=np.inf))print(&#x27;矩阵A的F-范数:&#x27;)print(np.linalg.norm(A,ord=&#x27;fro&#x27;))print(&#x27;矩阵A列向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=0))print(&#x27;矩阵A行向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=1))\n4 矩阵和线性变换\n4.1 矩阵及其运算\n一些不想敲的概念：\n\n矩阵的定义。\n特殊的矩阵：行矩阵（也叫行向量）、列矩阵（也叫列向量）、方阵（\\(\\pmb{A}_n\\)），三角矩阵、单位矩阵、对称矩阵、对角矩阵、实对称矩阵、零矩阵、正交矩阵。\n矩阵的运算：加法、数乘、乘法、转置、行列式（\\(|\\pmb{A}|\\) 或 \\(det(\\pmb{A})\\)).\n\n4.2 逆矩阵\n对于 \\(n\\) 阶矩阵 \\(\\pmb{A}\\) ，如果有一个 \\(n\\) 阶矩阵 \\(\\pmb{B}\\) ，使得 \\(\\pmb{AB=BA=E}\\)，则称矩阵 \\(\\pmb{A}\\) 是可逆的，并把矩阵 \\(\\pmb{B}\\) 称为 \\(\\pmb{A}\\) 的逆矩阵，记作 \\(\\pmb{A}^{-1}\\) .\n\n若矩阵 \\(\\pmb{A}\\) 可逆，则 \\(|\\pmb{A}| \\neq 0\\) .\n若 \\(|\\pmb{A}| \\neq 0\\)，则矩阵 \\(\\pmb{A}\\) 可逆，且 \\(\\pmb{A}^{-1}=\\frac{1}{|\\pmb{A}|}\\pmb{A}^*\\)，其中 \\(\\pmb{A}^*\\) 为矩阵 \\(\\pmb{A}\\) 的伴随矩阵。\n\n4.3 矩阵的初等变换\n\n对调两行\n数乘\n数乘再相加\n\n4.4 标量对向量的导数、最小二乘法\n\nxxds\n\n详见：\n系列：机器学习中的矩阵向量求导\n单列一个：机器学习中的矩阵向量求导(二) 矩阵向量求导之定义法\n最小二乘法及python代码：最小二乘法（least sqaure method）\n4.5 线性变换\n线性变换的定义：设 \\(\\pmb{V}\\) 为一个线性空间，映射 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个变换，若 \\(f\\) 保持 \\(\\pmb{V}\\) 的加法与数乘运算，则称 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个线性变换。\n线性变换把一个向量空间里的向量映射到了另一个向量空间里的另一个向量，因此，我们可以把线性变换理解成输入一个向量，然后输出一个向量的特殊函数。\n它可以看成一个动态的过程，比如旋转、伸缩或者投影之类的升降维的操作。\n常见的线性变换还有：恒等变换（单位变换）、求微商（线性空间 \\(P[x]\\) 内）、求定积分。\n详见：线性变换（一）【直观理解线性变换】\n4.6 矩阵的秩\n一些概念：矩阵的秩、行秩、列秩和极大无关向量组。\n定理：设 \\(n\\) 元线性方程组 \\(\\pmb{Ax=b}\\) ，\\(R(\\pmb{A})\\) 表示系数矩阵 \\(\\pmb{A}\\) 的秩，\\(R(\\pmb{A,b})\\) 表示增广矩阵 \\(\\pmb{B=(A,b)}\\) 的秩，则该线性方程组\n\n无解的充要条件是 : \\(R(\\pmb{A})&lt;R(\\pmb{A,b})\\)；\n有唯一解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})=n\\)；\n有无限多解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})&lt;n\\) .\n\n一些概念：线性方程组的解、方阵的特征值和特征向量\n习题：Python编程实现求逆矩阵、行列式的值、秩\nimport numpy as np# a=np.array([[1,4,7],[2,5,8],[3,6,9]])# a=np.array([[1,2,3],[4,5,6]])A=np.array([[1,4,9],[2,5,8],[3,6,9]])print(&quot;A矩阵为：&quot;)print(A)print(&#x27;*&#x27;*40)F = np.linalg.inv(A)print(&quot;A矩阵的逆矩阵为：&quot;)print(F)print(&#x27;*&#x27;*40)print(&quot;A矩阵与其逆矩阵乘积为：&quot;)print(np.dot(A,np.linalg.inv(A)))print(np.dot(A,np.linalg.inv(A)).astype(int))print(&#x27;*&#x27;*40)print(&quot;A矩阵的行列式的值为：&quot;)print(np.linalg.det(A))print(&#x27;*&#x27;*40)print(&quot;A矩阵的秩为：&quot;)print(np.linalg.matrix_rank(A))\n5 二次型\n5.1 二次型的定义\n即二次齐次函数（\\(x^2,x_1x_2,\\dots\\)，类似平方项展开加上系数）。二次型的标准型可理解为只含平方项的二次型。\n若 \\(\\pmb{A}\\) 为对称矩阵， \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，则 \\(f=\\pmb{x^TAx}\\) 也是二次型的一种形式，对成矩阵 \\(\\pmb{A}\\) 叫作二次型 \\(f\\) 的矩阵，也把 \\(f\\) 叫作对称矩阵 \\(\\pmb{A}\\) 的二次型。对称矩阵 \\(\\pmb{A}\\) 的秩就叫做二次型 \\(f\\) 的秩。\n5.2 用正交变换化二次型为标准型\n\n将二次型 \\(f=\\sum_\\limits{i=1}^n\\sum_\\limits{j=1}^na_{ij}x_ix_j\\)，写成矩阵形式 \\(f=\\pmb{x^TAx}\\) .\n由 \\(|\\pmb{A-\\lambda E}|=0\\)，求出 \\(\\pmb{A}\\) 的全部特征值。\n由 \\((\\pmb{A-\\lambda E})\\pmb{x}=0\\)，求出 \\(\\pmb{A}\\) 的特征向量。\n\n对于求出的不同特征值所对应的特征向量已正交，只需要单位化；对于 \\(k\\) 冲特征值 \\(\\lambda\\) 所对应的 \\(k\\) 个线性无关的特征向量，用施密特正交化方法把它们化成 \\(k\\) 个两两正交的单位向量。\n\n把求出的n个两两正交的单位向量拼成正交矩阵 \\(\\pmb{P}\\)，作正交变换 \\(\\pmb{x=Py}\\).\n用 \\(\\pmb{x=Py}\\) ，把 \\(f\\) 化成标准型 \\(f=\\lambda_1y_1^2+\\lambda_2y_2^2+\\dots+\\lambda_ny_n^2\\)，其中 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_n\\)是矩阵 \\(\\pmb{A}=(a_{ij})\\) 的特征值。\n\n5.3 二次型的正定型\n正定二次型、惯性定理、和赫尔维茨定理（后两个是判定定理）。\n麻省理工线性代数笔记（二十四）-正定矩阵\n6 矩阵分解\n矩阵分解有很多种，如 \\(LU\\) 分解、\\(QR\\) 分解、特征值分解（\\(EVD\\) ）和奇异值分解（\\(SVD\\) ）。\\(LU\\) 分解是将满秩矩阵分解为两个倒扣的三角形，即分解成下三角矩阵和上三角矩阵的乘积，它的意义在于求解大型方程组。QR分解经常用来解线性最小二乘法问题，它和机器学习的相关算法密切。特征值分解的方法也非常有效，但有一些局限性，即要求矩阵必须是方阵且能够被对角化。奇异值分解可以对任意形状的矩阵进行分解，实用性更广。\n麻省理工线性代数笔记（二十六）-奇异值分解\n【学长小课堂】什么是奇异值分解SVD--SVD如何分解时空矩阵\n\n\n\n李航统计学习之奇异值分解（SVD）\n习题：实现矩阵的QR分解\nimport numpy as npM= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)Q=np.zeros((4, 3))j = 0for a in M.T:    b = np.copy(a)    for i in range(0, j):        b = b - np.dot(np.dot(Q[:, i].T, a), Q[:, i])    e = b / np.linalg.norm(b)    Q[:, j] = e    j += 1R = np.dot(Q.T, M)np.set_printoptions(precision=3,suppress=True)print(&#x27;Gram-schmidt正交化变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))#方法二import numpy as npnp.set_printoptions(precision=4, suppress=True)M= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)s = 4t = 3Q = np.identity(s)R = np.copy(M)for j in range(s - 1):    x = R[j:, j]    E = np.zeros((4, 3))    E = np.zeros_like(x)    b = x - E    d = b / np.linalg.norm(b)    Q_j = np.identity(s)    Q_j[j:, j:] -= 2.0 * np.outer(d, d)    R = np.dot(Q_j, R)    Q = np.dot(Q, Q_j)np.set_printoptions(precision=3,suppress=True)print(&#x27;Householder变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))\nQ：奇异值分解的应用场景有哪些?\n\\(SVD\\) 的应用有很多，可以说，\\(SVD\\) 是矩阵分解、降维、压缩、特征学习的一个基础工具，所以 \\(SVD\\) 在机器学习领域相当的重要。\n\\(SVD\\) 在降维中作用如何呢？通过 \\(SVD\\) 的公式可以看出，原来矩阵 $ $ 的特征有 \\(n\\) 维，经过 \\(SVD\\) 后，可以用前 \\(r\\) 个非零奇异值对应的奇异向量表示矩阵\\(\\pmb{A}\\) 的主要特征，这样就把矩阵 $ $ 进行了降维。\n\\(SVD\\) 在压缩中作用如何呢？机器学习最基本和最有趣的特征之一是数据压缩概念的相关性。如果我们能提取有用的数据，我们就能用更少的比特位来表达数据。从信息论的观点来看，数据之间存在相关性，则有可压缩性。通过 \\(SVD\\) 的公式可以看出，矩阵 $ $ 经过 \\(SVD\\) 后，要表示原来的大矩阵 $ $ ，我们只需要存储 \\(\\pmb{U,\\Delta,V}\\) 三个较小的矩阵即可。而这 \\(3\\) 个较小规模的矩阵占用内存上也是远远小于原有矩阵 $ $ 的，这样 \\(SVD\\) 就起到了压缩的作用。\n\\(SVD\\) 和主成分分析有什么关系呢？\\(PCA\\) 即主成分分析方法，是一种使用最广泛的数据降维算法。\\(PCA\\) 的主要思想是将n维特征映射到 $ m$ 维上，这 \\(m\\) 维是全新的正交特征，也被称为主成分，是在原有 \\(n\\) 维特征的基础上重新构造出来的 \\(m\\) 维特征。\\(PCA\\) 的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。\\(PCA\\) 算法有两种实现方法，即基于特征值分解协方差矩阵实现 \\(PCA\\) 算法和基于 \\(SVD\\) 协方差矩阵实现 \\(PCA\\) 算法。所以，\\(SVD\\) 是 \\(PCA\\) 算法的一种实现方法。\n我们再来看一下潜在语义索引，它是一种简单实用的主题模型。潜在语义索引是一种利用 \\(SVD\\) 方法获得在文本中术语和概念之间关系的索引和获取方法。该方法的主要依据是在相同文章中的词语一般有类似的含义，可以从一篇文章中提取术语关系，从而建立起主要概念内容。潜在语义索引不同于 \\(PCA\\) ，至少不是实现了 \\(SVD\\) 就可以直接用的，但它也是一个高度依赖 \\(SVD\\) 的算法。\n","categories":["机器学习数学基础"]},{"title":"栈和递归","url":"/2022/01/17/%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92/","content":"栈（Stack）\n栈对数据 \"存\" 和 \"取\" 的过程有特殊的要求：\n\n栈只能从表的一端存取数据，另一端是封闭的。\n在栈中，无论是存数据还是取数据，都必须遵循\"先进后出\"的原则，即最先进栈的元素最后出栈。\n\n因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 \"先进后出\" 原则的线性存储结构。通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。栈的最重要一个特点——后进先出（LIFO，Last In First Out），也可以说是先进后出（FILO，First In Last Out），我们无论如何只能从一端去操作元素。\n栈又叫作堆栈，这里说明一下不要将它和堆混淆。实际上堆和栈是两个不同的概念，栈是一种只能在一端进行插入和删除的线性数据结构。\n一般来说，栈主要有两个操作：一个是进栈（PUSH），又叫作入栈、压栈；另一个是出栈（POP），或者叫作退栈。\nclass Stack:    def __init__(self):        self.stack = []        self.size = 0    def push(self, item):        self.stack.append(item) # 添加元素        self.size += 1 # 栈元素数量加 1    def pop(self):        pop = self.stack.pop() # 删除栈顶元素        self.size -= 1 # 栈元素数量减 1        return pop    def isEmpty(self):        return self.stack == []    def sizes(self):        return self.size    def peek(self):        return self.stack[-1]if __name__ = &#x27;__main__&#x27;:    # 这里假定 A 是 4，B 是 &#x27;dog&#x27;,建议每一步的结果用 print() 输出看一下    s = Stack()    s.isEmpty()    s.push(4)    s.push(&#x27;dog&#x27;)    s.peek()    s.pop()    s.isEmpty()\n递归函数\n递归函数（recursive function）是指会调用自身的函数。为了防止函数无限地重复调用自身，代码中必须至少有一条选择语句。这条用来查验条件的语句被称为基本情况（base case），用于确定接下来要继续递归还是停止递归。\ndef displayRange(lower, upper):     &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;     while lower &lt;= upper:         print(lower)         lower = lower + 1\n如何将这个函数转换为递归函数呢？首先，需要注意如下两点重要的情况。\n\nlower &lt;= upper时，循环的主体会继续执行。\n执行这个函数时，lower会不断地加1，但是upper不会有任何改变。\n\n等价的递归函数可以执行类似的基本操作，区别在于：循环被替换成了if语句；赋值语句被替换成了函数的递归调用。修改后的代码如下：\ndef displayRange(lower, upper):     &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;     if lower &lt;= upper:         print(lower)         displayRange(lower + 1, upper)\n尽管这两个函数的语法和设计是不一样的，但是它们执行的算法过程相同。递归函数的每次调用都像在迭代版本函数里的循环一样，每次都会访问整个序列里的下一个数。\n通常来说，递归函数至少有一个参数。这个参数的值会被用来对递归过程的基本情况进行判定，从而决定是否要结束整个调用。在每次递归调用之前，这个值也会被进行某种方式的修改。每次对这个值的修改，都应该产生一个新数据值，可以让函数最终达到基本情况。在displayRange这个示例里，每次递归调用之前都会增加参数lower的值，从而让它最终能够超过参数upper的值。\ndef ourSum(lower, upper, margin = 0):     &quot;&quot;&quot;Returns the sum of the numbers from lower to upper,     and outputs a trace of the arguments and return values     on each call.&quot;&quot;&quot;     blanks = &quot; &quot; * margin     print(blanks, lower, upper)         # Print the arguments    if lower &gt; upper:         print(blanks, 0)                # Print the returned value        return 0    else:        result = lower + ourSum(lower + 1, upper, margin + 4)        print(blanks, result)           # Print the returned value        return result&gt;&gt;&gt; ourSum(1, 4) 1 4   2 4       3 4          4 4             5 4             0          4       7    9 10 10\n从结果可以看出，随着对ourSum调用的进行，参数会不断向右缩进。注意，每次调用时，lower的值都增加1，而upper的值始终保持不变。对ourSum的最后一次调用返回0。随着递归的返回，所返回的每个值都与其上面的值对齐，并且会增加上lower的当前值。这样的跟踪，对于递归函数来说，是非常有用的调试工具。\n递归的三大要素\n整理自知乎\n第一要素：明确你这个函数想要干什么\n对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。\n例如，我定义了一个函数\n#算n的阶乘(假设n不为0)def f(n):\t\tpass\n这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。\n第二要素：寻找递归结束条件\n所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。\n例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下\n#算 n 的阶乘(假设n不为0)def f(n):\t\tif n == 1:        return 1\n有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？\n当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。\n#算 n 的阶乘(假设n&gt;=2)def f(n):\t\tif n == 2:        return 2\n注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样：\n# 算 n 的阶乘(假设n不为0)def f(n):\t\tif n &lt;= 2:        return n\n第三要素：找出函数的等价关系式\n第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。\n例如，\\(f(n)\\) 这个范围比较大，我们可以让 \\(f(n) = n * f(n-1)\\)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。\n说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即\n\\(f(n) = n * f(n-1)\\)。\n找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：\n# 算 n 的阶乘(假设n不为0)def f(n):\t\tif n &lt;= 2:        return n\t\treturn f(n-1) * n\n至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。\n这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。\n还是不懂？没关系，我再按照这个模式讲一些题。\n\n有些有点小基础的可能觉得我写的太简单了，没耐心看？少侠，请继续看，我下面还会讲\n如何优化递归\n\n案例1：斐波那契数列\n\n斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34....，即第一项 f(1) = 1,第二项 f(2) = 1.....,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。\n\n1、第一递归函数功能\n假设 f(n) 的功能是求第 n 项的值，代码如下：\n2、找出递归结束的条件\n显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) = f(2) = 1。所以递归结束条件可以为 n &lt;= 2。代码如下：\ndef f(n):    if n &lt;= 2:        return 1\n3、找出函数的等价关系式\n题目已经把等价关系式给我们了，所以我们很容易就能够知道 \\(f(n) = f(n-1) + f(n-2)\\)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。\n所以最终代码如下：\ndef f(n):    # 1.先写递归结束条件    if n &lt;= 2:        return 1    # 2.接着写等价关系式    return f(n - 1) + f(n - 2)\n搞定，是不是很简单？\n\n零基础的可能还是不大懂，没关系，之后慢慢按照这个模式练习！好吧，有大佬可能在吐槽太简单了。\n\n案例2：小青蛙跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n1、第一递归函数功能\n假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：\ndef f(n):\t\tpass\n2、找出递归结束的条件\n我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：\ndef f(n):    if n == 1:        return 1\n第三要素：找出函数的等价关系式\n每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。\n第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。\n第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。\n所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：\ndef f(n):    if n == 1:        return 1    return f(n - 1) + f(n - 2)\n大家觉得上面的代码对不对？\n答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。\n这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：\ndef f(n):    if n &lt;= 2:        return n    return f(n - 1) + f(n - 2)\n递归的缺点\n虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。\n1、递归堆栈溢出\n▉ 理解堆栈溢出\n1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。\n2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。\n3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。\n#报错def f(i):    if i == 1:        return 1    return i + f(i -1) result = f(200000)print(result)\n▉ 解决办法\n通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。\ndepth=1def f(n):    global depth    depth+=1    if(depth &gt; 1000):        raise Exception(&#x27;堆栈溢出&#x27;)    if(n == 1):        return 1    print(depth)    return f(n-1) + 1\n解决方案 tail recursion\n2、递归重复元素\n有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。\n▉ 解决办法\n重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表（hash）或者键值对来保存。\n3、递归高空间复杂度\n因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。\nhttps://leetcode-cn.com/problems/unique-paths/\nhttps://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/\n","categories":["数据结构"]},{"title":"01简介至06矩阵运算","url":"/2022/01/23/01-06/","content":"\n\n\n筛选的Q&amp;A\n1、copy和clone的区别\ncopy分深拷贝和浅拷贝，不一定会复制内存；clone一定会复制内存。\n2、torch不区分行向量与列向量吗\n行向量 \\([1, 2, 3]\\) ， 列向量 $ [[1], [2], [3]]$，行向量的shape是 \\([n]\\)，列向量的shape是 \\([n,1]\\) .\n如果一个问题能够得到最优解，那么它就是p问题，机器学习不关心p问题，只关心np的问题。\n","categories":["动手学深度学习v2"]},{"title":"pyschools while 9-13","url":"/2022/01/24/pyschools%E4%B8%ADwhile-9-13/","content":"09 Square Root Approximation\nlink：http://www.pyschools.com/quiz/view_question/s5-q9\nCreate a function that takes in a positive number and return 2 integers such that the number is between the squares of the 2 integers. It returns the same integer twice if the number is a square of an integer.\nExamples\n&gt;&gt;&gt; sqApprox(2)(1, 2)&gt;&gt;&gt; sqApprox(4)(2, 2)&gt;&gt;&gt; sqApprox(5.1)(2, 3)\nAnswer 1\nimport mathdef sqApprox(num):    return (math.floor(num**0.5),math.ceil(num**0.5))\nAnswer 2\ndef sqApprox(num):    i = 0    minsq = 0             # set lower bound    maxsq = int(num) + 1  # set upper bound    while i &lt; maxsq:        if i * i &lt;= num and i &gt;= minsq:  # complete inequality condition            minsq = i        if i * i &gt;= num and i &lt;= maxsq:  # complete inequality condition            maxsq = i        i += 1                           # update i so that &#x27;while&#x27; will terminate    return (minsq, maxsq)\n10 Pi Approximation\nlink:http://www.pyschools.com/quiz/view_question/s5-q10\nCreate a function that computes the approximation of pi, based on the number of iterations specified.\npi can be computed by 4*(1-1/3+1/5-1/7+1/9- ...).\nExamples\n&gt;&gt;&gt; piApprox(1)4.0&gt;&gt;&gt; piApprox(10)3.04183961893&gt;&gt;&gt; piApprox(300)3.13825932952\nAnswer\ndef piApprox(num):    i = 1    pi = 0    while i &lt;= num:        pi += 4 * (-1) ** (i + 1) * (1.0 / (2 * i - 1))        i += 1    return pi\n11 Estimate Pi\nlink:http://www.pyschools.com/quiz/view_question/s5-q11\nWrite a function estimatePi() to estimate and return the value of pi based on the formula found by an Indian Mathematician Srinivasa Ramanujan. It should use a while loop to compute the terms of the summation until the last item is smaller than 1e -15. The formula for calculating distance is given below:\n\n\n\nExamples\n&gt;&gt;&gt; estimatePi()3.14159265359\nAnswer\ndef estimatePi():    import math    def factorial(n):        if n == 0:            return 1        else:            return n * factorial(n - 1)    item = 1103    k = 0    pi = 0    while item &gt; 1e-15:        item = (            (factorial(4 * k) * (1103.0 + 26390 * k))            / factorial(k) ** 4            / 396 ** (4 * k))        pi += 2 * 2 ** (0.5) / 9801 * item        k += 1    return 1 / pi\n12 Prime Factorization\nlink:http://www.pyschools.com/quiz/view_question/s5-q12\nGiven a positive integer, write a function that computes the prime factors that can be multplied together to get back the same integer.\nExamples\n&gt;&gt;&gt; primeFactorization(60)[2, 2, 3, 5]&gt;&gt;&gt; primeFactorization(1050)[2, 3, 5, 5, 7]&gt;&gt;&gt; primeFactorization(1)[]\nAnswer 1\ndef primeFactorization4(num):    def prime(num):        if num &lt; 2:            return 0        for i in range(2, int(num ** 0.5) + 1):            if num % i == 0:                return 0        else:            return 1    ls = []    start = 2    while prime(num) == 0 and num &gt; 1:        for i in range(start, int(num ** 0.5) + 1):          #if num % i == 0 and prime(i):            if num % i == 0:                ls.append(i)                num = num // i                start = i                break    if prime(num):        ls.append(num)    return ls\nAnswer 2 **\ndef primeFactorization(num):    possible = [2] + list(range(3, int(num ** 0.5) + 1, 2))    for p in possible:        if num % p == 0:            return [p] + primeFactorization(num / p)    if num &lt; 2:        return []    return [num]\nAnswer 3\ndef primeFactorization(num):     factor=[]    while num&gt;1:        for i in range(2,num+1):            if num%i==0:                factor.append(i)                num = num//i                break    return factor\nTime complexity comparison\nimport timedef primeFactorization1(num):    def prime(num):        if num &lt; 2:            return 0        for i in range(2, int(num ** 0.5) + 1):            if num % i == 0:                return 0        else:            return 1    ls = []    start = 2    while prime(num) == 0 and num &gt; 1:        for i in range(start, int(num ** 0.5) + 1):            if num % i == 0 and prime(i):                ls.append(i)                num = num // i                start = i                break    if prime(num):        ls.append(num)    return lsdef primeFactorization2(num):    possible = [2] + list(range(3, int(num ** 0.5) + 1, 2))    for p in possible:        if num % p == 0:            return [p] + primeFactorization2(num / p)    if num &lt; 2:        return []    return [num]for c in [100, 1e6, 1e10, 1e14]:    print(c)    t0 = time.time()    primeFactorization1(c)    t1 = time.time()    print(&#x27;%.10f&#x27; % (t1 - t0))    primeFactorization2(c)    t2 = time.time()    print(&#x27;%.10f&#x27; % (t2 - t1))# 100# 0.0000226498# 0.0000531673# 1e6# 0.0000638962# 0.0000970364# 1e10# 0.0000720024# 0.0017700195# 1e14# 0.0000679493# 0.2322161198\n\nleetcode:[剑指 Offer 49. 丑数]\nleetcode:[263. Ugly Number]\nleetcode:[264. Ugly Number II]\nleetcode:[1201. Ugly Number III]\nleetcode:[507. Perfect Number]\nleetcode:[1390. Four Divisors]\n\n13 Lowest Common Multiple\nlink:http://www.pyschools.com/quiz/view_question/s5-q13\nThe smallest common multiple of two or more numbers is called the lowest common multiple (LCM). Given a list of integers, find the lowest common multiple.\nExamples\n&gt;&gt;&gt; LCM([2, 3, 4])12&gt;&gt;&gt; LCM([3, 6, 9])18&gt;&gt;&gt; LCM([3, 3])3\nAnswer 1\ndef LCM(nums):     def lcm(a, b):        c = a        while True:            if c % a == 0 and c % b == 0:                return c                break            c += 1    l=lcm(nums[0],nums[1])    for i in nums[2:]:        l=lcm(l,i)    return l\nAnswer 2\nfrom math import gcd # Python versions 3.5 and above#from fractions import gcd # Python versions below 3.5from functools import reduce # Python version 3.xdef LCM(denominators):    return reduce(lambda a,b: a*b // gcd(a,b), denominators)\n\nfunctools.``reduce(function, iterable[, initializer])\n\nApply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the iterable. If the optional initializer is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If initializer is not given and iterable contains only one item, the first item is returned.Roughly equivalent to:\ndef reduce(function, iterable, initializer=None):    it = iter(iterable)    if initializer is None:        value = next(it)    else:        value = initializer    for element in it:        value = function(value, element)    return value\nSee itertools.accumulate() for an iterator that yields all intermediate values.\n\nAs of Python 3.9 lcm() function has been added in the math library. It can be called with the following signature:\n\nmath.lcm(*integers)\n\nReturn the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\n\nAnswer 3\ndef LCM(nums):  def gcd(n, m):      if m == 0:          return n      return gcd(m, n % m)  lcm = 1  for i in nums:      lcm = lcm * i // gcd(lcm, i)  return lcm\nAnswer 4\nimport numpy as npnp.lcm.reduce([40, 12, 20])\n","categories":["题解"]},{"title":"矩阵求导与分子、分母布局","url":"/2022/02/05/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E4%B8%8E%E5%88%86%E5%AD%90%E3%80%81%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80/","content":"原文见：矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇）\n1 函数与标量、向量、矩阵\n考虑一个函数 \\[\n\\text{function}(\\text{input})\n\\]\n针对 \\(function\\) 的类型、\\(input\\) 的类型，我们可以将这个函数分为 \\(function\\) 不同的种类。\n1、 \\(function\\) 是一个标量\n我们称 \\(function\\) 是一个实值标量函数。用细体小写字母 \\(f\\) 表示。\n1.1 \\(input\\) 是一个标量\n我们称 \\(function\\) 的变元是标量。用细体小写字母 \\(x\\) 表示。\n例1： \\[\nf(x)=x+2\n\\]\n1.2 \\(input\\) 是一个向量\n我们称 \\(function\\) 的变元是向量。用粗体小写字母 \\(\\pmb{x}\\) 表示。\n例2：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\nf(\\pmb{x})=a_1x_1^2+a_2x_2^2+a_3x_3^2+a_4x_1x_2\n\\]\n1.3 \\(input\\) 是一个矩阵\n我们称 \\(function\\) 的变元是矩阵。用粗体大写字母 \\(\\pmb{X}\\) 表示。\n例3：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\nf(\\pmb{X})=a_1x_{11}^2+a_2x_{12}^2+a_3x_{21}^2+a_4x_{22}^2+a_5x_{31}^2+a_6x_{32}^2\n\\]\n\\[\n\\left\\{ \\begin{align*} \\frac{\\partial f}{\\partial x_1} &amp; = 2x_1+x_2 \\\\\\\\ \\frac{\\partial f}{\\partial x_2} &amp; = x_1+x_3 \\\\\\\\ \\frac{\\partial f}{\\partial x_3} &amp; = x_2 \\end{align*} \\right.\n\\]\n2、\\(function\\) 是一个向量\n我们称 \\(function\\) 是一个实向量函数 。用粗体小写字母表 \\(\\pmb{f}\\) 示。\n含义： \\(\\pmb{f}\\) 是由若干个 \\(f\\) 组成的一个向量。\n同样地，变元分三种：标量、向量、矩阵。这里的符号仍与上面相同。\n2.1 标量变元\n例4： \\[\n\\pmb{f}_{3\\times1}(x)= \\left[ \\matrix{ f_1(x)\\\\ f_2(x)\\\\ f_3(x)\\\\ } \\right] = \\left[  \\matrix{ x+1\\\\ 2x+1\\\\ 3x^2+1 } \\right]\n\\]\n2.2 向量变元\n例5：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\n\\pmb{f}_{3\\times1}(\\pmb{x})= \\left[ \\matrix{ f_1(\\pmb{x})\\\\ f_2(\\pmb{x})\\\\ f_3(\\pmb{x})\\\\ } \\right] = \\left[  \\matrix{ x_{1}+x_{2}+x_{3}\\\\ x_{1}^2+2x_{2}+2x_{3}\\\\ x_{1}x_{2}+x_{2}+x_{3} } \\right] \n\\]\n2.3 矩阵变元\n例6：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\n\\pmb{f}_{3\\times1}(\\pmb{X})= \\left[ \\matrix{ f_1(\\pmb{X})\\\\ f_2(\\pmb{X})\\\\ f_3(\\pmb{X})\\\\ } \\right] = \\left[  \\matrix{ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}+x_{11}x_{12}\\\\ 2x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}+x_{11}x_{12} } \\right]\n\\]\n3、\\(function\\) 是一个矩阵\n我们称 \\(function\\) 是一个实矩阵函数 。用粗体大写字母 \\(\\pmb{F}\\) 表示。\n含义： \\(\\pmb{F}\\) 是由若干个 \\(f\\) 组成的一个矩阵。\n同样地，变元分三种：标量、向量、矩阵。这里的符号仍与上面相同。\n3.1 标量变元\n例7： \\[\n\\pmb{F}_{3\\times2}(x)= \\left[ \\matrix{ f_{11}(x) &amp; f_{12}(x)\\\\ f_{21}(x) &amp; f_{22}(x)\\\\ f_{31}(x) &amp; f_{32}(x)\\\\ } \\right] = \\left[  \\matrix{ x+1 &amp; 2x+2\\\\ x^2+1 &amp; 2x^2+1\\\\ x^3+1 &amp; 2x^3+1 } \\right]\n\\]\n3.2 向量变元\n例8：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\n\\pmb{F}_{3\\times2}(\\pmb{x})= \\left[ \\matrix{ f_{11}(\\pmb{x}) &amp; f_{12}(\\pmb{x})\\\\ f_{21}(\\pmb{x}) &amp; f_{22}(\\pmb{x})\\\\ f_{31}(\\pmb{x}) &amp; f_{32}(\\pmb{x})\\\\ } \\right] = \\left[  \\matrix{ 2x_{1}+x_{2}+x_{3} &amp; 2x_{1}+2x_{2}+x_{3} \\\\ 2x_{1}+2x_{2}+x_{3} &amp; x_{1}+2x_{2}+x_{3} &amp; \\\\ 2x_{1}+x_{2}+2x_{3} &amp; x_{1}+2x_{2}+2x_{3} &amp; } \\right]\n\\]\n3.3 矩阵变元\n例9：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\n\\begin{align*} \\pmb{F}_{3\\times2}(\\pmb{X})&amp;= \\left[ \\matrix{ f_{11}(\\pmb{X}) &amp; f_{12}(\\pmb{X})\\\\ f_{21}(\\pmb{X}) &amp; f_{22}(\\pmb{X})\\\\ f_{31}(\\pmb{X}) &amp; f_{32}(\\pmb{X})\\\\ } \\right]\\\\\\\\ &amp;= \\left[  \\matrix{ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 2x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ 3x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 4x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ 5x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 6x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} } \\right] \\end{align*}\n\\]\n4、总结\n\n\n\nFunction\\input\n标量变元\n向量变元\n矩阵变元\n\n\n\n\n实值标量函数\n\\(f(x)\\)\n\\(f(\\pmb{x})\\)\n\\(f(\\pmb{X})\\)\n\n\n实向量函数\n\\(\\pmb{f}(x)\\)\n\\(\\pmb{f}(\\pmb{x})\\)\n\\(\\pmb{f}(\\pmb{X})\\)\n\n\n实矩阵函数\n\\(\\pmb{F}(x)\\)\n\\(\\pmb{F}(\\pmb{x})\\)\n\\(\\pmb{F}(\\pmb{X})\\)\n\n\n\n2 矩阵求导的本质\n对于一个多元函数\n例10： \\[\nf(x_1,x_2,x_3)=x_1^2+x_1x_2+x_2x_3\n\\] 我们可以将 \\(f\\) 对 \\(x_1,x_2,x_3\\) 偏导分别求出来，即： \\[\n\\left\\{ \\begin{align*} \\frac{\\partial f}{\\partial x_1} &amp; = 2x_1+x_2 \\\\\\\\ \\frac{\\partial f}{\\partial x_2} &amp; = x_1+x_3 \\\\\\\\ \\frac{\\partial f}{\\partial x_3} &amp; = x_2 \\end{align*} \\right. \n\\]\n矩阵求导也是一样的，本质就是 \\(function\\) 中的每个 \\(f\\) 分别对变元中的每个元素逐个求偏导，只不过写成了向量、矩阵形式而已。\n我们把得出的3个结果写成列向量形式： \\[\n\\frac{\\partial f(\\pmb{x})}{\\partial \\pmb{x}_{3\\times1}}= \\left[ \\matrix{ \\frac{\\partial f}{\\partial x_1}\\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\frac{\\partial f}{\\partial x_3}\\\\ } \\right] = \\left[  \\matrix{ 2x_1+x_2\\\\ x_1+x_3\\\\ x_2 } \\right]\n\\] 一个矩阵求导以列向量形式展开的雏形就出现了。\n当然我们也可以以行向量形式展开： \\[\n\\frac{\\partial f(\\pmb{x})}{\\partial \\pmb{x}_{3\\times1}^T}=  \\left[  \\frac{\\partial f}{\\partial x_1}, \\frac{\\partial f}{\\partial x_2}, \\frac{\\partial f}{\\partial x_3}  \\right]  =  \\left[   2x_1+x_2, x_1+x_3, x_2  \\right]\n\\] 所以，如果 \\(function\\) 中有 \\(m\\) 个 \\(f\\) ，变元中有 \\(n\\) 个元素，那么，每个 \\(f\\) 对变元中的每个元素逐个求偏导后，我们就会产生 \\(m\\times n\\) 个结果。至于结果的布局，是写成行向量，还是写成列向量，还是写成矩阵，就是我们接下来要讨论的事情。\n3 矩阵求导结果的布局\n不严谨地说，从直观上看：分子布局，就是分子是列向量形式，分母是行向量形式；分母布局，就是分母是列向量形式，分子是行向量形式。\n不同类型的变元，严谨的布局说明见原文：矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇）\n补充：来自机器学习中的矩阵和向量的求导\nx表示n维向量，X表示m×n维度的矩阵,y表示m维向量，Y表示p×q 维度的矩阵。\n\n\n\n解释几点：\n\n对于一个复杂的变量求导的时候，比如复合函数求导涉及到后面要讲的链式求导时候，只能选一种求导布局，不能同时出现分子布局和分母布局,分子布局与分母布局算出的结果只相差一个转置\n列向量y对列向量x的求导的分子布局形式可以理解为，分子向量y对分母向量x的第一个标量元素求导后排在第一列，对第二个标量元素求导后排在第二列，以此类推，排成一个m×n的矩阵。 也被称为雅克比矩阵：\n\n\n\n图中的默认布局是指常用的布局形式(向量和矩阵在分子上就用分子布局，否则用分母布局)，也是符合大家习惯的写法。\n\n4 分子布局、分母布局的本质\n总结：\n1、分子布局的本质：分子是标量、列向量、矩阵向量化后的列向量；分母是标量、列向量转置后的行向量、矩阵的转置矩阵、矩阵向量化后的列向量转置后的行向量。\n2、分母布局的本质：分子是标量、列向量转置后的行向量、矩阵向量化后的列向量转置后的行向量；分母是标量、列向量、矩阵自己、矩阵向量化后的列向量。\n思考一下，其实可以再简洁一些：谁转置了，就是另一方的布局。分子转置了，就是分母布局；分母转置了，就是分子布局。\n","categories":["数学基础"]},{"title":"07自动求导至08线性回归+基础优化算法","url":"/2022/02/06/07-08/","content":"筛选的Q&amp;A\n1、为什么深度学习中一般对标量求导而不是对矩阵或者向量？\n因为loss通常是一个标量，精度和loss在机器学习中都是一个标量。如果loss变成一个向量，那就会很麻烦。而且向量关于矩阵的loss就会变成一个矩阵，那么，矩阵再往下走，就会变成一个四维矩阵，那么神经网络一深，那就会变成一个特别特别大的张量，就算不出来了，所以loss通常是一个标量。\n2、多个loss分别反向的时候是不是要累计梯度？\n是的，假设在之后的神经网络有多个损失函数的话，是需要累积梯度的。也是为什么torch是默认累计梯度的。\n3、为什么获取grad前需要backward？\n不做backward的话不会去计算梯度，计算梯度是很贵的一件事情（时间和内存上）。\n4、求导过程一般来说是不是有向图？有没有环状的图结构？\n循环神经网络，但是计算上还是会展开，虽然逻辑上是有环的图。\n5、为什么用平方损失而不用绝对差值呢？\n因为绝对差值不可导。\n6、为什么机器学习优化算法都采用梯度下降，而不采用牛顿法？收敛速度更快，一般能算出一阶导，二阶导也能算。\n首先，二阶导不好算，不是总是能算出来的。 统计模型（损失函数），优化模型（我用什么算法优化），所以说把统计模型的最优解求出来的意义并不大，收敛快不快不那么关心。关心的是收敛导哪个地方，泛化性不一定比梯度下降好，不一定更实用。\n7、detach是什么作用\n告诉程序不用算梯度了。\n8、每次都随机取出一部分，怎么保证最后所有数据都被拿过了？\nbootstraping采样。次数多的情况下会遇到所有的数据，数据多的话也没必要所有的数据都用到。\n9、如果样本大小不是批量数的整数倍，那需要随机剔除多余的样本吗？\n\n改batch_size，使得epoch迭代完整\n忽略最后一次epoch的迭代\n不足部分从原有数据中抽出差额补齐\n\n08 线性回归 + 基础优化算法【动手学深度学习v2】\n","categories":["动手学深度学习v2"]}]