[{"title":"Hello World","url":"/2022/01/04/hello-world/","content":"2022，你好。\n","categories":["hello"]},{"title":"一些解决方案","url":"/2022/01/09/%E4%B8%80%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"\n关于Hexo添加Mathjax相关问题及解决方法：https://d-veda.top/2018/11/11/Hexo-with-Mathjax/\nmarkdown中希腊字母加粗：https://blog.csdn.net/qq_28714865/article/details/103717900\n让公式中的某些数学符号加粗显示，可以使用\"​\"，比如 \\(\\mathbf{0123456789}\\) . 加粗希腊字母（比如书写向量或者矩阵时），使用\"\"，比如 \\(\\pmb{\\lambda}\\) .\nLaTeX输入单个点、横向多个点、竖向多个点、斜向多个点：https://blog.csdn.net/GarfieldEr007/article/details/51619866\n\n输入单个点：\n横向多个点：\n竖向多个点：\n斜向多个点：\n\n使用Markdown写矩阵：https://blog.csdn.net/qq_38228254/article/details/79469727\n\n"},{"title":"八大常见类型的行列式及其解法","url":"/2022/01/09/%E5%85%AB%E5%A4%A7%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%B3%95/","content":"来源：https://zhuanlan.zhihu.com/p/34685081\n\n本文记录了八大常见类型的行列式及其解法，解法从一般性到特殊性都有，分享给大家，例子都特别经典好用，希望对线代、高代初学者以及考研党有用。\n\n类型总览：\n\n箭型行列式\n两三角型行列式\n两条线型行列式\n范德蒙德型行列式\n\\(Hessenberg\\)型行列式\n三对角型行列式\n各行元素和相等型行列式\n相邻两行对应元素相差K倍型行列式\n\n方法总览：\n\n拆行法\n升阶法\n方程组法\n累加消点法\n累加法\n递推法（特征方程法）\n步步差法\n\n一：箭型行列式\n最常见最常用的行列式，特征很好辨识，必须掌握，请看下例：\n\\[\neg:D_n= \\left|\\begin{array}{cccc} x_1&amp;1&amp;1 &amp;... &amp;1\\\\ 1&amp;x_2&amp;&amp;&amp;\\\\ 1&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 1&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|(空白处都为0)\n\\]\n\\(Solution\\): 将第一列元素依次减去第$ i$ 列的\\(\\frac{1}{x_i}\\) ,$i=2...n $\n得：\n\\[\nD_n= \\left|\\begin{array}{cccc} x_1-\\frac{1}{x_2}-...-\\frac{1}{x_n}&amp;1&amp;1 &amp;... &amp;1\\\\ 0&amp;x_2&amp;&amp;&amp;\\\\ 0&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 0&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|\n\\]\n所以：\n\\[\nD_n=\\prod_{i=2}^{n}x_i(x_1-\\sum_{i=2}^{n}\\frac{1}{x_i})\n\\]\n二：两三角型行列式\n\n特征为对角线上方元素均为\\(a\\) ,下方元素均为\\(b\\)\n\n\n当 \\(a=b\\) 时可化为箭型行列式计算，当 \\(a\\not=b\\) 时采用拆行法计算，请看下面两例\n\n\\[\neg1(a=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b&amp;x_2&amp;b&amp;...&amp;b\\\\ b&amp;b&amp;x_3&amp;...&amp;b\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i，i=2...n\\) 行都减去第一行\n得： \\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b-x_1&amp;x_2-b&amp;0&amp;...&amp;0\\\\ b-x_1&amp;0&amp;x_3-b&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b-x_1&amp;0&amp;0&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n即化成了箭型行列式，所以：\n\\[\nD_n=[\\prod_{i=2}^{n}(x_i-b)]\\times[x_1-b(b-x_1)\\sum_{i=2}^{n}\\frac{1}{x_i-b}] \n\\]\n\n\\[\neg2(a\\not=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 采用拆行法，目的是为了降阶\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a+0\\\\ b&amp;x_2&amp;a&amp;...&amp;a+0\\\\ b&amp;b&amp;x_3&amp;...&amp;a+0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n+b-b \\end{array}\\right| \n\\]\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;b \\end{array}\\right|_{(*)}+\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;0\\\\ b&amp;x_2&amp;a&amp;...&amp;0\\\\ b&amp;b&amp;x_3&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n将第 \\(i,i=1...n-1\\) 列都减去最后一列，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1-a&amp;0&amp;0 &amp;... &amp;a\\\\ b-a&amp;x_2-a&amp;0&amp;...&amp;a\\\\ b-a&amp;b-a&amp;x_3-a&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;b \\end{array}\\right|+(x_n-b)D_{n-1} \n\\]\n所以： \\[\nD_n=b\\prod_{i=1}^{n-1}(x_i-a)+(x_n-b)D_{n-1}\n\\]\n再由行列式转置不变性得到：\n\\[\nD_n=a\\prod_{i=1}^{n-1}(x_i-b)+(x_n-a)D_{n-1}\n\\]\n联立\\((11)(12)\\) ,得通式：\n\\[\nD_n=\\frac{1}{a-b}[a\\prod_{i=1}^{n}(x_i-b)-b\\prod_{j=1}^{n}(x_j-a)]\n\\]\n\n通过适当变换可以化为两三角型行列式的，描述不如大家自己看例子揣摩，也很容易理解的，请看下例\n\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} d&amp;b&amp;b &amp;... &amp;b\\\\ c&amp;x&amp;a&amp;...&amp;a\\\\ c&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ c&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n\\(Solution\\): 将第一行乘上 \\(\\frac{a}{b}\\) ，第一列乘上 \\(\\frac{a}{c}\\)，得：\n\\[\nD_n=\\frac{bc}{a^2}\\left|\\begin{array}{cccc} \\frac{a^2d}{bc}&amp;a&amp;a &amp;... &amp;a\\\\ a&amp;x&amp;a&amp;...&amp;a\\\\ a&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n即化成了两三角型行列式\n\n一些每行上有公因子但是无法向上式那样在保持行列式不变得基础上能提出公因子的，采用升阶法，请看下例\n\n\\[\neg4:D_n=\\left|\\begin{array}{cccc} 1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n\\(Solution\\): 加边升阶，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ 0&amp;1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ 0&amp;x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ 0&amp;x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n再将第 \\(i,i=2...n+1\\) 都减去第一行的\\(x_i，i=1...n\\) 倍，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ -x_1&amp;1&amp;0&amp;0 &amp;... &amp;0\\\\ -x_2&amp;0&amp;1&amp;0&amp;...&amp;0\\\\ -x_3&amp;0&amp;0&amp;1&amp;...&amp;0\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -x_n&amp;0&amp;0&amp;0&amp;...&amp;1 \\end{array}\\right| \n\\]\n即又化成了箭型行列式，可得通式：\n\\[\nD_n=1+\\sum_{i=1}^{n}x_{i}^{2} \n\\]\n三：两条线型行列式\n特征是除了主(次)对角线或与其相邻得一条斜线所组成的任意一条线加四个顶点中的某个顶点外，其他元素均为\\(0\\)，这类行列式可以直接展开降阶。这段描述有点繁琐，但其实也并不复杂，请看下例理解\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} a_1&amp;b_1&amp; &amp;... &amp;\\\\ &amp;a_2&amp;b_2&amp;...&amp;\\\\ &amp;&amp;a_3&amp;...&amp;\\\\ &amp;&amp;&amp;\\\\ &amp;&amp;...&amp;a_{n-1}&amp;b_{n-1} \\\\ b_n&amp;&amp;...&amp;&amp;a_n \\end{array}\\right| (空白处都为0)\n\\]\n\\(Solution\\): 按照第一列两个非\\(0\\)元素拉普拉斯展开即可\n\\[\nD_n=\\prod_{i=1}^{n}a_i+(-1)^{n+1}\\prod_{i=1}^{n}b_i \n\\]\n四：范德蒙德型行列式\n范德蒙德行列式大家应该熟悉，而范德蒙德型行列式的特征就是有逐行(列)元素按幂递增(减)，可以将其转化为范德蒙德行列式来计算，请看下例\n\\[\neg:D_n=\\left|\\begin{array}{cccc} a_{1}^n&amp; a_{1}^{n-1}b_1&amp;... &amp;a_1b_1^{n-1}&amp;b_1^n\\\\ a_{2}^n&amp;a_{2}^{n-1}b_2&amp;...&amp;a_2b_2^{n-1}&amp;b_2^n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{n}^n&amp;a_{n}^{n-1}b_n&amp;...&amp;a_nb_n^{n-1}&amp;b_n^n\\\\ a_{n+1}^n&amp;a_{n+1}^{n-1}b_{n+1}&amp;...&amp;a_{n+1}b_{n+1}^{n-1}&amp;b_{n+1}^n \\end{array}\\right| \n\\]\n\\(Solution\\): 将每行都提出 \\(a_i^{n}\\),$i=1...n+1 $倍，得：\n\\[\nD_n=\\prod_{i=1}^{n+1}a_i^n\\left|\\begin{array}{cccc} 1&amp; \\frac{b_1}{a_1}&amp;... &amp;(\\frac{b_1}{a_1})^{n-1}&amp;(\\frac{b_1}{a_1})^{n}\\\\ 1&amp;\\frac{b_2}{a_2}&amp;...&amp;(\\frac{b_2}{a_2})^{n-1}&amp;(\\frac{b_2}{a_2})^{n}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 1&amp;\\frac{b_n}{a_n}&amp;...&amp;(\\frac{b_n}{a_n})^{n-1}&amp;(\\frac{b_n}{a_n})^{n}\\\\ 1&amp;\\frac{b_{n+1}}{a_{n+1}}&amp;...&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n-1}&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n} \\end{array}\\right| \n\\]\n上式即为范德蒙德行列式，所以通式为：\n\\[\nD_n=\\prod_{1\\le i&lt;j\\le n+1}(a_ib_j-b_ia_j)\n\\]\n五：\\(Hessenberg\\)型行列式\n特征为除了主(次)对角线及与其相邻的斜线，再加上第一行(列)或第\\(n\\)行(列)外，其余元素均为\\(0\\)。这类行列式有点像前面说的两条线型行列式，但是还是有一点区别的。这类行列式都用累加消点法，即通常将某一行(列)都化简到只有一个非\\(0\\)元素，以便于降阶计算，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 1&amp;-1&amp;&amp;&amp;&amp;\\\\ &amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ &amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ &amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n\\(Solution\\): 将各列都加到第一列，得到：\n\\[\nD_n= \\left|\\begin{array}{cccc} \\frac{n(n+1)}{2}&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 0&amp;-1&amp;&amp;&amp;&amp;\\\\ 0&amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ 0&amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n降阶之后再重复上述步骤即可得到通式：\n\\[\nD_n=(-1)^{n-1}\\frac{(n+1)!}{2} \n\\]\n注：需要说明的是，上面举的例子比较容易看出如何实施累加消点法就可以实现将某一行(列)都化简到只有一个非\\(0\\)元素从而达到降阶的目的，但是还有很多\\(Hessenberg\\)型行列式并不这么容易就做到，还需要大家找找技巧稍微变换一下，只要始终记得你要用累加消点法来消元来降阶就可以了\n六：三对角型行列式\n这是一种递推结构的行列式，特征为所有主子式都有相同的结构，从而以最后一列展开，将所得的\\((n-1)\\) 阶行列式再展开即得递推公式，即递推法(特征方程法)，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} a&amp;b&amp; &amp;&amp;... &amp;&amp;&amp;\\\\ c&amp;a&amp;b&amp;&amp;...&amp;&amp;&amp;\\\\ &amp;c&amp;a&amp;b&amp;...&amp;&amp;\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;\\\\ &amp;&amp;&amp;&amp;...&amp;a&amp;b\\\\ &amp;&amp;&amp;&amp;...&amp;c&amp;a \\end{array}\\right| \n\\]\n\\(Solution\\): 按第一列拉普拉斯展开，得：\n\\[\nD_n=aD_{n-1}-bcD_{n-2} \n\\]\n解特征方程： \\(x^2=ax-bc\\) ，得：\n\\[\nx_1=\\frac{a+\\sqrt{a^2-4bc}}{2}\n\\]\n\\[\nx_2=\\frac{a-\\sqrt{a^2-4bc}}{2} \n\\]\n即可得通式：\n\\[\nD_n = \\frac{x_1^{n+1}-x_2^{n+1}}{x_1-x_2} \n\\]\n注：特征方程法我没记错的话，应该是在高中将数列的时候用到的。\n七：各行元素和相等型行列式\n这个特征已经很清楚了吧，方法就是累加法，很简单，直接看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1+x_1&amp;x_1 &amp;... &amp;x_1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i,i=2...n\\)行都加到第一行去，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1+\\sum_{i=1}^{n}x_i&amp;1+\\sum_{i=1}^{n}x_i &amp;... &amp;1+\\sum_{i=1}^{n}x_i\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;1 &amp;... &amp;1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right|= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;0&amp;... &amp;0\\\\ x_2&amp;1&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;0&amp;...&amp;1 \\end{array}\\right|=1+\\sum_{i=1}^{n}x_i \n\\]\n八：相邻两行对应元素相差K倍型行列式\n这个要用步步差法\n(1)大部分元素为数字，且相邻两行对应元素相差为\\(1\\)，采用逐步作差的方法，即可出现大量 \\(\\pm1\\) 元素，进而出现大量\\(0\\)元素\n(2)若相邻两行相差\\(K\\)倍，采用逐步作\\(k\\)倍差得方法，即可出现大量\\(0\\)元素\n请看下面两个例子\n\\[\neg1:D_n= \\left|\\begin{array}{cccc} 0&amp;1&amp;2 &amp;...&amp;n-2 &amp;n-1\\\\ 1&amp;0&amp;1&amp;...&amp;n-3&amp;n-2\\\\ 2&amp;1&amp;0&amp;...&amp;n-4&amp;n-3\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ n-2&amp;n-3&amp;n-4&amp;...&amp;0&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行减去后一行，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;1&amp;1 &amp;...&amp;1 &amp;1\\\\ -1&amp;-1&amp;1&amp;...&amp;1&amp;1\\\\ -1&amp;-1&amp;-1&amp;...&amp;1&amp;1\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-1&amp;-1&amp;...&amp;-1&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n再将第一列加到第\\(i,i=2...n\\) 列，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;-2&amp;...&amp;0&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-2&amp;-2&amp;...&amp;-2&amp;0\\\\ n-1&amp;2n-3&amp;2n-4&amp;...&amp;n&amp;n-1 \\end{array}\\right|=(-1)^{n-1}(-2)^{n-2}(n-1) \n\\]\n\n\\[\neg2:D_n= \\left|\\begin{array}{cccc} 1&amp;a&amp;a^2 &amp;...&amp;a^{n-2} &amp;a^{n-1}\\\\ a^{n-1}&amp;1&amp;a&amp;...&amp;a^{n-3} &amp;a^{n-2} \\\\ a^{n-2} &amp;a^{n-1} &amp;1&amp;...&amp;a^{n-4} &amp;a^{n-3} \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ a^2&amp;a^3&amp;a^4&amp;...&amp;1&amp;a\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行加上后一行的\\((-a)\\) 倍，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1-a^n&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ a^{n-1}&amp;1-a^n&amp;0&amp;...&amp;0 &amp;0\\\\ 0 &amp;0 &amp;1-a^n&amp;...&amp;0&amp;0 \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;1-a^n&amp;0\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n=(1-a^n)^{n-1}\n\\]\n","categories":["机器学习数学基础"]},{"title":"机器学习数学基础：微积分","url":"/2022/01/08/%E5%BE%AE%E7%A7%AF%E5%88%86/","content":"本章介绍微积分中的函数、极限、导数、梯度及积分等基本概念。\n1 函数和极限\n1.1 函数的定义\n设 \\(A\\)，\\(B\\) 都是非空的数的集合，\\(f:x \\rightarrow y\\) 是从 \\(A\\) 到 \\(B\\) 到一个对应法则，那么从 \\(A\\) 到 \\(B\\) 的映射\\(f:x \\rightarrow y\\) 就叫做函数，记作 \\(y=f(x)\\) ，其中 \\(x \\in A\\)，\\(y \\in B\\) .\n1.2 反函数\n设函数 $ y =f(x) $ 的定义域是 \\(D\\)，值域是 \\(f(D)\\) 。如果对于值域 \\(f(D)\\) 中的每一个 \\(y\\) ，在 \\(D\\) 中有且仅有一个 \\(x\\) 使得 \\(g(y)=x\\) ，则按此对应法则得到了一个定义在 \\(f(D)\\) 上的函数，并把该函数称为函数 \\(y=f(x)\\) 的反函数，记作 \\(x=f^{-1}(y)\\)，\\(y \\in f(D)\\) .\n1.3 复合函数\n若 \\(y\\) 是 \\(u\\) 的函数：\\(y=f(u)\\) ，而 $u $ 又是 \\(x\\) 的函数：\\(u=g(x)\\) ，且 \\(g(x)\\) 的函数值的全部或部分在 \\(f(u)\\) 的定义域内，则 \\(y\\) 通过 \\(u\\) 成为 \\(x\\) 的函数，这种函数称为由函数 \\(u=g(x)\\) 和函数 \\(y=f(u)\\) 构成的复合函数，记作 \\(y=f[g(x)]\\) ，其中 \\(u\\) 叫作中间变量。\n1.4 多元函数\n设有两个独立的变量 \\(x\\) 与 \\(y\\) 在其给定的变域 $ D$ 中，任取一组数值时，第 \\(3\\) 个变量 $ z$ 就以某一确定的法则有唯一确定的值与其对应，那么变量 \\(z\\) 称为 \\(x\\) 和 \\(y\\) 的二元函数，记作 \\(z=f(x,y)\\) ，其中 \\(x\\) 与 \\(y\\) 称为自变量，函数 \\(z\\) 也叫作因变量，自变量 \\(x\\) 与 \\(y\\) 的变域 \\(D\\) 称为函数的定义域。\n1.5 函数极限的性质\n数列极限的定义：给定数列 $ {x_n}$ ，实常数 \\(a\\) ，若对任意给定的 \\(\\epsilon&gt;0\\) ，可以找到正整数 \\(N\\) ，使得当 \\(n&gt;N\\) 时，$ |x_n-a|&lt;$ 成立，则称数列 $ {x_n}$收敛于 \\(a\\) （或称 \\(a\\) 是数列 $ {x_n}$ 的极限）。\n自变量趋向于无穷大时函数极限的定义： 类似数列极限的定义。\n自变量趋向有限值时函数极限的定义：设函数 \\(f(x)\\) 在某点 \\(x_0\\) 的某个去心邻域内有定义，后面类似数列极限的定义。\n一些懒得敲公式的知识概念：数列极限的夹逼定理、函数极限的夹逼定理、函数极限的运算法则（加减乘除幂）、无穷大量和无穷小量。\n两个公式： \\[\n\\lim\\limits_{x\\rightarrow0}\\frac{\\text{sin} x}{x}=1\\\\\n\\lim\\limits_{x\\rightarrow0}(1+x)^{\\frac{1}{x}}=e\n\\]\n1.6 洛必达法则\n适用于 \\(\\large\\frac{0}{0}\\) 和 \\(\\large\\frac{\\infty}{\\infty}\\) 及其变式。\n1.7 函数的连续性\n一些懒得敲公式的知识概念：函数连续性定义、最值定理、介值定理、零点存在定理（勘根定理）\n1.8 拉格朗日乘数法\n拉格朗日乘数法可以解决约束优化问题。其基本思想是通过引入拉格朗日乘子来将含有 \\(n\\) 个变量和 \\(k\\) 个约束条件的约束优化问题转化成含有 \\(n+k\\) 个变量的无约束优化问题。是解决带等式约束优化问题的常用方法。\n详见：\n好久不见的拉格朗日乘数法：https://zhuanlan.zhihu.com/p/149104728\n如何理解拉格朗日乘子法？：https://www.zhihu.com/question/38586401\n1.9 函数间断点\n即不满足函数连续定义的条件。分为：\n\n第一类间断点：左右极限有定义\n\n跳跃间断点：左右极限不相等\n可去间断点：左右极限相等\n\n第二类间断点：左右极限不全有定义\n\n习题\n利用 \\(SymPy^{[1]}\\) 库实现 \\(\\lim\\limits_{a\\rightarrow 0}\\frac{sin(a)}{a}\\) 和 \\(\\lim\\limits_{n\\rightarrow\\infty}(\\frac{n+3}{n+2})^n\\) 的求解。\n#coding:utf-8import sympysympy.init_printing()from sympy import oo# 1.求sin(a) / a在a=0处的极限a = sympy.Symbol(&#x27;a&#x27;)b = sympy.sin(a) / aresult = sympy.limit(b,a,0)print(&#x27;sin(a) / a在a趋近于0处的极限:&#x27;,result)#2.求[(n+3)/(n+2)]^n ,n趋紧无穷大时的极值n = sympy.Symbol(&#x27;n&#x27;)y = ((n+3)/(n+2))**nprint ( &#x27;[(n+3)/(n+2)]^n ,n趋紧无穷大的极值：&#x27;,sympy.limit(y, n, sympy.oo) )\n2 导数\n2.1 导数的概念\n有定义，有增量，极限存在。是一种变化率\n2.2 偏导数、全导数\n偏导数相对于多元函数，全导数相对于复合函数。\n2.3 高阶导数\n多次连续求导。\n2.4 函数的基础求导法则\n一些懒得敲公式的知识概念：常用的求导公式、和与差的求导法则、复合函数的求导规则、反函数的求导法则、隐函数的求导法则等各种求导法则。\n2.5 链式法则及复杂函数的求导\n假设 \\(z = f(u, v)\\)的每一个自变量都是二元函数，也就是说，\\(u=h(x, y)\\) ，\\(v = g(x, y)\\) ，且这些函数都是可微的。那么，\\(z\\) 的偏导数为： \\[\n\\frac {\\delta z}{dx}  =  \\frac {\\delta z}{du}  \\frac {du}{dx}  +  \\frac {\\delta z}{dv} \\frac {\\delta v}{dx} \\\\\\\n \\frac {\\delta z}{dy}= \\frac {\\delta z}{du} \\frac {\\delta u}{dy}+\\frac {\\delta z}{dv} \\frac {\\delta v}{dy}\n\\] 如果我们考虑 $  =(u,v)$，为一个向量函数，我们可以用向量的表示法把以上的公式写成 \\(f\\) 的梯度与 \\(\\overrightarrow {r}\\) 的偏导数的数量积:\n\\[\n\\frac {\\delta f}{dx}  =  \\overrightarrow {V}  f  \\cdot   \\frac {\\theta r}{dx}\n\\] 更一般地,对于从向量到向量的函数,求导法则为: \\[\n\\frac {\\delta (z_ {1},\\cdots ,z_ {m})}{o(x_ {1},\\cdots ,x_ {p})} =  \\frac {d(z_ {1},\\cdots ,z_ {m})}{d(y_ {1},\\cdots ,y_ {n})}  \\frac {o(y_ {1},\\cdots ,y_ {n})}{o(x_ {1},\\cdots ,x_ {p})}\n\\]\n2.6 导数的应用\n一些懒得敲公式的知识概念：极值与最值、曲线的凸凹、拐点（凹弧的分界点）、泰勒公式和泰勒展开式、泰勒定理、中值定理（拉格朗日、罗尔和柯西中值定理）\n3 方向导数和梯度\n3.1 向量\n一些懒得敲公式的知识概念：向量的模、数量积（内积、点积、标量积 $ |a||b|cos$）、向量积（外积、叉积，它的模是 \\(|a||b|sin\\theta\\)）\n3.2 方向导数、梯度\n带有方向（极值方向，一般是取最大值的方向）的导数。\n3.3 雅可比矩阵与局部最优问题\n详见：雅可比矩阵和雅可比行列式：https://zhuanlan.zhihu.com/p/39762178\n3.4 黑塞矩阵\n二阶偏导数矩阵就是黑塞矩阵（Hessian Matrix）。它是一个自变量为向量的实值函数的二阶偏导数组成的方阵。\n\n如果H(M)是 正定矩阵，则临界点M处是一个局部的极小值。\n如果H(M)是 负定矩阵，则临界点M处是一个局部的极大值。\n如果H(M)是 不定矩阵，则临界点M处不是极值。\n\n习题\n调用 SymPy的库函数求解出雅可比矩阵的形式，调用Theano的库函数计算雅可比矩阵和黑塞矩阵的值。\n#实例01：用SymPy库函数求解出的雅克比矩阵的形式。import sympym,n,i,j = sympy.symbols(&quot;m n i j&quot;)m = i**4-2*j**3-1 #设置变量（符号）n = j-i*j**2+5funcs = sympy.Matrix([m,n])#矩阵的维度m,nargs = sympy.Matrix([i,j])res = funcs.jacobian(args)#调用jacobian函数求解print(res)#实例02：Theano库实现雅克比矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as T# 计算雅克比矩阵x=T.dvector(&#x27;x&#x27;)y=x**3+x**4# 调用scan构建循环GraphJ,updates=theano.scan(lambda i,y,x:T.grad(y[i],x),sequences=T.arange(y.shape[0]),non_sequences=[y,x])f1=function([x],J,updates=updates)print(&quot;f1=&quot;,f1([5, 5]))#实例03：Theano库实现海森矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as Tx=T.dvector(&#x27;x&#x27;)# 计算hessian矩阵y=x**3+x**4cost=y.sum()gy=T.grad(cost,x) #求梯度# 调用scan构建循环GraphH,updates=theano.scan(lambda i,gy,x:T.grad(gy[i],x),sequences=T.arange(gy.shape[0]),non_sequences=[gy,x])f2=function([x],H,updates=updates)print(&quot;f2=&quot;,f2([5, 5]))\n4 积分\n4.1 不定积分\n一些懒得敲公式的知识概念：原函数（定义、存在定理、原函数族 \\(F(x)+C\\)）\n4.2 求不定积分的方法\n一些懒得敲公式的知识概念：积分基本公式、换元法、分部积分法\n4.3 定积分\n一些懒得敲公式的知识概念：定积分定义、性质（和差、与常数乘积、单调性、极值）、积分中值定理\n","categories":["机器学习数学基础"]},{"title":"机器学习数学基础：线性代数","url":"/2022/01/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","content":"本章介绍线性代数中向量、内积、范数、矩阵、线性变换、二次型、矩阵分解等基本知识。\n1 行列式\n线性代数中，行列式是一个函数，和矩阵有一定的关系。几何上，行列式可以看作有向面积或体积的概念在一般的欧几里得空间中的推广。\n1.1 二阶与三阶行列式\n可用来解决线性方程求解的问题，同时注意对角线法则只适用于二阶和三阶的行列式。\n表达式 \\[\nD=a_{11}a_{22}-a_{12}a_{21}=\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12}\\\\\n   a_{21} &amp; a_{22} \n  \\end{matrix}\n  \\right]\n\\] 称为数表的二阶行列式，记作 \\(D=det(a_{ij})\\) .\n三阶行列式定义为 \\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}\n\\]\n1.2 全排列和对换\n全排列的定义：由 \\(1\\) 到 \\(n\\) 个数组成的一个有序数组称为一个n级全排列，通常用 $ P_n$ 表示。 \\[\nP_n=n\\times (n-1)\\times \\dots\\times3\\times2\\times1=n!\n\\] 逆序数的定义：在一个排列中，如果两个数（称为数对）的前后位置与大小顺序相反，即前面的数大于后面的数，那么称它们构成一个逆序（反序）。一个排列中所有逆序的总数称为此排列的逆序数。分别计算出排在 \\(1,2,\\dots,n-1,n\\) 前面比它大的数码之和。 \\[\nt=t_1+t_2+\\dots+t_n=\\sum_{i=1}^nt_i\n\\] 此外，还有奇排列和偶排列的概念，即奇排列为逆序数为奇数的排列。\n对换的定义：在排列中，将任意两个元素对调，其余元素不动，就得到另一个排列，这样的一个变换叫作对换。将相邻的两个元素对换，叫作相邻对换。其中，一个排列中任意两个元素对换，排列改变奇偶性。\n1.3 n阶行列式\n\\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=\\sum(-1)^ta_{11}a_{22}a_{33}\n\\]\n可推广至n阶，其中 \\(t\\) 为列标排列的逆序数。\n1.4 几种特殊行列式的值\n上、下三角行列式，对角行列式，特殊行列式（类似反的下三角行列式）\n如果是计算的是主对角线的值，则直接连乘；如果是副对角线，则需加一个系数 \\((-1)^{\\frac{n(n-1)}{2}}\\).\n一些其他的见知乎：https://zhuanlan.zhihu.com/p/34685081。\n1.5 n阶行列式的性质\n\n性质1：行列式与它的转置行列式相等。\n性质2：互换行列式的两列，行列式变号。（推论：两行或两列相同，此行列式等于零）。\n性质3：行列式的某一行（列）中所有元素都乘同一数 \\(k\\)，等于用数 \\(k\\) 乘此行列式。\n性质4：行列式中如果有两行（列）元素成比例，则此行列式等于零。\n性质5：若行列式的某一列（行）的元素都是两数 之和，则该行列式等于两个行列式之和。\n性质6：把行列式的某一列（行）的各个元素乘同一个数，然后加到另一列（行）对应的元素上去，行列式的值不变。\n\n2 用向量描述空间\n2.1 向量及其运算\n\\(n\\) 维空间用 \\(\\pmb{R}^n\\) 表示，上标 \\(n\\) 表示空间的维度。\n2.2 向量组的线性组合\n若干个同纬度的列向量（或同纬度的行向量）所组成的集合叫作向量组。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和一组实数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，那么表达式 \\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)称为向量组 $ $ 的一个线性组合。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和向量 \\(\\pmb{b}\\)，如果存在一组数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得 \\(\\pmb{b}=\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)，则向量 \\(\\pmb{b}\\) 是向量组 \\(\\pmb{A}\\) 的线性组合，这时称向量 \\(\\pmb{b}\\) 能由向量组 \\(\\pmb{A}\\) 线性表示，也就是对应的方程组有解。\n2.3 向量组的线性相关性\n向量组的线性相关性的定义：给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) ，如果存在不全为0的数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得\\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m=0\\)，则称向量组 \\(\\pmb{A}\\) 是线性相关的。\n线性相关的充要条件是：向量组中至少有一个向量可以由其他所有向量线性表示。\n3 内积、正交向量组和范数\n3.1 内积\n向量之间的乘法可分为内积和外积，一般用内积比较多。内积的直接描述为某一向量在另一个向量方向上的投影长度。\n内积的定义：设有 \\(n\\) 维向量 \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，\\(\\pmb{y}=\\left(\\begin{matrix}  y_1 \\\\  y_2\\\\ \\vdots \\\\ y_n  \\end{matrix}\\right)\\)，令\\(（\\pmb{x},\\pmb{y}）=x_1y_1+x_2y_2+\\dots+x_ny_n\\)，\\(（\\pmb{x},\\pmb{y}）\\)称为向量 \\(\\pmb{x}\\) 和向量 \\(\\pmb{y}\\) 的内积，也可以表示为 \\(\\pmb{x·}\\pmb{y}\\).\n3.2 正交向量组和施密特正交化\n正交向量的定义：如果两向量的内积为零，则称它们正交。\n正交向量组的定义：如果向量组中任意两个向量都正交且不含零向量，则称为正交向量组，并且正交向量组是线性无关的。\n标准正交向量：向量组内向量彼此之间的点积为 \\(0\\)，与自身的点积为 \\(1\\)。\n施密特正交化详见：\n如何理解施密特（Schmidt）正交化：https://zhuanlan.zhihu.com/p/136627868。\n3.3 范数\n向量范数的定义：如果向量 \\(\\pmb{a} \\in \\pmb{R}^n\\) 的某个实值函数 $f()=|||| $ 满足\n\n非负性：\\(||\\pmb{a}||\\geq 0\\) ，且\\(||\\pmb{a}||=0\\) 当且仅当 \\(\\pmb{a}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{a}||=|\\lambda|||\\pmb{a}||\\)\n三角不等式：对于任意 \\(\\pmb{a,b}\\in\\pmb{R}^n\\)，都有 \\(||\\pmb{a+b}||\\leq||\\pmb{a}||+||\\pmb{b}||\\)\n\n常用的向量范数有 $ 1$ -范数、\\(2\\) -范数和 \\(\\infty\\) -范数。\n\n$ 1$ -范数：也称为曼哈顿距离 \\[\n  ||\\pmb{a}||_1=\\sum_i^n|\\pmb{a}_i|\n  \\]\n\\(2\\) -范数：也称为欧几里得范数\n\n\\[\n||\\pmb{a}||_2=\\sqrt{\\sum_{i=1}^n\\pmb{a}_i^2}\n\\]\n\n\\(\\infty\\) -范数：所有向量元素中的最大值 \\[\n  ||\\pmb{a}||_\\infty=\\max_i|a_i|\n  \\]\n\n矩阵范数的定义：如果矩阵 \\(\\pmb{A} \\in \\pmb{R}^{n\\times n}\\) ，若按某一确定的法则对应于一个非负实数 $|||| $ 满足\n\n非负性：\\(||\\pmb{A}||\\geq 0\\) ，且\\(||\\pmb{A}||=0\\) 当且仅当 \\(\\pmb{A}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{A}||=|\\lambda|||\\pmb{A}||\\)\n三角不等式：对于任意 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{A+B}||\\leq||\\pmb{A}||+||\\pmb{B}||\\)\n相容性：对于任意的 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{AB}||\\leq||\\pmb{A}||||\\pmb{B}||\\)\n\n常用的矩阵范数有 $ 1$ -范数、\\(2\\) -范数、 \\(\\infty\\) -范数和 \\(F\\) -范数。\n\n$ 1$ -范数：又称为列和范数。顾名思义，即矩阵列向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_1=\\max_j\\sum_i^m|a_{ij}|\n  \\]\n\\(2\\) -范数：又称为谱范数，计算方法为 \\(\\pmb{A^TA}\\) 矩阵的最大特征值开平方。\n\n\\[\n||\\pmb{A}||_2=\\sqrt{\\lambda_1}\n\\]\n\n\\(\\infty\\) -范数：又称为行和范数。顾名思义，即矩阵行向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_\\infty=\\max_i\\sum_j^n|a_{ij}|\n  \\]\n\\(F\\) -范数：又称为Frobenius范数，计算方法为矩阵元素的绝对值的平方和再开方。 \\[\n||\\pmb{A}||_F=\\sqrt{\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|}\n\\]\n\n习题：Python编程实现求向量范数和矩阵范数。\n# -*- coding: UTF-8 -*-import numpy as npa=np.array([2,4,5,8,-3])print(&#x27;向量a：&#x27;,a)print (&#x27;向量a的1-范数:&#x27;)print(np.linalg.norm(a,ord=1))print (&#x27;向量a的2-范数:&#x27;)print(np.linalg.norm(a,ord=2))print (&#x27;向量a的∞-范数:&#x27;)print(np.linalg.norm(a,ord=np.inf))# -*- coding: UTF-8 -*-import numpy as npA=np.arange(3,15).reshape(3,4)print(&#x27;矩阵A：&#x27;,A)print(&#x27;矩阵A的1-范数:&#x27;)print(np.linalg.norm(A,ord=1))print(&#x27;矩阵A的2-范数:&#x27;)print(np.linalg.norm(A,ord=2))print(&#x27;矩阵的∞-范数:&#x27;)print(np.linalg.norm(A,ord=np.inf))print(&#x27;矩阵A的F-范数:&#x27;)print(np.linalg.norm(A,ord=&#x27;fro&#x27;))print(&#x27;矩阵A列向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=0))print(&#x27;矩阵A行向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=1))\n4 矩阵和线性变换\n4.1 矩阵及其运算\n一些不想敲的概念：\n\n矩阵的定义。\n特殊的矩阵：行矩阵（也叫行向量）、列矩阵（也叫列向量）、方阵（\\(\\pmb{A}_n\\)），三角矩阵、单位矩阵、对称矩阵、对角矩阵、实对称矩阵、零矩阵、正交矩阵。\n矩阵的运算：加法、数乘、乘法、转置、行列式（\\(|\\pmb{A}|\\) 或 \\(det(\\pmb{A})\\)).\n\n4.2 逆矩阵\n对于 \\(n\\) 阶矩阵 \\(\\pmb{A}\\) ，如果有一个 \\(n\\) 阶矩阵 \\(\\pmb{B}\\) ，使得 \\(\\pmb{AB=BA=E}\\)，则称矩阵 \\(\\pmb{A}\\) 是可逆的，并把矩阵 \\(\\pmb{B}\\) 称为 \\(\\pmb{A}\\) 的逆矩阵，记作 \\(\\pmb{A}^{-1}\\) .\n\n若矩阵 \\(\\pmb{A}\\) 可逆，则 \\(|\\pmb{A}| \\neq 0\\) .\n若 \\(|\\pmb{A}| \\neq 0\\)，则矩阵 \\(\\pmb{A}\\) 可逆，且 \\(\\pmb{A}^{-1}=\\frac{1}{|\\pmb{A}|}\\pmb{A}^*\\)，其中 \\(\\pmb{A}^*\\) 为矩阵 \\(\\pmb{A}\\) 的伴随矩阵。\n\n4.3 矩阵的初等变换\n\n对调两行\n数乘\n数乘再相加\n\n4.4 标量对向量的导数、最小二乘法\n\nxxds\n\n详见：\n系列：机器学习中的矩阵向量求导\n单列一个：机器学习中的矩阵向量求导(二) 矩阵向量求导之定义法\n最小二乘法及python代码：最小二乘法（least sqaure method）\n4.5 线性变换\n线性变换的定义：设 \\(\\pmb{V}\\) 为一个线性空间，映射 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个变换，若 \\(f\\) 保持 \\(\\pmb{V}\\) 的加法与数乘运算，则称 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个线性变换。\n线性变换把一个向量空间里的向量映射到了另一个向量空间里的另一个向量，因此，我们可以把线性变换理解成输入一个向量，然后输出一个向量的特殊函数。\n它可以看成一个动态的过程，比如旋转、伸缩或者投影之类的升降维的操作。\n常见的线性变换还有：恒等变换（单位变换）、求微商（线性空间 \\(P[x]\\) 内）、求定积分。\n详见：线性变换（一）【直观理解线性变换】\n4.6 矩阵的秩\n一些概念：矩阵的秩、行秩、列秩和极大无关向量组。\n定理：设 \\(n\\) 元线性方程组 \\(\\pmb{Ax=b}\\) ，\\(R(\\pmb{A})\\) 表示系数矩阵 \\(\\pmb{A}\\) 的秩，\\(R(\\pmb{A,b})\\) 表示增广矩阵 \\(\\pmb{B=(A,b)}\\) 的秩，则该线性方程组\n\n无解的充要条件是 : \\(R(\\pmb{A})&lt;R(\\pmb{A,b})\\)；\n有唯一解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})=n\\)；\n有无限多解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})&lt;n\\) .\n\n一些概念：线性方程组的解、方阵的特征值和特征向量\n习题：Python编程实现求逆矩阵、行列式的值、秩\nimport numpy as np# a=np.array([[1,4,7],[2,5,8],[3,6,9]])# a=np.array([[1,2,3],[4,5,6]])A=np.array([[1,4,9],[2,5,8],[3,6,9]])print(&quot;A矩阵为：&quot;)print(A)print(&#x27;*&#x27;*40)F = np.linalg.inv(A)print(&quot;A矩阵的逆矩阵为：&quot;)print(F)print(&#x27;*&#x27;*40)print(&quot;A矩阵与其逆矩阵乘积为：&quot;)print(np.dot(A,np.linalg.inv(A)))print(np.dot(A,np.linalg.inv(A)).astype(int))print(&#x27;*&#x27;*40)print(&quot;A矩阵的行列式的值为：&quot;)print(np.linalg.det(A))print(&#x27;*&#x27;*40)print(&quot;A矩阵的秩为：&quot;)print(np.linalg.matrix_rank(A))\n5 二次型\n5.1 二次型的定义\n即二次齐次函数（\\(x^2,x_1x_2,\\dots\\)，类似平方项展开加上系数）。二次型的标准型可理解为只含平方项的二次型。\n若 \\(\\pmb{A}\\) 为对称矩阵， \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，则 \\(f=\\pmb{x^TAx}\\) 也是二次型的一种形式，对成矩阵 \\(\\pmb{A}\\) 叫作二次型 \\(f\\) 的矩阵，也把 \\(f\\) 叫作对称矩阵 \\(\\pmb{A}\\) 的二次型。对称矩阵 \\(\\pmb{A}\\) 的秩就叫做二次型 \\(f\\) 的秩。\n5.2 用正交变换化二次型为标准型\n\n将二次型 \\(f=\\sum_\\limits{i=1}^n\\sum_\\limits{j=1}^na_{ij}x_ix_j\\)，写成矩阵形式 \\(f=\\pmb{x^TAx}\\) .\n由 \\(|\\pmb{A-\\lambda E}|=0\\)，求出 \\(\\pmb{A}\\) 的全部特征值。\n由 \\((\\pmb{A-\\lambda E})\\pmb{x}=0\\)，求出 \\(\\pmb{A}\\) 的特征向量。\n\n对于求出的不同特征值所对应的特征向量已正交，只需要单位化；对于 \\(k\\) 冲特征值 \\(\\lambda\\) 所对应的 \\(k\\) 个线性无关的特征向量，用施密特正交化方法把它们化成 \\(k\\) 个两两正交的单位向量。\n\n把求出的n个两两正交的单位向量拼成正交矩阵 \\(\\pmb{P}\\)，作正交变换 \\(\\pmb{x=Py}\\).\n用 \\(\\pmb{x=Py}\\) ，把 \\(f\\) 化成标准型 \\(f=\\lambda_1y_1^2+\\lambda_2y_2^2+\\dots+\\lambda_ny_n^2\\)，其中 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_n\\)是矩阵 \\(\\pmb{A}=(a_{ij})\\) 的特征值。\n\n5.3 二次型的正定型\n正定二次型、惯性定理、和赫尔维茨定理（后两个是判定定理）。\n麻省理工线性代数笔记（二十四）-正定矩阵\n6 矩阵分解\n矩阵分解有很多种，如 \\(LU\\) 分解、\\(QR\\) 分解、特征值分解（\\(EVD\\) ）和奇异值分解（\\(SVD\\) ）。\\(LU\\) 分解是将满秩矩阵分解为两个倒扣的三角形，即分解成下三角矩阵和上三角矩阵的乘积，它的意义在于求解大型方程组。QR分解经常用来解线性最小二乘法问题，它和机器学习的相关算法密切。特征值分解的方法也非常有效，但有一些局限性，即要求矩阵必须是方阵且能够被对角化。奇异值分解可以对任意形状的矩阵进行分解，实用性更广。\n麻省理工线性代数笔记（二十六）-奇异值分解\n习题：实现矩阵的QR分解\nimport numpy as npM= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)Q=np.zeros((4, 3))j = 0for a in M.T:    b = np.copy(a)    for i in range(0, j):        b = b - np.dot(np.dot(Q[:, i].T, a), Q[:, i])    e = b / np.linalg.norm(b)    Q[:, j] = e    j += 1R = np.dot(Q.T, M)np.set_printoptions(precision=3,suppress=True)print(&#x27;Gram-schmidt正交化变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))#方法二import numpy as npnp.set_printoptions(precision=4, suppress=True)M= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)s = 4t = 3Q = np.identity(s)R = np.copy(M)for j in range(s - 1):    x = R[j:, j]    E = np.zeros((4, 3))    E = np.zeros_like(x)    b = x - E    d = b / np.linalg.norm(b)    Q_j = np.identity(s)    Q_j[j:, j:] -= 2.0 * np.outer(d, d)    R = np.dot(Q_j, R)    Q = np.dot(Q, Q_j)np.set_printoptions(precision=3,suppress=True)print(&#x27;Householder变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))\nQ：奇异值分解的应用场景有哪些?\n\\(SVD\\) 的应用有很多，可以说，\\(SVD\\) 是矩阵分解、降维、压缩、特征学习的一个基础工具，所以 \\(SVD\\) 在机器学习领域相当的重要。\n\\(SVD\\) 在降维中作用如何呢？通过 \\(SVD\\) 的公式可以看出，原来矩阵 $ $ 的特征有 \\(n\\) 维，经过 \\(SVD\\) 后，可以用前 \\(r\\) 个非零奇异值对应的奇异向量表示矩阵\\(\\pmb{A}\\) 的主要特征，这样就把矩阵 $ $ 进行了降维。\n\\(SVD\\) 在压缩中作用如何呢？机器学习最基本和最有趣的特征之一是数据压缩概念的相关性。如果我们能提取有用的数据，我们就能用更少的比特位来表达数据。从信息论的观点来看，数据之间存在相关性，则有可压缩性。通过 \\(SVD\\) 的公式可以看出，矩阵 $ $ 经过 \\(SVD\\) 后，要表示原来的大矩阵 $ $ ，我们只需要存储 \\(\\pmb{U,\\Delta,V}\\) 三个较小的矩阵即可。而这 \\(3\\) 个较小规模的矩阵占用内存上也是远远小于原有矩阵 $ $ 的，这样 \\(SVD\\) 就起到了压缩的作用。\n\\(SVD\\) 和主成分分析有什么关系呢？\\(PCA\\) 即主成分分析方法，是一种使用最广泛的数据降维算法。\\(PCA\\) 的主要思想是将n维特征映射到 $ m$ 维上，这 \\(m\\) 维是全新的正交特征，也被称为主成分，是在原有 \\(n\\) 维特征的基础上重新构造出来的 \\(m\\) 维特征。\\(PCA\\) 的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。\\(PCA\\) 算法有两种实现方法，即基于特征值分解协方差矩阵实现 \\(PCA\\) 算法和基于 \\(SVD\\) 协方差矩阵实现 \\(PCA\\) 算法。所以，\\(SVD\\) 是 \\(PCA\\) 算法的一种实现方法。\n我们再来看一下潜在语义索引，它是一种简单实用的主题模型。潜在语义索引是一种利用 \\(SVD\\) 方法获得在文本中术语和概念之间关系的索引和获取方法。该方法的主要依据是在相同文章中的词语一般有类似的含义，可以从一篇文章中提取术语关系，从而建立起主要概念内容。潜在语义索引不同于 \\(PCA\\) ，至少不是实现了 \\(SVD\\) 就可以直接用的，但它也是一个高度依赖 \\(SVD\\) 的算法。\n","categories":["机器学习数学基础"]}]