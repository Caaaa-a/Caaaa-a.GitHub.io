[{"title":"01简介至06矩阵运算","url":"/2022/01/23/01-06/","content":"\n\n\n筛选的Q&amp;A\n1、copy和clone的区别\ncopy分深拷贝和浅拷贝，不一定会复制内存；clone一定会复制内存。\n2、torch不区分行向量与列向量吗\n行向量 \\([1, 2, 3]\\) ， 列向量 $ [[1], [2], [3]]$，行向量的shape是 \\([n]\\)，列向量的shape是 \\([n,1]\\) .\n如果一个问题能够得到最优解，那么它就是p问题，机器学习不关心p问题，只关心np的问题。\n","categories":["动手学深度学习v2"]},{"title":"pyschools while 9-13","url":"/2022/01/24/pyschools%E4%B8%ADwhile-9-13/","content":"09 Square Root Approximation\nlink：http://www.pyschools.com/quiz/view_question/s5-q9\nCreate a function that takes in a positive number and return 2 integers such that the number is between the squares of the 2 integers. It returns the same integer twice if the number is a square of an integer.\nExamples\n&gt;&gt;&gt; sqApprox(2)(1, 2)&gt;&gt;&gt; sqApprox(4)(2, 2)&gt;&gt;&gt; sqApprox(5.1)(2, 3)\nAnswer 1\nimport mathdef sqApprox(num):    return (math.floor(num**0.5),math.ceil(num**0.5))\nAnswer 2\ndef sqApprox(num):    i = 0    minsq = 0             # set lower bound    maxsq = int(num) + 1  # set upper bound    while i &lt; maxsq:        if i * i &lt;= num and i &gt;= minsq:  # complete inequality condition            minsq = i        if i * i &gt;= num and i &lt;= maxsq:  # complete inequality condition            maxsq = i        i += 1                           # update i so that &#x27;while&#x27; will terminate    return (minsq, maxsq)\n10 Pi Approximation\nlink:http://www.pyschools.com/quiz/view_question/s5-q10\nCreate a function that computes the approximation of pi, based on the number of iterations specified.\npi can be computed by 4*(1-1/3+1/5-1/7+1/9- ...).\nExamples\n&gt;&gt;&gt; piApprox(1)4.0&gt;&gt;&gt; piApprox(10)3.04183961893&gt;&gt;&gt; piApprox(300)3.13825932952\nAnswer\ndef piApprox(num):    i = 1    pi = 0    while i &lt;= num:        pi += 4 * (-1) ** (i + 1) * (1.0 / (2 * i - 1))        i += 1    return pi\n11 Estimate Pi\nlink:http://www.pyschools.com/quiz/view_question/s5-q11\nWrite a function estimatePi() to estimate and return the value of pi based on the formula found by an Indian Mathematician Srinivasa Ramanujan. It should use a while loop to compute the terms of the summation until the last item is smaller than 1e -15. The formula for calculating distance is given below:\n\n\n\nExamples\n&gt;&gt;&gt; estimatePi()3.14159265359\nAnswer\ndef estimatePi():    import math    def factorial(n):        if n == 0:            return 1        else:            return n * factorial(n - 1)    item = 1103    k = 0    pi = 0    while item &gt; 1e-15:        item = (            (factorial(4 * k) * (1103.0 + 26390 * k))            / factorial(k) ** 4            / 396 ** (4 * k))        pi += 2 * 2 ** (0.5) / 9801 * item        k += 1    return 1 / pi\n12 Prime Factorization\nlink:http://www.pyschools.com/quiz/view_question/s5-q12\nGiven a positive integer, write a function that computes the prime factors that can be multplied together to get back the same integer.\nExamples\n&gt;&gt;&gt; primeFactorization(60)[2, 2, 3, 5]&gt;&gt;&gt; primeFactorization(1050)[2, 3, 5, 5, 7]&gt;&gt;&gt; primeFactorization(1)[]\nAnswer 1\ndef primeFactorization4(num):    def prime(num):        if num &lt; 2:            return 0        for i in range(2, int(num ** 0.5) + 1):            if num % i == 0:                return 0        else:            return 1    ls = []    start = 2    while prime(num) == 0 and num &gt; 1:        for i in range(start, int(num ** 0.5) + 1):          #if num % i == 0 and prime(i):            if num % i == 0:                ls.append(i)                num = num // i                start = i                break    if prime(num):        ls.append(num)    return ls\nAnswer 2 **\ndef primeFactorization(num):    possible = [2] + list(range(3, int(num ** 0.5) + 1, 2))    for p in possible:        if num % p == 0:            return [p] + primeFactorization(num / p)    if num &lt; 2:        return []    return [num]\nAnswer 3\ndef primeFactorization(num):     factor=[]    while num&gt;1:        for i in range(2,num+1):            if num%i==0:                factor.append(i)                num = num//i                break    return factor\nTime complexity comparison\nimport timedef primeFactorization1(num):    def prime(num):        if num &lt; 2:            return 0        for i in range(2, int(num ** 0.5) + 1):            if num % i == 0:                return 0        else:            return 1    ls = []    start = 2    while prime(num) == 0 and num &gt; 1:        for i in range(start, int(num ** 0.5) + 1):            if num % i == 0 and prime(i):                ls.append(i)                num = num // i                start = i                break    if prime(num):        ls.append(num)    return lsdef primeFactorization2(num):    possible = [2] + list(range(3, int(num ** 0.5) + 1, 2))    for p in possible:        if num % p == 0:            return [p] + primeFactorization2(num / p)    if num &lt; 2:        return []    return [num]for c in [100, 1e6, 1e10, 1e14]:    print(c)    t0 = time.time()    primeFactorization1(c)    t1 = time.time()    print(&#x27;%.10f&#x27; % (t1 - t0))    primeFactorization2(c)    t2 = time.time()    print(&#x27;%.10f&#x27; % (t2 - t1))# 100# 0.0000226498# 0.0000531673# 1e6# 0.0000638962# 0.0000970364# 1e10# 0.0000720024# 0.0017700195# 1e14# 0.0000679493# 0.2322161198\n\nleetcode:[剑指 Offer 49. 丑数]\nleetcode:[263. Ugly Number]\nleetcode:[264. Ugly Number II]\nleetcode:[1201. Ugly Number III]\nleetcode:[507. Perfect Number]\nleetcode:[1390. Four Divisors]\n\n13 Lowest Common Multiple\nlink:http://www.pyschools.com/quiz/view_question/s5-q13\nThe smallest common multiple of two or more numbers is called the lowest common multiple (LCM). Given a list of integers, find the lowest common multiple.\nExamples\n&gt;&gt;&gt; LCM([2, 3, 4])12&gt;&gt;&gt; LCM([3, 6, 9])18&gt;&gt;&gt; LCM([3, 3])3\nAnswer 1\ndef LCM(nums):     def lcm(a, b):        c = a        while True:            if c % a == 0 and c % b == 0:                return c                break            c += 1    l=lcm(nums[0],nums[1])    for i in nums[2:]:        l=lcm(l,i)    return l\nAnswer 2\nfrom math import gcd # Python versions 3.5 and above#from fractions import gcd # Python versions below 3.5from functools import reduce # Python version 3.xdef LCM(denominators):    return reduce(lambda a,b: a*b // gcd(a,b), denominators)\n\nfunctools.``reduce(function, iterable[, initializer])\n\nApply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the iterable. If the optional initializer is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If initializer is not given and iterable contains only one item, the first item is returned.Roughly equivalent to:\ndef reduce(function, iterable, initializer=None):    it = iter(iterable)    if initializer is None:        value = next(it)    else:        value = initializer    for element in it:        value = function(value, element)    return value\nSee itertools.accumulate() for an iterator that yields all intermediate values.\n\nAs of Python 3.9 lcm() function has been added in the math library. It can be called with the following signature:\n\nmath.lcm(*integers)\n\nReturn the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\n\nAnswer 3\ndef LCM(nums):  def gcd(n, m):      if m == 0:          return n      return gcd(m, n % m)  lcm = 1  for i in nums:      lcm = lcm * i // gcd(lcm, i)  return lcm\nAnswer 4\nimport numpy as npnp.lcm.reduce([40, 12, 20])\n","categories":["题解"]},{"title":"八大常见类型的行列式及其解法","url":"/2022/01/09/%E5%85%AB%E5%A4%A7%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%B3%95/","content":"来源：https://zhuanlan.zhihu.com/p/34685081\n\n本文记录了八大常见类型的行列式及其解法，解法从一般性到特殊性都有，分享给大家，例子都特别经典好用，希望对线代、高代初学者以及考研党有用。\n\n类型总览：\n\n箭型行列式\n两三角型行列式\n两条线型行列式\n范德蒙德型行列式\n\\(Hessenberg\\)型行列式\n三对角型行列式\n各行元素和相等型行列式\n相邻两行对应元素相差K倍型行列式\n\n方法总览：\n\n拆行法\n升阶法\n方程组法\n累加消点法\n累加法\n递推法（特征方程法）\n步步差法\n\n一：箭型行列式\n最常见最常用的行列式，特征很好辨识，必须掌握，请看下例：\n\\[\neg:D_n= \\left|\\begin{array}{cccc} x_1&amp;1&amp;1 &amp;... &amp;1\\\\ 1&amp;x_2&amp;&amp;&amp;\\\\ 1&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 1&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|(空白处都为0)\n\\]\n\\(Solution\\): 将第一列元素依次减去第$ i$ 列的\\(\\frac{1}{x_i}\\) ,$i=2...n $\n得：\n\\[\nD_n= \\left|\\begin{array}{cccc} x_1-\\frac{1}{x_2}-...-\\frac{1}{x_n}&amp;1&amp;1 &amp;... &amp;1\\\\ 0&amp;x_2&amp;&amp;&amp;\\\\ 0&amp;&amp;x_3\\\\ ...&amp;&amp;&amp;...\\\\ 0&amp;&amp;&amp;...&amp;x_n \\end{array}\\right|\n\\]\n所以：\n\\[\nD_n=\\prod_{i=2}^{n}x_i(x_1-\\sum_{i=2}^{n}\\frac{1}{x_i})\n\\]\n二：两三角型行列式\n\n特征为对角线上方元素均为\\(a\\) ,下方元素均为\\(b\\)\n\n\n当 \\(a=b\\) 时可化为箭型行列式计算，当 \\(a\\not=b\\) 时采用拆行法计算，请看下面两例\n\n\\[\neg1(a=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b&amp;x_2&amp;b&amp;...&amp;b\\\\ b&amp;b&amp;x_3&amp;...&amp;b\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i，i=2...n\\) 行都减去第一行\n得： \\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;b&amp;b &amp;... &amp;b\\\\ b-x_1&amp;x_2-b&amp;0&amp;...&amp;0\\\\ b-x_1&amp;0&amp;x_3-b&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b-x_1&amp;0&amp;0&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n即化成了箭型行列式，所以：\n\\[\nD_n=[\\prod_{i=2}^{n}(x_i-b)]\\times[x_1-b(b-x_1)\\sum_{i=2}^{n}\\frac{1}{x_i-b}] \n\\]\n\n\\[\neg2(a\\not=b):D_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 采用拆行法，目的是为了降阶\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a+0\\\\ b&amp;x_2&amp;a&amp;...&amp;a+0\\\\ b&amp;b&amp;x_3&amp;...&amp;a+0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n+b-b \\end{array}\\right| \n\\]\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;a\\\\ b&amp;x_2&amp;a&amp;...&amp;a\\\\ b&amp;b&amp;x_3&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;b \\end{array}\\right|_{(*)}+\\left|\\begin{array}{cccc} x_1&amp;a&amp;a &amp;... &amp;0\\\\ b&amp;x_2&amp;a&amp;...&amp;0\\\\ b&amp;b&amp;x_3&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ b&amp;b&amp;b&amp;...&amp;x_n-b \\end{array}\\right| \n\\]\n将第 \\(i,i=1...n-1\\) 列都减去最后一列，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} x_1-a&amp;0&amp;0 &amp;... &amp;a\\\\ b-a&amp;x_2-a&amp;0&amp;...&amp;a\\\\ b-a&amp;b-a&amp;x_3-a&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;b \\end{array}\\right|+(x_n-b)D_{n-1} \n\\]\n所以： \\[\nD_n=b\\prod_{i=1}^{n-1}(x_i-a)+(x_n-b)D_{n-1}\n\\]\n再由行列式转置不变性得到：\n\\[\nD_n=a\\prod_{i=1}^{n-1}(x_i-b)+(x_n-a)D_{n-1}\n\\]\n联立\\((11)(12)\\) ,得通式：\n\\[\nD_n=\\frac{1}{a-b}[a\\prod_{i=1}^{n}(x_i-b)-b\\prod_{j=1}^{n}(x_j-a)]\n\\]\n\n通过适当变换可以化为两三角型行列式的，描述不如大家自己看例子揣摩，也很容易理解的，请看下例\n\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} d&amp;b&amp;b &amp;... &amp;b\\\\ c&amp;x&amp;a&amp;...&amp;a\\\\ c&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ c&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n\\(Solution\\): 将第一行乘上 \\(\\frac{a}{b}\\) ，第一列乘上 \\(\\frac{a}{c}\\)，得：\n\\[\nD_n=\\frac{bc}{a^2}\\left|\\begin{array}{cccc} \\frac{a^2d}{bc}&amp;a&amp;a &amp;... &amp;a\\\\ a&amp;x&amp;a&amp;...&amp;a\\\\ a&amp;a&amp;x&amp;...&amp;a\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a&amp;a&amp;a&amp;...&amp;x \\end{array}\\right|\n\\]\n即化成了两三角型行列式\n\n一些每行上有公因子但是无法向上式那样在保持行列式不变得基础上能提出公因子的，采用升阶法，请看下例\n\n\\[\neg4:D_n=\\left|\\begin{array}{cccc} 1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n\\(Solution\\): 加边升阶，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ 0&amp;1+x_{1}^2&amp;x_1x_2&amp;x_1x_3 &amp;... &amp;x_1x_n\\\\ 0&amp;x_2x_1&amp;1+x_{2}^2&amp;x_2x_3&amp;...&amp;x_2x_n\\\\ 0&amp;x_3x_1&amp;x_3x_2&amp;1+x_{3}^2&amp;...&amp;x_3x_n\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;x_nx_1&amp;x_nx_2&amp;x_nx_3&amp;...&amp;1+x_{n}^2 \\end{array}\\right| \n\\]\n再将第 \\(i,i=2...n+1\\) 都减去第一行的\\(x_i，i=1...n\\) 倍，得：\n\\[\nD_n=\\left|\\begin{array}{cccc} 1&amp;x_1&amp;x_2&amp;x_3&amp;...&amp;x_n\\\\ -x_1&amp;1&amp;0&amp;0 &amp;... &amp;0\\\\ -x_2&amp;0&amp;1&amp;0&amp;...&amp;0\\\\ -x_3&amp;0&amp;0&amp;1&amp;...&amp;0\\\\ 0&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -x_n&amp;0&amp;0&amp;0&amp;...&amp;1 \\end{array}\\right| \n\\]\n即又化成了箭型行列式，可得通式：\n\\[\nD_n=1+\\sum_{i=1}^{n}x_{i}^{2} \n\\]\n三：两条线型行列式\n特征是除了主(次)对角线或与其相邻得一条斜线所组成的任意一条线加四个顶点中的某个顶点外，其他元素均为\\(0\\)，这类行列式可以直接展开降阶。这段描述有点繁琐，但其实也并不复杂，请看下例理解\n\\[\neg3:D_n=\\left|\\begin{array}{cccc} a_1&amp;b_1&amp; &amp;... &amp;\\\\ &amp;a_2&amp;b_2&amp;...&amp;\\\\ &amp;&amp;a_3&amp;...&amp;\\\\ &amp;&amp;&amp;\\\\ &amp;&amp;...&amp;a_{n-1}&amp;b_{n-1} \\\\ b_n&amp;&amp;...&amp;&amp;a_n \\end{array}\\right| (空白处都为0)\n\\]\n\\(Solution\\): 按照第一列两个非\\(0\\)元素拉普拉斯展开即可\n\\[\nD_n=\\prod_{i=1}^{n}a_i+(-1)^{n+1}\\prod_{i=1}^{n}b_i \n\\]\n四：范德蒙德型行列式\n范德蒙德行列式大家应该熟悉，而范德蒙德型行列式的特征就是有逐行(列)元素按幂递增(减)，可以将其转化为范德蒙德行列式来计算，请看下例\n\\[\neg:D_n=\\left|\\begin{array}{cccc} a_{1}^n&amp; a_{1}^{n-1}b_1&amp;... &amp;a_1b_1^{n-1}&amp;b_1^n\\\\ a_{2}^n&amp;a_{2}^{n-1}b_2&amp;...&amp;a_2b_2^{n-1}&amp;b_2^n\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{n}^n&amp;a_{n}^{n-1}b_n&amp;...&amp;a_nb_n^{n-1}&amp;b_n^n\\\\ a_{n+1}^n&amp;a_{n+1}^{n-1}b_{n+1}&amp;...&amp;a_{n+1}b_{n+1}^{n-1}&amp;b_{n+1}^n \\end{array}\\right| \n\\]\n\\(Solution\\): 将每行都提出 \\(a_i^{n}\\),$i=1...n+1 $倍，得：\n\\[\nD_n=\\prod_{i=1}^{n+1}a_i^n\\left|\\begin{array}{cccc} 1&amp; \\frac{b_1}{a_1}&amp;... &amp;(\\frac{b_1}{a_1})^{n-1}&amp;(\\frac{b_1}{a_1})^{n}\\\\ 1&amp;\\frac{b_2}{a_2}&amp;...&amp;(\\frac{b_2}{a_2})^{n-1}&amp;(\\frac{b_2}{a_2})^{n}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ 1&amp;\\frac{b_n}{a_n}&amp;...&amp;(\\frac{b_n}{a_n})^{n-1}&amp;(\\frac{b_n}{a_n})^{n}\\\\ 1&amp;\\frac{b_{n+1}}{a_{n+1}}&amp;...&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n-1}&amp;(\\frac{b_{n+1}}{a_{n+1}})^{n} \\end{array}\\right| \n\\]\n上式即为范德蒙德行列式，所以通式为：\n\\[\nD_n=\\prod_{1\\le i&lt;j\\le n+1}(a_ib_j-b_ia_j)\n\\]\n五：\\(Hessenberg\\)型行列式\n特征为除了主(次)对角线及与其相邻的斜线，再加上第一行(列)或第\\(n\\)行(列)外，其余元素均为\\(0\\)。这类行列式有点像前面说的两条线型行列式，但是还是有一点区别的。这类行列式都用累加消点法，即通常将某一行(列)都化简到只有一个非\\(0\\)元素，以便于降阶计算，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 1&amp;-1&amp;&amp;&amp;&amp;\\\\ &amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ &amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ &amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n\\(Solution\\): 将各列都加到第一列，得到：\n\\[\nD_n= \\left|\\begin{array}{cccc} \\frac{n(n+1)}{2}&amp;2&amp;3 &amp;... &amp;n-1&amp;n\\\\ 0&amp;-1&amp;&amp;&amp;&amp;\\\\ 0&amp;2&amp;-2&amp;...\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;&amp;&amp;n-2&amp;2-n&amp;\\\\ 0&amp;&amp;&amp;...&amp;n-1&amp;1-n \\end{array}\\right| \n\\]\n降阶之后再重复上述步骤即可得到通式：\n\\[\nD_n=(-1)^{n-1}\\frac{(n+1)!}{2} \n\\]\n注：需要说明的是，上面举的例子比较容易看出如何实施累加消点法就可以实现将某一行(列)都化简到只有一个非\\(0\\)元素从而达到降阶的目的，但是还有很多\\(Hessenberg\\)型行列式并不这么容易就做到，还需要大家找找技巧稍微变换一下，只要始终记得你要用累加消点法来消元来降阶就可以了\n六：三对角型行列式\n这是一种递推结构的行列式，特征为所有主子式都有相同的结构，从而以最后一列展开，将所得的\\((n-1)\\) 阶行列式再展开即得递推公式，即递推法(特征方程法)，请看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} a&amp;b&amp; &amp;&amp;... &amp;&amp;&amp;\\\\ c&amp;a&amp;b&amp;&amp;...&amp;&amp;&amp;\\\\ &amp;c&amp;a&amp;b&amp;...&amp;&amp;\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;\\\\ &amp;&amp;&amp;&amp;...&amp;a&amp;b\\\\ &amp;&amp;&amp;&amp;...&amp;c&amp;a \\end{array}\\right| \n\\]\n\\(Solution\\): 按第一列拉普拉斯展开，得：\n\\[\nD_n=aD_{n-1}-bcD_{n-2} \n\\]\n解特征方程： \\(x^2=ax-bc\\) ，得：\n\\[\nx_1=\\frac{a+\\sqrt{a^2-4bc}}{2}\n\\]\n\\[\nx_2=\\frac{a-\\sqrt{a^2-4bc}}{2} \n\\]\n即可得通式：\n\\[\nD_n = \\frac{x_1^{n+1}-x_2^{n+1}}{x_1-x_2} \n\\]\n注：特征方程法我没记错的话，应该是在高中将数列的时候用到的。\n七：各行元素和相等型行列式\n这个特征已经很清楚了吧，方法就是累加法，很简单，直接看下例\n\\[\neg:D_n= \\left|\\begin{array}{cccc} 1+x_1&amp;x_1 &amp;... &amp;x_1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n\\(Solution\\): 将第\\(i,i=2...n\\)行都加到第一行去，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1+\\sum_{i=1}^{n}x_i&amp;1+\\sum_{i=1}^{n}x_i &amp;... &amp;1+\\sum_{i=1}^{n}x_i\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;1 &amp;... &amp;1\\\\ x_2&amp;1+x_2&amp;...&amp;x_2\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;x_n&amp;...&amp;1+x_n \\end{array}\\right|= (1+\\sum_{i=1}^{n}x_i)\\left|\\begin{array}{cccc} 1&amp;0&amp;... &amp;0\\\\ x_2&amp;1&amp;...&amp;0\\\\ ...&amp;...&amp;...&amp;...\\\\ x_n&amp;0&amp;...&amp;1 \\end{array}\\right|=1+\\sum_{i=1}^{n}x_i \n\\]\n八：相邻两行对应元素相差K倍型行列式\n这个要用步步差法\n(1)大部分元素为数字，且相邻两行对应元素相差为\\(1\\)，采用逐步作差的方法，即可出现大量 \\(\\pm1\\) 元素，进而出现大量\\(0\\)元素\n(2)若相邻两行相差\\(K\\)倍，采用逐步作\\(k\\)倍差得方法，即可出现大量\\(0\\)元素\n请看下面两个例子\n\\[\neg1:D_n= \\left|\\begin{array}{cccc} 0&amp;1&amp;2 &amp;...&amp;n-2 &amp;n-1\\\\ 1&amp;0&amp;1&amp;...&amp;n-3&amp;n-2\\\\ 2&amp;1&amp;0&amp;...&amp;n-4&amp;n-3\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ n-2&amp;n-3&amp;n-4&amp;...&amp;0&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行减去后一行，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;1&amp;1 &amp;...&amp;1 &amp;1\\\\ -1&amp;-1&amp;1&amp;...&amp;1&amp;1\\\\ -1&amp;-1&amp;-1&amp;...&amp;1&amp;1\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-1&amp;-1&amp;...&amp;-1&amp;1\\\\ n-1&amp;n-2&amp;n-3&amp;...&amp;1&amp;0 \\end{array}\\right| \n\\]\n再将第一列加到第\\(i,i=2...n\\) 列，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} -1&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;0&amp;...&amp;0&amp;0\\\\ -1&amp;-2&amp;-2&amp;...&amp;0&amp;0\\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ -1&amp;-2&amp;-2&amp;...&amp;-2&amp;0\\\\ n-1&amp;2n-3&amp;2n-4&amp;...&amp;n&amp;n-1 \\end{array}\\right|=(-1)^{n-1}(-2)^{n-2}(n-1) \n\\]\n\n\\[\neg2:D_n= \\left|\\begin{array}{cccc} 1&amp;a&amp;a^2 &amp;...&amp;a^{n-2} &amp;a^{n-1}\\\\ a^{n-1}&amp;1&amp;a&amp;...&amp;a^{n-3} &amp;a^{n-2} \\\\ a^{n-2} &amp;a^{n-1} &amp;1&amp;...&amp;a^{n-4} &amp;a^{n-3} \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ a^2&amp;a^3&amp;a^4&amp;...&amp;1&amp;a\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n\\(Solution\\): 从第一行开始，依次用前一行加上后一行的\\((-a)\\) 倍，得：\n\\[\nD_n= \\left|\\begin{array}{cccc} 1-a^n&amp;0&amp;0&amp;...&amp;0&amp;0\\\\ a^{n-1}&amp;1-a^n&amp;0&amp;...&amp;0 &amp;0\\\\ 0 &amp;0 &amp;1-a^n&amp;...&amp;0&amp;0 \\\\ ...&amp;...&amp;...&amp;...&amp;...&amp;...\\\\ 0&amp;0&amp;0&amp;...&amp;1-a^n&amp;0\\\\ a&amp;a^2&amp;a^3&amp;...&amp;a^{n-1}&amp;1 \\end{array}\\right| \n\\]\n所以：\n\\[\nD_n=(1-a^n)^{n-1}\n\\]\n","categories":["机器学习数学基础"]},{"title":"07自动求导至08线性回归+基础优化算法","url":"/2022/02/06/07-08/","content":"筛选的Q&amp;A\n1、为什么深度学习中一般对标量求导而不是对矩阵或者向量？\n因为loss通常是一个标量，精度和loss在机器学习中都是一个标量。如果loss变成一个向量，那就会很麻烦。而且向量关于矩阵的loss就会变成一个矩阵，那么，矩阵再往下走，就会变成一个四维矩阵，那么神经网络一深，那就会变成一个特别特别大的张量，就算不出来了，所以loss通常是一个标量。\n2、多个loss分别反向的时候是不是要累计梯度？\n是的，假设在之后的神经网络有多个损失函数的话，是需要累积梯度的。也是为什么torch是默认累计梯度的。\n3、为什么获取grad前需要backward？\n不做backward的话不会去计算梯度，计算梯度是很贵的一件事情（时间和内存上）。\n4、求导过程一般来说是不是有向图？有没有环状的图结构？\n循环神经网络，但是计算上还是会展开，虽然逻辑上是有环的图。\n5、为什么用平方损失而不用绝对差值呢？\n因为绝对差值不可导。\n6、为什么机器学习优化算法都采用梯度下降，而不采用牛顿法？收敛速度更快，一般能算出一阶导，二阶导也能算。\n首先，二阶导不好算，不是总是能算出来的。 统计模型（损失函数），优化模型（我用什么算法优化），所以说把统计模型的最优解求出来的意义并不大，收敛快不快不那么关心。关心的是收敛导哪个地方，泛化性不一定比梯度下降好，不一定更实用。\n7、detach是什么作用\n告诉程序不用算梯度了。\n8、每次都随机取出一部分，怎么保证最后所有数据都被拿过了？\nbootstraping采样。次数多的情况下会遇到所有的数据，数据多的话也没必要所有的数据都用到。\n9、如果样本大小不是批量数的整数倍，那需要随机剔除多余的样本吗？\n\n改batch_size，使得epoch迭代完整\n忽略最后一次epoch的迭代\n不足部分从原有数据中抽出差额补齐\n\n08 线性回归 + 基础优化算法【动手学深度学习v2】\n","categories":["动手学深度学习v2"]},{"title":"如何做文献阅读汇报？——改自知乎答案","url":"/2022/02/14/%E5%A6%82%E4%BD%95%E5%81%9A%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E6%B1%87%E6%8A%A5%EF%BC%9F/","content":"青藤学术\n来源：知乎答案\n一篇文章又分成研究型文献和综述性文献。\n研究型文献\n针对一篇研究型文献，那么我们需要向读者讲清这篇文献的故事：\n\n这篇文献讲了个什么问题， 他的假设是什么？\n作者为什么要提出这个假设 （研究背景，他不可能凭空提出来做这个）？\n他证明了这个假设吗（大概率是的）？\n他怎么证明的（数据来源是什么，做了几组实验，什么被试，使用了什么器材，什么试剂，为什么要做几组实验，分别证明了什么）？\n作者的结论是什么？\n他还对研究提出了展望吗？他有没有声明研究的一些缺憾？\n最重要的： 你的看法（这就是 critical thinking了）， 具体可以包括：\n\n你同意作者提出的这个假设吗，有其他的文献支持或者反对作者的假设吗，为什么？\n作者的实验（数据）证明了假设吗，为什么？\n你同意作者的结论吗？为什么？\n你觉得可以在作者的基础上，有拓展空间吗？作者提出的展望值得我们研究吗？\n\n\n综述性文献\n综述文献和研究型文献有相似的地方，也有不同的地方。 相同的地方，文献都是讲一个故事，不同的地方是，综述里不涉及作者新的证明（实验），但是他会用已有的文献找到一个好的角度，这个角度是最重要的。\n我们对综述文献汇报：\n\n作者为什么要写这篇综述？\n这篇综述提出了一个什么问题或者几个问题？\n针对每个问题，作者是用哪些文献来佐证他的观点的？有没有反对的文献？\n接下来，你的想法：\n\n读完这些综述，你学习到了一些什么领域的知识？\n作者列出的这么多文献里，你觉得那些值得继续阅读？为什么？\n你觉得读完这篇综述，从作者提出的这些问题，你有启发吗？\n作者所列举的问题，你觉得值得拓展研究吗？\n\n\n综述一般是用来学习的，所以从汇报者的角度来说，如果能 Get 到能学习哪些东西，能继续阅读哪些文献，有没有启发，有没有一些 idea， 那就实现了目的。\n多篇文献\n第一种方法，如果文献不是很多，比如1-3篇，可以逐篇汇报，没有毛病，不扣分。当然控制时间，不要一个人讲了一个小时，其他人听得要睡觉。\n第二种方法，文献数量比较多，那么就要串一下，类似做个小综述，这就需要点本事。你得找到一个串的东西，我可以举一些例子，你大概会明白怎么串：\n​ 1） 这几个文献用了同一个研究方法，比如问卷，你发现他们其实挺难有因果关系；\n​ 2） 他们都用了相同的仪器，然后你觉得这个仪器你们也可以用，可以怎么在你们的实验中发挥重大的作用；\n​ 3） 他们都讨论了同一个问题，要么是时间先后顺序，要么是一个问题的不同角度，得出了不同的结论，这很有趣，我们也可以Follow。\n第二种方法需要的时间比较多一些，抽象一些，如果时间有，可以多试试看，毕竟你都读了好几篇。\n以上说的都是内容，汇报不仅包括内容，还包括内容的形式，以及报告本身（你的表演）。我稍微点一下，仁者见仁，这个需要本事。\n关于PPT\n写 PPT 的套路就很多了，但有一些guideline 和你share 一下：\n\n能用图就不要用文字；\n文字要少，不要和有些老师上课用的 PPT 那样，全部是字 ...\n列要点，说要点，不要遗漏即可。要点简要到你自己能想起来你要说啥就可以。\n风格不要洗剪吹，简洁，清爽，切记，看的人舒服。\n求你们英文不要用宋体，不要全角，不要用中文标点。反之一样，中文不要用英文标点。\n不要有拼写错误（现在 PPT 都有拼写检查），领域里的专业名词和缩小多检查几遍，不要出错。\n尽量不要有语法错误，找个英语好的同学帮忙 Check一下。\n不要最后一个晚上赶工，提前做准备。\n多检查几遍，会发现很多错误。\n\n\n这篇文章的目的是什么？研究的核心是什么？核心的结论有哪些？\n把文章的结论进行一个简要的翻译，起到最终收尾的作用\n\n车前草\n来源：知乎答案\n每个session一般有4-5篇必读文献，3篇左右选读文献。一般课上5-6人，一个人当leader，其他人都是discussant。leader是每周轮流换的。leader需要读全部的论文，discussant读必读的就可以。我们一般是三小时的课，每篇文献大概能讨论半小时到五十分钟。\nLeader通常会做PPT。内容不多，七八页左右就可以了。每页内容也很简单，大致包含以下标题：\n\nResearch Question(s). 本文研究了什么？解答了什么样的问题？\nTheoretical argument. 本文的主要argument是什么？具体说来，可以包括以下几个小的方面：a. 使用了什么理论作为依托。也就是说本文的论点是建立在什么理论上的。b. 对哪个理论/领域做出了贡献（因为使用的理论不一定要和做出贡献的理论一致。）c. 理论的推导是如何完成的。对于实证论文来说，就是自变量到因变量的逻辑是什么样的。d. argument的边界条件是什么。本文所提出的观点（即hypothesis）在什么样的条件下是立得住脚的。\nEmpirics. 本文使用了什么数据？数据是从哪里来的？取得数据的行业大致是什么样的情况？为什么这个数据有用？在方法上，为什么采用这种回归模型？为什么用零膨胀负二项回归（ZINB）而不是泊松回归（Poisson）？\nComments. 即你作为评论人对于这篇文章是怎么看的。好在哪里？差在哪里？\n\n我们老师在领域里有一定地位，提问题特别辛辣。他一般不喜欢学生在1和3方面集中太多精力。而是喜欢在2和4里挑战（challenge）学生。在讨论问题2时，他不喜欢学生把PPT里的东西念出来，而是希望你回答 “为什么这篇文章要用A理论不用B理论？”“这篇文章跟我们以前读过X文章有什么联系？”“这篇文章是如何和讨论C理论的Y、Z文章联系起来的？” 之类的问题。在回答问题4时，他希望你有建设性的批评（constructive critique）而不是光批评不提解决办法（criticizing）。总之，上文献讨论课会很辛苦。尤其对于没有参与过西方式课堂讨论的中国学生来说，第一年是一个大挑战。\n\n接下来说说为啥你觉得没什么好说的。这种事情非常正常。刚开始接触文献的时候会自然而然地把接收到的信息当做真理，大牛都已经做过了，好像都挺对，没啥意见…… 其实看多了文章之后就会知道，其实每篇文章都有或多或少的毛病。区别只在于毛病是否有损文章在领域内的贡献罢了。为了解决这个问题，还是要多看、多写。看完文章一定要写summary，research question写一段就够了，重点是constructive critique(s)。文章看多了，每篇文章在整个领域内的位置就清晰了。\n有一些速成问题可以思考的：\n理论方面：\n\n理论的假设（assumption）是什么？适用范围如何？对于本文的行业背景到底合适吗？为何本文讨论的事情不用A理论非要用B理论？\n理论的边界条件（boundary condition）是啥？假设是不是所有情况下一定成立的？\n\n实证方面：\n\n有没有遗漏变量、互为因果、测量误差等内生性问题？\n模型设定对吗？估计方法合适吗？\n假设有没有其他解释（alternative explanation）？排除了其他逻辑的干扰了吗？\n结果稳健吗？有没有P-hacking？\n\n\n最后说说汇报时的小技巧。我自己认为，写在slides上的东西其实并不重要，关键是观众听进去了多少。我一般会避免在slides上堆太多文字，一页五行字，一些关键词就差不多了。千万不要念PPT。听众期待的是脑力上的激荡，而不是一台复读机。为了激起观众的兴趣，在讲述过程中可以适当抛几个问题。（并不一定要点人回答，只要看到听众在想问题就可以了。）尽量跟听众有眼神接触，同时辅之以少量手势。不独中国人，东亚学生在做presentation上都不如北美学生熟练自信。掌握了这些讲述技巧，听众也容易弄懂你的内容。\nPPT 目录结构\n\nThe Summary of Wesley D. Sine &amp; Brandon H. Lee 2009.3 Tilting at Windmills? The Environmental Movement and the Emergence of the U.S. Wind Energy Sector Administrative Science Quarterly, 54(2009): 123-155\nExecutive Summary\n\nAbstract\n\nResearch Question\n\nGeneral Research Question\n\nHow …..?\n\nSpecific Research Question\n\nHow can …. ?\n\n\nTheory\n\nKey Theoretical Arguments\n\nEmpirics\n\nResearch Context : U.S. Wind energy sector\nSampling : 1978-1992, state-level data on entrepreneurial activity, environmental social movement organizations, and the regulatory environment in the U.S. wind energy sector.\n\nDependent Variable:\nExplanatory Variables:\nControl Variables:\n\nMethod:\n\nEvent history methods ….\n\nFindings:\n\nComments\nImportant Citations\n\nCitations that have direct theoretical impact to the focal paper\n\n\n","categories":["研究初成长"]},{"title":"Hello World","url":"/2022/01/04/hello-world/","content":"2022，你好。\n","categories":["hello"]},{"title":"机器学习数学基础：微积分","url":"/2022/01/08/%E5%BE%AE%E7%A7%AF%E5%88%86/","content":"本章介绍微积分中的函数、极限、导数、梯度及积分等基本概念。\n1 函数和极限\n1.1 函数的定义\n设 \\(A\\)，\\(B\\) 都是非空的数的集合，\\(f:x \\rightarrow y\\) 是从 \\(A\\) 到 \\(B\\) 到一个对应法则，那么从 \\(A\\) 到 \\(B\\) 的映射\\(f:x \\rightarrow y\\) 就叫做函数，记作 \\(y=f(x)\\) ，其中 \\(x \\in A\\)，\\(y \\in B\\) .\n1.2 反函数\n设函数 $ y =f(x) $ 的定义域是 \\(D\\)，值域是 \\(f(D)\\) 。如果对于值域 \\(f(D)\\) 中的每一个 \\(y\\) ，在 \\(D\\) 中有且仅有一个 \\(x\\) 使得 \\(g(y)=x\\) ，则按此对应法则得到了一个定义在 \\(f(D)\\) 上的函数，并把该函数称为函数 \\(y=f(x)\\) 的反函数，记作 \\(x=f^{-1}(y)\\)，\\(y \\in f(D)\\) .\n1.3 复合函数\n若 \\(y\\) 是 \\(u\\) 的函数：\\(y=f(u)\\) ，而 $u $ 又是 \\(x\\) 的函数：\\(u=g(x)\\) ，且 \\(g(x)\\) 的函数值的全部或部分在 \\(f(u)\\) 的定义域内，则 \\(y\\) 通过 \\(u\\) 成为 \\(x\\) 的函数，这种函数称为由函数 \\(u=g(x)\\) 和函数 \\(y=f(u)\\) 构成的复合函数，记作 \\(y=f[g(x)]\\) ，其中 \\(u\\) 叫作中间变量。\n1.4 多元函数\n设有两个独立的变量 \\(x\\) 与 \\(y\\) 在其给定的变域 $ D$ 中，任取一组数值时，第 \\(3\\) 个变量 $ z$ 就以某一确定的法则有唯一确定的值与其对应，那么变量 \\(z\\) 称为 \\(x\\) 和 \\(y\\) 的二元函数，记作 \\(z=f(x,y)\\) ，其中 \\(x\\) 与 \\(y\\) 称为自变量，函数 \\(z\\) 也叫作因变量，自变量 \\(x\\) 与 \\(y\\) 的变域 \\(D\\) 称为函数的定义域。\n1.5 函数极限的性质\n数列极限的定义：给定数列 $ {x_n}$ ，实常数 \\(a\\) ，若对任意给定的 \\(\\epsilon&gt;0\\) ，可以找到正整数 \\(N\\) ，使得当 \\(n&gt;N\\) 时，$ |x_n-a|&lt;$ 成立，则称数列 $ {x_n}$收敛于 \\(a\\) （或称 \\(a\\) 是数列 $ {x_n}$ 的极限）。\n自变量趋向于无穷大时函数极限的定义： 类似数列极限的定义。\n自变量趋向有限值时函数极限的定义：设函数 \\(f(x)\\) 在某点 \\(x_0\\) 的某个去心邻域内有定义，后面类似数列极限的定义。\n一些懒得敲公式的知识概念：数列极限的夹逼定理、函数极限的夹逼定理、函数极限的运算法则（加减乘除幂）、无穷大量和无穷小量。\n两个公式： \\[\n\\lim\\limits_{x\\rightarrow0}\\frac{\\text{sin} x}{x}=1\\\\\n\\lim\\limits_{x\\rightarrow0}(1+x)^{\\frac{1}{x}}=e\n\\]\n1.6 洛必达法则\n适用于 \\(\\large\\frac{0}{0}\\) 和 \\(\\large\\frac{\\infty}{\\infty}\\) 及其变式。\n1.7 函数的连续性\n一些懒得敲公式的知识概念：函数连续性定义、最值定理、介值定理、零点存在定理（勘根定理）\n1.8 拉格朗日乘数法\n拉格朗日乘数法可以解决约束优化问题。其基本思想是通过引入拉格朗日乘子来将含有 \\(n\\) 个变量和 \\(k\\) 个约束条件的约束优化问题转化成含有 \\(n+k\\) 个变量的无约束优化问题。是解决带等式约束优化问题的常用方法。\n详见：\n好久不见的拉格朗日乘数法：https://zhuanlan.zhihu.com/p/149104728\n如何理解拉格朗日乘子法？：https://www.zhihu.com/question/38586401\n1.9 函数间断点\n即不满足函数连续定义的条件。分为：\n\n第一类间断点：左右极限有定义\n\n跳跃间断点：左右极限不相等\n可去间断点：左右极限相等\n\n第二类间断点：左右极限不全有定义\n\n习题\n利用 \\(SymPy^{[1]}\\) 库实现 \\(\\lim\\limits_{a\\rightarrow 0}\\frac{sin(a)}{a}\\) 和 \\(\\lim\\limits_{n\\rightarrow\\infty}(\\frac{n+3}{n+2})^n\\) 的求解。\n#coding:utf-8import sympysympy.init_printing()from sympy import oo# 1.求sin(a) / a在a=0处的极限a = sympy.Symbol(&#x27;a&#x27;)b = sympy.sin(a) / aresult = sympy.limit(b,a,0)print(&#x27;sin(a) / a在a趋近于0处的极限:&#x27;,result)#2.求[(n+3)/(n+2)]^n ,n趋紧无穷大时的极值n = sympy.Symbol(&#x27;n&#x27;)y = ((n+3)/(n+2))**nprint ( &#x27;[(n+3)/(n+2)]^n ,n趋紧无穷大的极值：&#x27;,sympy.limit(y, n, sympy.oo) )\n2 导数\n2.1 导数的概念\n有定义，有增量，极限存在。是一种变化率\n2.2 偏导数、全导数\n偏导数相对于多元函数，全导数相对于复合函数。\n2.3 高阶导数\n多次连续求导。\n2.4 函数的基础求导法则\n一些懒得敲公式的知识概念：常用的求导公式、和与差的求导法则、复合函数的求导规则、反函数的求导法则、隐函数的求导法则等各种求导法则。\n2.5 链式法则及复杂函数的求导\n假设 \\(z = f(u, v)\\)的每一个自变量都是二元函数，也就是说，\\(u=h(x, y)\\) ，\\(v = g(x, y)\\) ，且这些函数都是可微的。那么，\\(z\\) 的偏导数为： \\[\n\\frac {\\delta z}{dx}  =  \\frac {\\delta z}{du}  \\frac {du}{dx}  +  \\frac {\\delta z}{dv} \\frac {\\delta v}{dx} \\\\\\\n \\frac {\\delta z}{dy}= \\frac {\\delta z}{du} \\frac {\\delta u}{dy}+\\frac {\\delta z}{dv} \\frac {\\delta v}{dy}\n\\] 如果我们考虑 $  =(u,v)$，为一个向量函数，我们可以用向量的表示法把以上的公式写成 \\(f\\) 的梯度与 \\(\\overrightarrow {r}\\) 的偏导数的数量积:\n\\[\n\\frac {\\delta f}{dx}  =  \\overrightarrow {V}  f  \\cdot   \\frac {\\theta r}{dx}\n\\] 更一般地,对于从向量到向量的函数,求导法则为: \\[\n\\frac {\\delta (z_ {1},\\cdots ,z_ {m})}{o(x_ {1},\\cdots ,x_ {p})} =  \\frac {d(z_ {1},\\cdots ,z_ {m})}{d(y_ {1},\\cdots ,y_ {n})}  \\frac {o(y_ {1},\\cdots ,y_ {n})}{o(x_ {1},\\cdots ,x_ {p})}\n\\]\n2.6 导数的应用\n一些懒得敲公式的知识概念：极值与最值、曲线的凸凹、拐点（凹弧的分界点）、泰勒公式和泰勒展开式、泰勒定理、中值定理（拉格朗日、罗尔和柯西中值定理）\n3 方向导数和梯度\n3.1 向量\n一些懒得敲公式的知识概念：向量的模、数量积（内积、点积、标量积 $ |a||b|cos$）、向量积（外积、叉积，它的模是 \\(|a||b|sin\\theta\\)）\n3.2 方向导数、梯度\n带有方向（极值方向，一般是取最大值的方向）的导数。\n3.3 雅可比矩阵与局部最优问题\n详见：雅可比矩阵和雅可比行列式：https://zhuanlan.zhihu.com/p/39762178\n3.4 黑塞矩阵\n二阶偏导数矩阵就是黑塞矩阵（Hessian Matrix）。它是一个自变量为向量的实值函数的二阶偏导数组成的方阵。\n\n如果H(M)是 正定矩阵，则临界点M处是一个局部的极小值。\n如果H(M)是 负定矩阵，则临界点M处是一个局部的极大值。\n如果H(M)是 不定矩阵，则临界点M处不是极值。\n\n习题\n调用 SymPy的库函数求解出雅可比矩阵的形式，调用Theano的库函数计算雅可比矩阵和黑塞矩阵的值。\n#实例01：用SymPy库函数求解出的雅克比矩阵的形式。import sympym,n,i,j = sympy.symbols(&quot;m n i j&quot;)m = i**4-2*j**3-1 #设置变量（符号）n = j-i*j**2+5funcs = sympy.Matrix([m,n])#矩阵的维度m,nargs = sympy.Matrix([i,j])res = funcs.jacobian(args)#调用jacobian函数求解print(res)#实例02：Theano库实现雅克比矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as T# 计算雅克比矩阵x=T.dvector(&#x27;x&#x27;)y=x**3+x**4# 调用scan构建循环GraphJ,updates=theano.scan(lambda i,y,x:T.grad(y[i],x),sequences=T.arange(y.shape[0]),non_sequences=[y,x])f1=function([x],J,updates=updates)print(&quot;f1=&quot;,f1([5, 5]))#实例03：Theano库实现海森矩阵的计算。import theanofrom theano import function, config, shared, sandboximport theano.tensor as Tx=T.dvector(&#x27;x&#x27;)# 计算hessian矩阵y=x**3+x**4cost=y.sum()gy=T.grad(cost,x) #求梯度# 调用scan构建循环GraphH,updates=theano.scan(lambda i,gy,x:T.grad(gy[i],x),sequences=T.arange(gy.shape[0]),non_sequences=[gy,x])f2=function([x],H,updates=updates)print(&quot;f2=&quot;,f2([5, 5]))\n4 积分\n4.1 不定积分\n一些懒得敲公式的知识概念：原函数（定义、存在定理、原函数族 \\(F(x)+C\\)）\n4.2 求不定积分的方法\n一些懒得敲公式的知识概念：积分基本公式、换元法、分部积分法\n4.3 定积分\n一些懒得敲公式的知识概念：定积分定义、性质（和差、与常数乘积、单调性、极值）、积分中值定理\n","categories":["机器学习数学基础"]},{"title":"栈和递归","url":"/2022/01/17/%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92/","content":"栈（Stack）\n栈对数据 \"存\" 和 \"取\" 的过程有特殊的要求：\n\n栈只能从表的一端存取数据，另一端是封闭的。\n在栈中，无论是存数据还是取数据，都必须遵循\"先进后出\"的原则，即最先进栈的元素最后出栈。\n\n因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 \"先进后出\" 原则的线性存储结构。通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。栈的最重要一个特点——后进先出（LIFO，Last In First Out），也可以说是先进后出（FILO，First In Last Out），我们无论如何只能从一端去操作元素。\n栈又叫作堆栈，这里说明一下不要将它和堆混淆。实际上堆和栈是两个不同的概念，栈是一种只能在一端进行插入和删除的线性数据结构。\n一般来说，栈主要有两个操作：一个是进栈（PUSH），又叫作入栈、压栈；另一个是出栈（POP），或者叫作退栈。\nclass Stack:    def __init__(self):        self.stack = []        self.size = 0    def push(self, item):        self.stack.append(item) # 添加元素        self.size += 1 # 栈元素数量加 1    def pop(self):        pop = self.stack.pop() # 删除栈顶元素        self.size -= 1 # 栈元素数量减 1        return pop    def isEmpty(self):        return self.stack == []    def sizes(self):        return self.size    def peek(self):        return self.stack[-1]if __name__ = &#x27;__main__&#x27;:    # 这里假定 A 是 4，B 是 &#x27;dog&#x27;,建议每一步的结果用 print() 输出看一下    s = Stack()    s.isEmpty()    s.push(4)    s.push(&#x27;dog&#x27;)    s.peek()    s.pop()    s.isEmpty()\n递归函数\n递归函数（recursive function）是指会调用自身的函数。为了防止函数无限地重复调用自身，代码中必须至少有一条选择语句。这条用来查验条件的语句被称为基本情况（base case），用于确定接下来要继续递归还是停止递归。\ndef displayRange(lower, upper):     &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;     while lower &lt;= upper:         print(lower)         lower = lower + 1\n如何将这个函数转换为递归函数呢？首先，需要注意如下两点重要的情况。\n\nlower &lt;= upper时，循环的主体会继续执行。\n执行这个函数时，lower会不断地加1，但是upper不会有任何改变。\n\n等价的递归函数可以执行类似的基本操作，区别在于：循环被替换成了if语句；赋值语句被替换成了函数的递归调用。修改后的代码如下：\ndef displayRange(lower, upper):     &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;     if lower &lt;= upper:         print(lower)         displayRange(lower + 1, upper)\n尽管这两个函数的语法和设计是不一样的，但是它们执行的算法过程相同。递归函数的每次调用都像在迭代版本函数里的循环一样，每次都会访问整个序列里的下一个数。\n通常来说，递归函数至少有一个参数。这个参数的值会被用来对递归过程的基本情况进行判定，从而决定是否要结束整个调用。在每次递归调用之前，这个值也会被进行某种方式的修改。每次对这个值的修改，都应该产生一个新数据值，可以让函数最终达到基本情况。在displayRange这个示例里，每次递归调用之前都会增加参数lower的值，从而让它最终能够超过参数upper的值。\ndef ourSum(lower, upper, margin = 0):     &quot;&quot;&quot;Returns the sum of the numbers from lower to upper,     and outputs a trace of the arguments and return values     on each call.&quot;&quot;&quot;     blanks = &quot; &quot; * margin     print(blanks, lower, upper)         # Print the arguments    if lower &gt; upper:         print(blanks, 0)                # Print the returned value        return 0    else:        result = lower + ourSum(lower + 1, upper, margin + 4)        print(blanks, result)           # Print the returned value        return result&gt;&gt;&gt; ourSum(1, 4) 1 4   2 4       3 4          4 4             5 4             0          4       7    9 10 10\n从结果可以看出，随着对ourSum调用的进行，参数会不断向右缩进。注意，每次调用时，lower的值都增加1，而upper的值始终保持不变。对ourSum的最后一次调用返回0。随着递归的返回，所返回的每个值都与其上面的值对齐，并且会增加上lower的当前值。这样的跟踪，对于递归函数来说，是非常有用的调试工具。\n递归的三大要素\n整理自知乎\n第一要素：明确你这个函数想要干什么\n对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。\n例如，我定义了一个函数\n#算n的阶乘(假设n不为0)def f(n):\t\tpass\n这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。\n第二要素：寻找递归结束条件\n所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。\n例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下\n#算 n 的阶乘(假设n不为0)def f(n):\t\tif n == 1:        return 1\n有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？\n当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。\n#算 n 的阶乘(假设n&gt;=2)def f(n):\t\tif n == 2:        return 2\n注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样：\n# 算 n 的阶乘(假设n不为0)def f(n):\t\tif n &lt;= 2:        return n\n第三要素：找出函数的等价关系式\n第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。\n例如，\\(f(n)\\) 这个范围比较大，我们可以让 \\(f(n) = n * f(n-1)\\)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。\n说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即\n\\(f(n) = n * f(n-1)\\)。\n找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：\n# 算 n 的阶乘(假设n不为0)def f(n):\t\tif n &lt;= 2:        return n\t\treturn f(n-1) * n\n至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。\n这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。\n还是不懂？没关系，我再按照这个模式讲一些题。\n\n有些有点小基础的可能觉得我写的太简单了，没耐心看？少侠，请继续看，我下面还会讲\n如何优化递归\n\n案例1：斐波那契数列\n\n斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34....，即第一项 f(1) = 1,第二项 f(2) = 1.....,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。\n\n1、第一递归函数功能\n假设 f(n) 的功能是求第 n 项的值，代码如下：\n2、找出递归结束的条件\n显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) = f(2) = 1。所以递归结束条件可以为 n &lt;= 2。代码如下：\ndef f(n):    if n &lt;= 2:        return 1\n3、找出函数的等价关系式\n题目已经把等价关系式给我们了，所以我们很容易就能够知道 \\(f(n) = f(n-1) + f(n-2)\\)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。\n所以最终代码如下：\ndef f(n):    # 1.先写递归结束条件    if n &lt;= 2:        return 1    # 2.接着写等价关系式    return f(n - 1) + f(n - 2)\n搞定，是不是很简单？\n\n零基础的可能还是不大懂，没关系，之后慢慢按照这个模式练习！好吧，有大佬可能在吐槽太简单了。\n\n案例2：小青蛙跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n1、第一递归函数功能\n假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：\ndef f(n):\t\tpass\n2、找出递归结束的条件\n我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：\ndef f(n):    if n == 1:        return 1\n第三要素：找出函数的等价关系式\n每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。\n第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。\n第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。\n所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：\ndef f(n):    if n == 1:        return 1    return f(n - 1) + f(n - 2)\n大家觉得上面的代码对不对？\n答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。\n这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：\ndef f(n):    if n &lt;= 2:        return n    return f(n - 1) + f(n - 2)\n递归的缺点\n虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。\n1、递归堆栈溢出\n▉ 理解堆栈溢出\n1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。\n2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。\n3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。\n#报错def f(i):    if i == 1:        return 1    return i + f(i -1) result = f(200000)print(result)\n▉ 解决办法\n通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。\ndepth=1def f(n):    global depth    depth+=1    if(depth &gt; 1000):        raise Exception(&#x27;堆栈溢出&#x27;)    if(n == 1):        return 1    print(depth)    return f(n-1) + 1\n解决方案 tail recursion\n2、递归重复元素\n有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。\n▉ 解决办法\n重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表（hash）或者键值对来保存。\n3、递归高空间复杂度\n因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。\nhttps://leetcode-cn.com/problems/unique-paths/\nhttps://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/\n","categories":["数据结构"]},{"title":"爬虫：电子阅读权限保存电子书","url":"/2022/02/09/%E7%94%B5%E5%AD%90%E9%98%85%E8%AF%BB%E6%9D%83%E9%99%90%E4%BF%9D%E5%AD%98%E7%94%B5%E5%AD%90%E4%B9%A6/","content":"在文泉书局上买了本《统计学习必学的十个问题》，但是只有网上的阅读权限，不是很方便做笔记。电子阅读后发现，每一页其实都是一张图片，因此可以把图片保存下来，然后再合成PDF。再HTML进行解析获得左边目录对应的书签，对PDF进行添加书签，然后一本带书签的PDF文件就下载完毕了。\n本文代码参考：\n\n文泉书局的电子书下载方法-c++\n文泉学堂PDF(带书签)下载原理详细讲解_python脚本实现\n\n问题\n所有的电子书内容都是以图片进行传输和显示的，那么只要能获取图片的url或者直接获取图片内容就可以把图片保存下来。但是，在图片的url请求地址中包含有一个key，不要这个key就只能获取到一张非常模糊的图片，只有key值对上了才能请求到清晰的图片，而且这个请求地址好像还是有时间限制的，估计是在key里面有个时间戳\\(^{[1]}\\)。（只有留在那一页才会有清晰的图片，否则只会有缩略图或者模糊版本，而且图片采用的是base64加密。）\n\n\n\n解决方案\n登陆\n因为是登陆后买的书籍，所以需要登陆（懒得写验证码等等，直接分开运行好了）。\nBEGIN_PAGE = 1url = &quot;https://wqbook.wqxuetang.com/read/pdf?bid=3224478&quot;# 图片路径，mac路径_image_path = &quot;./img/&quot;start = time.time()  # 开始时间browser = webdriver.Chrome() #这里也可以加路径，通过chrome://settings/help了解版本号，下载对应的web driver即可browser.get(url=url)  # 访问\n然后手动登陆。\n下载高清图片\n可以在页码框中依次输入页码1，3...（也可以改成1，2，3...），每次输入完之后保存图片再进行下一次输入。采用python的selenium模块进行模拟，然后用webdriver.Chrome()对象的page_source来获取当前页面的html文档，之后再用BeautifulSoup获取加密的图片数据，然后base64解密，获取图片的分辨率，如果\\(&gt;500\\)（判断是不是缩略图）就保存图片。\nmain-code\ndataQueue = queue.Queue(155)  # 初始化队列try :    time.sleep(4)    pages = 155    print(&quot;总页数为%d&quot; % pages)  # 获取书本总页数    for i in range(BEGIN_PAGE, pages, 2) :        list = input_action(browser, i, False)        download_image(list[0], i, dataQueue)        download_image(list[1], i + 1, dataQueue)        print(&quot;下载进度: %f%%   \\r&quot; % ((i / pages) * 100))    if pages % 2 == 1 :  # 如果是奇数的话，最后一页没有下载        text = input_action(browser, pages, True)        download_image(text, pages, dataQueue)    while not dataQueue.empty() :        index = dataQueue.get(False)        b_text = input_action(browser, index, True)        download_image(b_text, index, dataQueue)    end = time.time()    print(&quot;-------------下载图片完毕-------------&quot;)\ndef-code\n函数：get_image_size，delay，input_action，download_image .\ndef get_image_size(content) :    &quot;&quot;&quot;    :param content: 图片的二进制数据    :return: 图片的宽高    &quot;&quot;&quot;    tmpIm = BytesIO(content)    im = Image.open(tmpIm)    w = im.size[0]  # 宽    h = im.size[1]  # 高    return w, h  def delay(browser, page, is_last) :    &quot;&quot;&quot;    此函数非常关键，它等待两个页面全部加载完毕    原理是根据此页面的图片是否高清    输入页码之后，一次加载的是2页，比如输入3，加载的是3,4两页的图片    :param browser:webdriver.Chrome()    :param page:页数    :param is_last: 是否是最后一页    :return:图片字节流    &quot;&quot;&quot;    start_tm = datetime.datetime.now()    while True :        try :            # 如果长时间没反应就刷新当前页面，并且把当前下载页面输入进去            end_tm = datetime.datetime.now()            if (end_tm - start_tm).seconds &gt; 8 :                start_tm = datetime.datetime.now()                browser.refresh()                time.sleep(1)                input_ = browser.find_element_by_id(&#x27;input&#x27;)                input_.clear()                input_.send_keys(&#x27;1&#x27;)                time.sleep(0.5)                input_.clear()                input_.send_keys(str(page))                input_.send_keys(Keys.ENTER)            html = browser.page_source            soup = BeautifulSoup(html, &quot;html.parser&quot;)            help_contents = soup.find_all(&#x27;div&#x27;, class_=&quot;page-img-box&quot;)            text1 = help_contents[page].find(&#x27;img&#x27;)[&#x27;src&#x27;]            index1 = text1.find(&quot;,&quot;)            img_byte1 = base64.b64decode(text1[index1 + 1 :].encode(&quot;utf-8&quot;))            num1, tmp = get_image_size(img_byte1)            if not is_last :  # 如果不是最后一个                text2 = help_contents[page + 1].find(&#x27;img&#x27;)[&#x27;src&#x27;]                index2 = text2.find(&quot;,&quot;)                img_byte2 = base64.b64decode(text2[index2 + 1 :].encode(&quot;utf-8&quot;))                num2, tmp = get_image_size(img_byte2)                if num1 &gt; 500 and num2 &gt; 500 :                    return [img_byte1, img_byte2]                time.sleep(0.5)            else :  # 如果是最后一个                if num1 &gt; 500 :                    return img_byte1        except :            passdef input_action(browser, page_num, is_last) :    &quot;&quot;&quot;    开始模拟自动输入页码，加载    &quot;&quot;&quot;    input = browser.find_element_by_id(&#x27;input&#x27;)    input.clear()    input.send_keys(str(page_num))    input.send_keys(Keys.ENTER)    # 延迟，等待页面加载完毕    _list = delay(browser, page_num, is_last)    return _listdef download_image(text, page, dataQueue) :    &quot;&quot;&quot;    :param text: 图片字节流    :param page: 页码，防止保存失败的时候，加入到dataQueue中方便最后重新下载    :param dataQueue:    :return:    &quot;&quot;&quot;    try :        byte_text = text        img_name = str(page) + &quot;.jpeg&quot;        with open(_image_path + img_name,&#x27;wb&#x27;) as f:            f.write(byte_text)    except :        print(&quot;第%d页下载失败&quot; % page)        print(_image_path+img_name)        dataQueue.put(page)\n下载书签\nmain-code\nbookmark = download_bookmark(bookmark_action(browser))  # 打开目录，准备下载书签print(&quot;下载书签完毕&quot;)\ndef-code\n函数：bookmark_action，download_bookmark .\ndef bookmark_action(browser) :    &quot;&quot;&quot;    开始模拟打开所有目录(经过测试，只有打开所有目录之后，子书签才会出现在html文档中)    :param browser:    :return:返回包含子书签的html文档，以便后期用BeautifulSoup获取保存书签    &quot;&quot;&quot;    mulu = browser.find_element_by_css_selector(&quot;[class=&#x27;iconfont2 icon-wq-catalog&#x27;]&quot;)    mulu.click()    # 打开所有的三角形    sjxs = browser.find_elements_by_css_selector(&quot;[class=&#x27;el-tree-node__expand-icon el-icon-caret-right&#x27;]&quot;)    for sjx in sjxs :        sjx.click()        time.sleep(0.5)    time.sleep(2)  # 等待2秒，开始    html = browser.page_source.encode(&quot;utf-8&quot;)    return html  def download_bookmark(html) :    &quot;&quot;&quot;    爬取书签保存为列表,格式如下    无子书签： [name, num, 0]    有子书签: [name, num, [[child_name1, child_num1],[child_name2, child_num2]...... ]]    :param html: html字符串    :return:返回书签列表    &quot;&quot;&quot;    soup = BeautifulSoup(html, &quot;html.parser&quot;)    help_contents = soup.find(&#x27;div&#x27;, role=&quot;tree&quot;)    xs = help_contents.contents    parent_tag_list = []    for i in range(len(xs)) :  # 筛选出父节点        try :            if xs[i][&#x27;role&#x27;] == &quot;treeitem&quot; :                parent_tag_list.append(xs[i])        except :            pass    bookmark = []    for i in range(len(parent_tag_list)) :        temp_bookmark = [0, 0, 0]  # 名字，序号，子节点        temp_bookmark[0] = parent_tag_list[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-left&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;)        temp_bookmark[1] = parent_tag_list[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-pagenum&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;)        a = parent_tag_list[i].find(&quot;div&quot;, class_=&quot;el-tree-node__children&quot;)        if a :  # 如果存在子节点            tag_children = a.find_all(&#x27;div&#x27;, role=&quot;treeitem&quot;)            children_bookmark = []            for i in range(len(tag_children)) :                child_bookmark = [0, 0]  # 名字，序号                child_bookmark[0] = tag_children[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-left&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;)                child_bookmark[1] = tag_children[i].find(&quot;div&quot;, class_=&quot;el-tree-node__content&quot;).find(&quot;span&quot;,class_=&quot;BookCatTree-node-pagenum&quot;).string.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;)                children_bookmark.append(child_bookmark)            temp_bookmark[2] = children_bookmark        else :            temp_bookmark[2] = 0        bookmark.append(temp_bookmark)    return bookmark\n合成pdf\nmain-code\npdf_name = &quot;统计学习必学的十个问题&quot;img_path = _image_pathpdf_path = pdf_name + &quot;.pdf&quot;convert_images_to_pdf(img_path, pdf_path, get_size(), pages)\ndef-code\ndef get_size() :    &quot;&quot;&quot;    获取图片的宽高，来计算比例，用来合成PDF    :return:PDF的尺寸    &quot;&quot;&quot;    with open(_image_path + &quot;1.jpeg&quot;, &quot;rb&quot;) as f :        A4_MY = [0, 297 * mm]        f.seek(16)        w = bytes_to_long(f.read(4))        h = bytes_to_long(f.read(4))    bili = h / w    A4_MY[0] = (297 // bili) * mm    return A4_MYdef convert_images_to_pdf(img_path, pdf_path, size, pdf_count) :    &quot;&quot;&quot;    将图片合成为PDF    :param img_path:图片文件夹路径    :param pdf_path:PDF文件路径(包含PDF文件名)    :param size: PDF的尺寸    :param pdf_count: PDF的总页数    :return:    &quot;&quot;&quot;    pages = 0    (w, h) = size    c = canvas.Canvas(pdf_path, pagesize=portrait((w, h)))    l = os.listdir(img_path)    l.sort(key=lambda x : int(x[:-5]))      # 因为后缀都是.jpeg，所以是-5，对图片进行排序    for i in l :        f = img_path + os.sep + str(i)        c.drawImage(f, 0, 0, w, h)        c.showPage()        pages = pages + 1        print(&quot;添加进度: %f%%   \\r&quot; % ((pages / pdf_count) * 100))    c.save()\n添加书签\nmain-code\nadd_bookmark(bookmark, pdf_path)print(&quot;下载完成，时间:%.2f秒&quot; % (end - start))\ndef-code\ndef add_bookmark(bookmark, pdf_path) :    &quot;&quot;&quot;    书签的列表格式    无子书签： [name, num, 0]    有子书签: [name, num, [[child_name1, child_num1],[child_name2, child_num2]...... ]]    根据bookmark列表来对PDF文件添加书签    :param bookmark:    :return:    &quot;&quot;&quot;    # 读取PDF文件，创建PdfFileReader对象    book = PdfFileReader(pdf_path)    # 创建PdfFileWriter对象，并用拷贝reader对象进行初始化    pdf = PdfFileWriter()    pdf.cloneDocumentFromReader(book)    # 添加书签    # 注意：页数是从0开始的，中文要用unicode字符串，否则会出现乱码    # 如果这里的页码超过文档的最大页数，会报IndexError异常    for i in range(len(bookmark)) :        parent = pdf.addBookmark(bookmark[i][0], int(bookmark[i][1]) - 1)        if bookmark[i][2] != 0 :  # 如果有子书签            for j in range(len(bookmark[i][2])) :                pdf.addBookmark(bookmark[i][2][j][0], int(bookmark[i][2][j][1]) - 1, parent=parent)    # 保存修改后的PDF文件内容到文件中    # 注意：这里必须用二进制的&#x27;wb&#x27;模式来写文件，否则写到文件中的内容都为乱码    with open(pdf_path, &#x27;wb&#x27;) as fout :        pdf.write(fout)\n运行登陆模块后的main代码\ndataQueue = queue.Queue(155)  # 初始化队列try :    time.sleep(4)    pages = 155    print(&quot;总页数为%d&quot; % pages)  # 获取书本总页数    for i in range(BEGIN_PAGE, pages, 2) :        list = input_action(browser, i, False)        download_image(list[0], i, dataQueue)        download_image(list[1], i + 1, dataQueue)        print(&quot;下载进度: %f%%   \\r&quot; % ((i / pages) * 100))    if pages % 2 == 1 :  # 如果是奇数的话，最后一页没有下载        text = input_action(browser, pages, True)        download_image(text, pages, dataQueue)    while not dataQueue.empty() :        index = dataQueue.get(False)        b_text = input_action(browser, index, True)        download_image(b_text, index, dataQueue)    end = time.time()    print(&quot;-------------下载图片完毕-------------&quot;)    # 开始获取尺寸    bookmark = download_bookmark(bookmark_action(browser))  # 打开目录，准备下载书签    print(&quot;下载书签完毕&quot;)    pdf_name = &quot;统计学习必学的十个问题&quot;    img_path = _image_path    pdf_path = pdf_name + &quot;.pdf&quot;    convert_images_to_pdf(img_path, pdf_path, get_size(), pages)    # 添加书签    add_bookmark(bookmark, pdf_path)    print(&quot;下载完成，时间:%.2f秒&quot; % (end - start))finally :    browser.close()\n","categories":["爬虫"]},{"title":"流程图与伪代码","url":"/2022/02/11/%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%8E%E4%BC%AA%E4%BB%A3%E7%A0%81/","content":"流程图 Flowchart\nWhat is flowchart?\nA flowchart is a schematic representation of an algorithm or process that tell how to complete a task.\n程序流程图又称程序框图，是用统一规定的标准符号描述程序运行具体步骤的图形表示。\nHow to use flowchart?——symbol\n\n\n\n\n\n\nHow to use flowchart?——structure\n1）顺序结构\n这种结构最简单，各个步骤是按先后顺序执行的。如图，A、B、C是三个连续的步骤，它们是按顺序执行的，即完成上一个框中指定的操作才能再执行下一个动作。\n\n\n\n2） 选择结构\n选择结构又称分支结构，用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。\n\n\n\n3）循环结构\n循环结构又称为重复结构，指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。\n根据判断条件，循环结构又可细分为以下两种形式：先判断后执行的循环结构（当型结构），和先执行后判断的循环结构（直到型结构）。\n\n\n\nHow to use flowchart?——path/arrow\n除了符号规划、结构规划，绘制流程图过程中还要注意一些约定俗成的路径规划，比如\n1）绘制流程图时，为了提高流程图的逻辑性，应遵循从左到右、从上到下的顺序排列。\n2）一个流程从开始符开始，以结束符结束。开始符号只能出现一次，而结束符号可出现多次。若流程足够清晰，可省略开始、结束符号。\n3）同一流程图内，符号大小需要保持一致，同时连接线不能交叉，连接线不能无故弯曲。\n4）流程处理关系为并行关系的，需要将流程放在同一高度。\n5）处理流程须以单一入口和单一出口绘制，同一路径的指示箭头应只有一个。\n\n\n\nAnnotation\n\n\n\nParallel\n\n\n\nExample\n\n\n\n制作软件\n\nvisio\nprocesson\n\n伪代码 Pseudocode\nWhat is Pseudocode?\nPseudocode is a simpler version of a programming code in plain English before it is implemented in a specific programming language. Pseudocode is often referred to as a syntactical representation of a program and it doesn't have a strict syntax since it only represents the way we're thinking.\n\n伪代码是在以特定编程语言实现之前的简单英语编程代码的更简单版本。 伪代码通常被称为程序的语法表示，它没有严格的语法，因为它只表示我们的思维方式。\n\nWhy use pseudocode?\nPseudocode abstracts away syntax to let you focus on solving the problem in front of you. So instead of getting bogged down in the exact syntax of a language, pseudocode allows you to work almost impure programming logic. This way you don't actually have to know what exact built-in functions a programming language provides, you can simply write down in plain English what it is you're trying to do.\n\n伪代码抽象出语法，让您专注于解决您面前的问题。 因此，伪代码可以让您使用几乎不纯的编程逻辑，而不是陷入语言的确切语法中。 这样，您实际上不必知道编程语言提供了哪些确切的内置函数。 您可以简单地用日常的英语写下您想要做什么。\n\nIt essentially helps us break down large problems into smaller manageable pieces through this. Running pseudocode allows you to think through a problem with some foresight and lets you anticipate important questions before they arise. It is actually saving some time and headaches along the way and breaking things down with pure programming logic, and then googling or researching what you need to look for will essentially help you in becoming a better programmer.\n\n它本质上帮助我们把大问题分解成更小的可管理的部分。 运行伪代码可以让您有远见地思考问题，并在重要问题出现之前预测它们。 它实际上节省了一些时间和痛苦，并用纯编程逻辑分解事情，然后谷歌搜索或研究你需要寻找的内容将帮助你成为一个更好的程序员。\n\nHow to write pseudocode?\n\nCapitalize key commands (IF numbers is &gt; 10 THEN) \\(\\rightarrow\\)​ create code blocks and actually spots some of the logic\nWrite one statement per line\nUse indentation keep \\(\\rightarrow\\) different components of your pseudocode isolated\nBe specific\nKeep it simple \\(\\rightarrow\\) even for a layman or a client\n\nExample\nWrite a program that prints the number from 1 to 20 . For multiples of three print \"Fizz\" instead of the number. For the multples of five print \"Buzz\" instead of the number. For numbers which are multiples of both three and five print \"FizzBuzz\". For numbers not divisible by 3, or 5, or both, print the number as is.\nFOR LOOP:Set counter to 1Break when counter reaches 20Increment counter by 1\tIF number MOD 15  == 0\t\tprint &#x27;FizzBuzz&#x27;\tELSE IF number MOD 3 == 0\t\tprint &#x27;Fizz&#x27;\tELSE IF number MOD 5 == 0\t\tprint&#x27;Buzz&#x27;\tELSE\t\tprint number\nAnother version\n规则：\n\n在伪代码中，每一条指令占一行(else if 例外)，指令后不跟任何符号；\n“缩进”表示程序中的分支程序结构（同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进）；\n通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上行号，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤；\n每一行可以加上编号（也可不加）。\n\n1.变量的声明\n算法中出现的数组、变量可以是以下类型：整数、实数、字符、字符串或指针。定义变量的语句不用写出来，但必须在注释中给出。\n2.指令的表示\n在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。\n3.表达式\n算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符 = 、≠、&lt;、&gt;、≤ 和 ≥，以及逻辑运算符与(and)、或（or）、非（not）。\n4.赋值语句\n赋值语句是如下形式的语句：a←b。 这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。\n变量交换：若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。\n5.goto语句\ngoto语句具有形式：\ngoto label（goto标号）\n它将导致转向具有指定标号的语句。\n6.分支结构\n条件语句：\nif i=10    then xxxx    else xxxx //else 和 then 要对齐       //或者if i=10    then xxxx //if 后面必定跟上then，else后面不用跟then    else if i=9 //elseif 要连在一起写        then xxxx        yyyy    else  xxxx //else 跟在 elseif 的 then 对齐\n7.循环结构\n有两种循环指令：while和for。\nwhile语句的形式是：\nwhile time&lt;10    do  xxxxx //while后面必定要紧跟缩进的do    xxxxx    end\nfor语句的形式是：\nfor var init to limit by incr \tdo send\n这里var是变量，init、limit和incr都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若incr≥0，则只要var≤limit，就执行s并且将incr加到var上。（假若incr&lt;0，则只要var≥limit，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。\n8.程序的结束\nexit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。exit导致转向到紧接在包含exit的（最内层）while或者for循环后面的一个语句。\nreturn用来指出一个算法执行的终点；如果算法在最后一条指令之后结束，它通常是被省略的；它被用得最多的场合是检测到不合需要的条件时。return的后面可以紧接被括在引号的信息。\n9.注释风格\n算法中的注释被括在 /* */ 之中。\n10.函数的编写\n函数的伪代码格式例子为：search（A，name）， 参数类型可以不给出，但必须在注释中说明。\nExample\n//伪代码x ← 0y ← 0z ← 0while x &lt; Ndo x ← x + 1y ← x + yfor t ← 0 to 10do z ← ( z + x * y ) / 100repeaty ← y + 1z ← z - yuntil z &lt; 0z ← x * yy ← y / 2  //代码x = y = z = 0;while( z &lt; N )&#123;   x ++;　　y += x;　　for( t = 0; t &lt; 10; t++ )　　&#123;　　     z = ( z + x * y ) / 100;　　     do 　　     &#123;\t\t\ty ++;\t\t\tz -= y;　　     &#125; while( z &gt;= 0 );    &#125;　　z = x * y;&#125;y /= 2;\n参考自\n\nYoutube：Introduction to Creating Flowcharts\n专栏：知乎专栏：流程图绘制\nYouTube: What is pseudocode and how do you use it?\n博客：学会写伪代码\n博客：科研基础3-伪代码规范-latex\n\n","categories":["编程思维"]},{"title":"第1章 日常用语的骗局","url":"/2022/02/13/%E7%AC%AC1%E7%AB%A0-%E6%97%A5%E5%B8%B8%E7%94%A8%E8%AF%AD%E7%9A%84%E9%AA%97%E5%B1%80/","content":"\n  我只知道它言之无理，却讲不出所以然。\n\n基本原则\n首先是一些基本原则。我们不能称之为规律，它们不过是一些行为模式的描述，大致概括了人类反应和思考的倾向方式。比如，人们会：\n\n倾向于相信自己愿意相信的事物。\n倾向于将自身的偏爱或经验投射于现实生活。\n倾向于对特殊事件进行普遍化概括。\n倾向于身临其境地分析事件并且让自身情感超越客观理性。\n不能作为很好的聆听者。人们会有选择地听，并且常常只听自己想听的内容。\n拥有对所观察到的事物进行合理化(文饰)的冲动。\n常常无法从无关紧要的事物中提取相关、重要的事物。\n很容易从正在处理的特定事情上转移注意力。\n通常不愿意彻底地探索主题的盘根错节，倾向于过度简单化。\n一般都以貌取人。人们观察事物时，曲解自己的观察，然后做出可怕的误判。\n总是不知所谓，尤爱泛泛而谈。说话之前很少审慎思考，却让情感、偏见、成见、好恶、希望和挫折代替审慎思考。\n很少坚持一贯的行为准则。人们很少仔细检查证据然后得出结论。相反，人们更倾向于想怎么做就怎么做，想相信什么就相信什么，然后找出能够支持自己行动或信念的证据。人们的思考具有选择性：在评估现实情况时，热衷于寻找支持自己所支持事物的理由，同样热衷于忽视或者漠视不支持他们所支持事物的理由。\n人们往往不会将内心的本意宣之于口，而说出的话通常别有深意。\n\n观察评论\n针对这些原则，我们再加上由J.A.C.布朗 (J.A.C.Brown) 在《说服的技巧》(Techniques of Persuasion)一书中所引用的四条观察评论：\n①大多数人宁愿觉得事情简单而不复杂。\n②希望自己的偏见得到证实。\n③想要体验其他人无法企及的“归属感”。\n④需要为自己的挫败精确指定背黑锅的假想敌。\n未经训练的大脑更容易选择阻力最小的道路。阻力最小的道路就是几乎从不运用理性思考。\n","categories":["有毒的逻辑"]},{"title":"矩阵求导与分子、分母布局","url":"/2022/02/05/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E4%B8%8E%E5%88%86%E5%AD%90%E3%80%81%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80/","content":"原文见：矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇）\n1 函数与标量、向量、矩阵\n考虑一个函数 \\[\n\\text{function}(\\text{input})\n\\]\n针对 \\(function\\) 的类型、\\(input\\) 的类型，我们可以将这个函数分为 \\(function\\) 不同的种类。\n1、 \\(function\\) 是一个标量\n我们称 \\(function\\) 是一个实值标量函数。用细体小写字母 \\(f\\) 表示。\n1.1 \\(input\\) 是一个标量\n我们称 \\(function\\) 的变元是标量。用细体小写字母 \\(x\\) 表示。\n例1： \\[\nf(x)=x+2\n\\]\n1.2 \\(input\\) 是一个向量\n我们称 \\(function\\) 的变元是向量。用粗体小写字母 \\(\\pmb{x}\\) 表示。\n例2：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\nf(\\pmb{x})=a_1x_1^2+a_2x_2^2+a_3x_3^2+a_4x_1x_2\n\\]\n1.3 \\(input\\) 是一个矩阵\n我们称 \\(function\\) 的变元是矩阵。用粗体大写字母 \\(\\pmb{X}\\) 表示。\n例3：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\nf(\\pmb{X})=a_1x_{11}^2+a_2x_{12}^2+a_3x_{21}^2+a_4x_{22}^2+a_5x_{31}^2+a_6x_{32}^2\n\\]\n\\[\n\\left\\{ \\begin{align*} \\frac{\\partial f}{\\partial x_1} &amp; = 2x_1+x_2 \\\\\\\\ \\frac{\\partial f}{\\partial x_2} &amp; = x_1+x_3 \\\\\\\\ \\frac{\\partial f}{\\partial x_3} &amp; = x_2 \\end{align*} \\right.\n\\]\n2、\\(function\\) 是一个向量\n我们称 \\(function\\) 是一个实向量函数 。用粗体小写字母表 \\(\\pmb{f}\\) 示。\n含义： \\(\\pmb{f}\\) 是由若干个 \\(f\\) 组成的一个向量。\n同样地，变元分三种：标量、向量、矩阵。这里的符号仍与上面相同。\n2.1 标量变元\n例4： \\[\n\\pmb{f}_{3\\times1}(x)= \\left[ \\matrix{ f_1(x)\\\\ f_2(x)\\\\ f_3(x)\\\\ } \\right] = \\left[  \\matrix{ x+1\\\\ 2x+1\\\\ 3x^2+1 } \\right]\n\\]\n2.2 向量变元\n例5：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\n\\pmb{f}_{3\\times1}(\\pmb{x})= \\left[ \\matrix{ f_1(\\pmb{x})\\\\ f_2(\\pmb{x})\\\\ f_3(\\pmb{x})\\\\ } \\right] = \\left[  \\matrix{ x_{1}+x_{2}+x_{3}\\\\ x_{1}^2+2x_{2}+2x_{3}\\\\ x_{1}x_{2}+x_{2}+x_{3} } \\right] \n\\]\n2.3 矩阵变元\n例6：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\n\\pmb{f}_{3\\times1}(\\pmb{X})= \\left[ \\matrix{ f_1(\\pmb{X})\\\\ f_2(\\pmb{X})\\\\ f_3(\\pmb{X})\\\\ } \\right] = \\left[  \\matrix{ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}+x_{11}x_{12}\\\\ 2x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}+x_{11}x_{12} } \\right]\n\\]\n3、\\(function\\) 是一个矩阵\n我们称 \\(function\\) 是一个实矩阵函数 。用粗体大写字母 \\(\\pmb{F}\\) 表示。\n含义： \\(\\pmb{F}\\) 是由若干个 \\(f\\) 组成的一个矩阵。\n同样地，变元分三种：标量、向量、矩阵。这里的符号仍与上面相同。\n3.1 标量变元\n例7： \\[\n\\pmb{F}_{3\\times2}(x)= \\left[ \\matrix{ f_{11}(x) &amp; f_{12}(x)\\\\ f_{21}(x) &amp; f_{22}(x)\\\\ f_{31}(x) &amp; f_{32}(x)\\\\ } \\right] = \\left[  \\matrix{ x+1 &amp; 2x+2\\\\ x^2+1 &amp; 2x^2+1\\\\ x^3+1 &amp; 2x^3+1 } \\right]\n\\]\n3.2 向量变元\n例8：设 \\(\\pmb{x}=[x_1,x_2,x_3]^T\\) \\[\n\\pmb{F}_{3\\times2}(\\pmb{x})= \\left[ \\matrix{ f_{11}(\\pmb{x}) &amp; f_{12}(\\pmb{x})\\\\ f_{21}(\\pmb{x}) &amp; f_{22}(\\pmb{x})\\\\ f_{31}(\\pmb{x}) &amp; f_{32}(\\pmb{x})\\\\ } \\right] = \\left[  \\matrix{ 2x_{1}+x_{2}+x_{3} &amp; 2x_{1}+2x_{2}+x_{3} \\\\ 2x_{1}+2x_{2}+x_{3} &amp; x_{1}+2x_{2}+x_{3} &amp; \\\\ 2x_{1}+x_{2}+2x_{3} &amp; x_{1}+2x_{2}+2x_{3} &amp; } \\right]\n\\]\n3.3 矩阵变元\n例9：设 \\(\\pmb{X}_{3\\times 2}=(x_{ij})_{i=1,j=1}^{3,2}\\) \\[\n\\begin{align*} \\pmb{F}_{3\\times2}(\\pmb{X})&amp;= \\left[ \\matrix{ f_{11}(\\pmb{X}) &amp; f_{12}(\\pmb{X})\\\\ f_{21}(\\pmb{X}) &amp; f_{22}(\\pmb{X})\\\\ f_{31}(\\pmb{X}) &amp; f_{32}(\\pmb{X})\\\\ } \\right]\\\\\\\\ &amp;= \\left[  \\matrix{ x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 2x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ 3x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 4x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32}\\\\ 5x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} &amp; 6x_{11}+x_{12}+x_{21}+x_{22}+x_{31}+x_{32} } \\right] \\end{align*}\n\\]\n4、总结\n\n\n\nFunction\\input\n标量变元\n向量变元\n矩阵变元\n\n\n\n\n实值标量函数\n\\(f(x)\\)\n\\(f(\\pmb{x})\\)\n\\(f(\\pmb{X})\\)\n\n\n实向量函数\n\\(\\pmb{f}(x)\\)\n\\(\\pmb{f}(\\pmb{x})\\)\n\\(\\pmb{f}(\\pmb{X})\\)\n\n\n实矩阵函数\n\\(\\pmb{F}(x)\\)\n\\(\\pmb{F}(\\pmb{x})\\)\n\\(\\pmb{F}(\\pmb{X})\\)\n\n\n\n2 矩阵求导的本质\n对于一个多元函数\n例10： \\[\nf(x_1,x_2,x_3)=x_1^2+x_1x_2+x_2x_3\n\\] 我们可以将 \\(f\\) 对 \\(x_1,x_2,x_3\\) 偏导分别求出来，即： \\[\n\\left\\{ \\begin{align*} \\frac{\\partial f}{\\partial x_1} &amp; = 2x_1+x_2 \\\\\\\\ \\frac{\\partial f}{\\partial x_2} &amp; = x_1+x_3 \\\\\\\\ \\frac{\\partial f}{\\partial x_3} &amp; = x_2 \\end{align*} \\right. \n\\]\n矩阵求导也是一样的，本质就是 \\(function\\) 中的每个 \\(f\\) 分别对变元中的每个元素逐个求偏导，只不过写成了向量、矩阵形式而已。\n我们把得出的3个结果写成列向量形式： \\[\n\\frac{\\partial f(\\pmb{x})}{\\partial \\pmb{x}_{3\\times1}}= \\left[ \\matrix{ \\frac{\\partial f}{\\partial x_1}\\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\frac{\\partial f}{\\partial x_3}\\\\ } \\right] = \\left[  \\matrix{ 2x_1+x_2\\\\ x_1+x_3\\\\ x_2 } \\right]\n\\] 一个矩阵求导以列向量形式展开的雏形就出现了。\n当然我们也可以以行向量形式展开： \\[\n\\frac{\\partial f(\\pmb{x})}{\\partial \\pmb{x}_{3\\times1}^T}=  \\left[  \\frac{\\partial f}{\\partial x_1}, \\frac{\\partial f}{\\partial x_2}, \\frac{\\partial f}{\\partial x_3}  \\right]  =  \\left[   2x_1+x_2, x_1+x_3, x_2  \\right]\n\\] 所以，如果 \\(function\\) 中有 \\(m\\) 个 \\(f\\) ，变元中有 \\(n\\) 个元素，那么，每个 \\(f\\) 对变元中的每个元素逐个求偏导后，我们就会产生 \\(m\\times n\\) 个结果。至于结果的布局，是写成行向量，还是写成列向量，还是写成矩阵，就是我们接下来要讨论的事情。\n3 矩阵求导结果的布局\n不严谨地说，从直观上看：分子布局，就是分子是列向量形式，分母是行向量形式；分母布局，就是分母是列向量形式，分子是行向量形式。\n不同类型的变元，严谨的布局说明见原文：矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇）\n补充：来自机器学习中的矩阵和向量的求导\nx表示n维向量，X表示m×n维度的矩阵,y表示m维向量，Y表示p×q 维度的矩阵。\n\n\n\n解释几点：\n\n对于一个复杂的变量求导的时候，比如复合函数求导涉及到后面要讲的链式求导时候，只能选一种求导布局，不能同时出现分子布局和分母布局,分子布局与分母布局算出的结果只相差一个转置\n列向量y对列向量x的求导的分子布局形式可以理解为，分子向量y对分母向量x的第一个标量元素求导后排在第一列，对第二个标量元素求导后排在第二列，以此类推，排成一个m×n的矩阵。 也被称为雅克比矩阵：\n\n\n\n图中的默认布局是指常用的布局形式(向量和矩阵在分子上就用分子布局，否则用分母布局)，也是符合大家习惯的写法。\n\n4 分子布局、分母布局的本质\n总结：\n1、分子布局的本质：分子是标量、列向量、矩阵向量化后的列向量；分母是标量、列向量转置后的行向量、矩阵的转置矩阵、矩阵向量化后的列向量转置后的行向量。\n2、分母布局的本质：分子是标量、列向量转置后的行向量、矩阵向量化后的列向量转置后的行向量；分母是标量、列向量、矩阵自己、矩阵向量化后的列向量。\n思考一下，其实可以再简洁一些：谁转置了，就是另一方的布局。分子转置了，就是分母布局；分母转置了，就是分子布局。\n","categories":["数学基础"]},{"title":"第2章 感性的语言","url":"/2022/02/14/%E7%AC%AC2%E7%AB%A0%E6%84%9F%E6%80%A7%E7%9A%84%E8%AF%AD%E8%A8%80/","content":"\n  越是坏事，越能说出好的道理来。\n\n我们都有情感的需要：爱的需要、被爱的需要、被接受的需要、体验成就感的需要、体验自我价值的需要、体会自身重要性的需要、感到被人需要的需要、能够保护自己的需要、获取自己眼中的相应地位和其他人眼中的相应地位的需要，以及安全感的需要。这些需要依次隐含了其他情感：爱、恨、恐惧、嫉妒、愤怒、愧疚、贪婪、希望和忠诚。情感既脆弱又敏感。它们很容易被入侵，也很容易被操纵。只要有人懂得如何诉诸我们的情感，就能欺骗我们，操纵我们，并且让我们把谬误当作真理来接受。\n以下就是为达到欺骗理性的目的而蹂躏情感的几种手段。如果我们能够辨认出它们，就有可能避免受到欺骗和操纵。\n诉诸怜悯\n有人求助于我们的同情心、慈悲和友爱，而不是拿出有案可查的严密推理、证据或事实。他们给我们展示一张瘦骨嶙峋的儿童的照片、一位营养不良的受害者，使得我们不得不拿出一大笔钱捐献给为养活饥饿儿童而建立的基金会。如今这样的诉求并没有什么本质上的错误。但是我们不应该太天真，居然相信我们的捐赠都能实实在在地用来养活饥饿的儿童。那些捐赠有多少会用于行政管理，有多少会用于其他广告宣传，又有多少会用于支付基金高管们的高薪？此种诉诸怜悯的关键问题在于，它并没有告诉我们捐赠会被如何使用，甚至都不能保证我们的捐赠能被用于当初所诉求的目的。\n诉诸罪恶感\n让我们回顾前一个例子。有人给我们展示了一张饥饿儿童的图片，然后又给我们展示了另一张温馨的家庭聚餐图片。“你们衣食无忧，”宣传语这样写着，“你们什么都不缺。比起全世界上百万的挨饿人群，你们心安理得。”我们因为生活舒适而被动地产生罪恶感。此外，它还暗示甚至可以说是明示：如果不捐款，我们的罪恶感更强。以后享用晚餐时，我们会不自觉地想起饥饿的儿童。这样的情景会一直萦绕在心中，直到我们捐款为止。\n对于这样的诉诸罪恶感有三点需要说明。\n第一，任何人无权践踏我们的情感天平。\n第二，除非能给出充足的理由支持我们应该有罪恶感的推测，否则此种推测无足轻重。\n第三，就算我们有罪恶感，也没有任何理由去做宣传所鼓吹的事情，因为仍然无法保证我们的捐赠会带来任何明显的好处。\n诉诸恐惧则试图恐吓我们，让我们做出特定的行为或者接受特定的信念。“如果你不照做X事情，就会发生Y事情。”当然，Y事情的后果非常可怕。“如果你不先杀死敌人，敌人就会先干掉你。”但是，为证明此命题正确有效，表述者有义务证明X事件和Y事件之间的确切因果关系。有时候诉诸恐惧是私下形成的。\n诉诸希望\n“如果你做了X事情，Y事情就有可能发生；如果你想要Y事情发生，就去做X事情吧。”但是，说这话的人既无法保证Y事情一定会发生，也没有任何好的理由证明X事情对Y事情有显著影响。州彩票活动就是利用这一手段。人人都想赢得十万美金，一旦听说有人中了奖，尤其是当配合使用“这也能发生在你身上”的营销说辞，这种希望所带来的感觉会令人忘记真正买到中奖彩票的机会是多么渺茫。\n诉诸恭维\n如果有人恭维我们，我们就会容易混淆对于恭维者的好感和恭维者真正表达的意思。贝丝恭维乔治，乔治享受贝丝的恭维，因此乔治对贝丝的一切都有正面倾向，也更加容易顺从贝丝的立场。但是，请注意，贝丝并没有提供任何正当的理由让乔治接受她的观点。\n诉诸地位\n有些人非常在意社会地位。他们炫耀这个是Gucci牌的，那个是Pucci牌的，他们开国外名车，他们无论买什么东西，名牌商标总是最重要的。这些人觉得，财富外露会让他们显得更加重要、更加与众不同、更加优雅或更加精明老练。这些人更容易受到声称能提高社会地位的诉求蛊惑：“充分彰显你独一无二的品位”是为一支150美元的圆珠笔打广告。毋庸置疑，一个人独特地位的取得是靠他的行为而不是靠他使用的产品。但这些人对烤鸡配米饭不屑一顾，却对arrozconpollo（西班牙语：西班牙米烧鸡）趋之若鹜。\n诉诸潮流\n此种诉求有些类似于诉诸地位，但不同之处在于，它诉诸我们内心渴望的归属感、不落人后。我们被鼓励到国外旅游，因为一切有品位的人都这么做。我们被鼓励到乡村买宅邸，因为我们的邻居有乡间别墅。日常生活中，“如果有一千万的家庭主妇使用Sparkle产品，你不是也应该使用Sparkle产品吗！”又是如此，像所有的感性诉求一样，我们去国外、买乡间别墅或者使用Sparkle的产品并没有合理的理由。唯一的理由就是不甘人后。\n诉诸信任\n有人说你不赞同他就意味着你不爱他或者不信任他。“要么与我同一阵线，要么与我为敌！”“如果你以前真正地信任我，你早该和我在一起了。”这种手段并不公平。你赞成一个人与否，与你对此人的喜爱毫无瓜葛。不与某人为伍并不意味着你不爱某人或者不信任某人。在接受任何思想路线或者同意任何行动方案之前，你应该首先确定接受或者同意的理由。否则你的行为可能是不负责任的。此类感性诉求有个共同的名称——诉诸友情。我们应该记得，真正的友情有时候需要我们投反对票。\n诉诸自豪或忠诚\n“如果你真的为自己的国家感到自豪，真的想看到它繁荣富强，那就买储蓄债券吧。”“你什么意思——你一张教会抽奖券都不买吗？你想干什么，反对教会吗？”“你再也不带我出去吃饭了，你就是嫌弃我，你再也不爱我了。”诉诸自豪或忠诚通常是一种令人眩目的过度简单化。不购买储蓄债券并不意味着对国家不忠诚。不购买抽奖券并不意味着对教会不忠诚。不带妻子出去吃饭并不意味着你不再以她为荣，或者不再爱她。诉诸真诚。此种诉求非常有效，尤其适用于演技派。这种人采用认真、诚挚、不出风头且绝对谦卑的语气，看上去此人说话绝对发自肺腑，他频频止声，仿佛很难找到合适的词语表达他的下一想法。他的感情是如此深沉，以至于一般的语言无法表达。他不断地重复字词以示强调。加强语气的动词形式（以语气助词does和do的形式）和副词——真实地（really）、千真万确地（genuinely）、实实在在地（truly）、绝对无疑地（absolutely）、实事求是地（actually）——都是用来加强真诚感。\n诉诸群众\n最后一个感性诉求可能涵盖了许多本章提到的其他诉求，也许是大部分诉求。这是对群众的诉求，对暴民的诉求，对议会旁听者的诉求。一概而论、陈腔滥调、标语口号、老生常谈、道貌岸然地哗众取宠以及歌颂大众等泛滥成灾。\n最后，有一点必须反复申明，感性诉求并非本身有错。有时候，这样的诉求只是反映了内心深处的感受或者信念。那位妻子也许真的被她心里认为“丈夫冷落自己”给伤害了，在她对自尊进行感性诉求时，情感自然流露出来。那位机修工有可能真的认为你的传动装置即将导致严重问题，他可能把诉诸恐惧作为一种便捷的手段，让你做出他认为必要的防备。而道奇欧米尼也许就是一部绝世好车。重要的是，你要认识到感性诉求可能反映了某些未言明的感受或信念，还留有一条底线未被明确地表达，或者还有一条隐藏的事项未被确认。一方面，也许那位试图说服你购买教会抽奖券的人是真的很想帮助教会；另一方面，也许他只是想完成抽奖券配额任务。永远记得找出什么是底线，或者探明隐藏的事项。感觉很重要，但人不能只依赖感觉行事。行动必须要有理性。正是由于理性的含糊不清，感性诉求才变得危险。\n","categories":["有毒的逻辑"]},{"title":"第3章 感性的语言：宣传鼓动","url":"/2022/02/15/%E7%AC%AC3%E7%AB%A0%20%E6%84%9F%E6%80%A7%E7%9A%84%E8%AF%AD%E8%A8%80-%E5%AE%A3%E4%BC%A0%E9%BC%93%E5%8A%A8/","content":"\n  我了解你们人类。你们都是乖乖听话的羔羊。\n\n在广泛意义上，宣传鼓动只不过是一种说服手段，一种诉诸感性而非诉诸理性的形式。它依赖于人们对暗示的感受。它企图诱使我们以特 定的方式来行动或思考；它企图影响我们的信念并最终影响我们的态度。它的手段通常狡猾而隐秘。鼓吹者不会当面摊开他的手牌；有一个隐藏的动机，一条底线，隐而不发。\n成功的鼓吹者善于俘获我们的情感。他大量运用第2章所提到的感性诉求。他说着我们想听的话，赢取我们的信任，然后开始巧妙地影响我们的态度。鼓吹者几乎从不为其所倡导的内容提供完好的理由。即使他提供证据，也是精心选择之后的一面之词。他将事情过度简单化，并且常常任意歪曲事实。\n以下详细说明鼓吹者可能采取的一些策略。\n随波逐流。\n“大家都这么做。所以，你也应该这样做。”显然，此命题过度简单化，并不是大家都这么做。随波逐流策略至少发挥了两方面作用。\n\n第一，它企图造成一种印象，有许多人都在做某件事情或者支持某种立场；然后它暗示群众的判断是合理的：如果这么多人都这么做，那它一定是对的。\n第二，更重要的一点，随波逐流策略是满足我们内心归属需要的一种情感诉求。我们不想被别人抛弃。“所以，跳到乐队花车上来。融入狂欢的人潮，享受快乐和安全感。”\n\n不断重复。\n鼓吹者反复地诉说某事。他每次可能使用不同的措辞，但主题却始终如一。此种理论就是，如果你重复诉说的次数足够多，人们终究会相信你。\n自信。\n鼓吹者的谈吐也是自信满满的。他留给人的印象是知道自己在说什么。他的声音铿锵有力，他的表情大义凛然，他的肢体动作坚毅果敢。此处的理论如下：如果有人如此自信，如果他对自己的立场如此确信无疑，那他肯定是对的。人们喜欢支持胜利者，而自信的姿态使人看起来像个胜利者。\n认真和真诚。\n一个人外表看起来越是认真和真诚，越容易获得人们的信任。\n过度简单化。\n鼓吹者选取事物的一个方面，并且把它视为宛如仅有的一个方面。比如参与党派竞选的候选人可能只会提及对手的弱点，完全忽略对手的优势所在。他选取一个复杂的问题，然后将其简化到极致，通常以“要么......要么......”二者择其一的方式呈现该问题：“要么你跟随我，那样对大家都好，要么你不跟随我，那样必定损失惨重。”\n污名辱骂。\n鼓吹者对不喜欢的人物或者观点冠以污辱性的绰号，或者使用引起强烈贬损意味的名称；对喜欢的人物或观点，则致以谄媚般的称呼，或者使用引起强烈褒扬意味的名称。他打算用他的命名来影响我们的态度。他们有时候也会使用“标签”：“种族主义者”“无政府主义者”“社会主义者”“激进分子”“反动派”。\n刻板印象(心理定式)。\n这是污名辱骂和过度简单化的一种变式。鼓吹者抓住对方的某一性格特征，经过夸张变形，然后视之为唯一的性格特征。这个技巧曾被用来反对已故前副总统休伯特·汉弗莱，不断有人把他画成漫画形象的风囊(比喻饶舌之人)来进行讽刺。刻板印象剥夺一个人的复杂性和独特性，将其简化为一种品质。\n光芒万丈的泛泛而谈。\n鼓吹者发表大而无当、概括笼统的言论，通常这种言论会带来盘根错节、影响深远的复杂后果，而他却故意忽略这种复杂性和纠纷。他痛斥在野党剥削穷人，没有争取到有效的税制改革立法，但他本身却开不出良方。他沉浸在泛泛而谈的满足中，自鸣得意。光芒万丈的泛泛而谈很安全：如果连具体规划都没提供，又怎么会受到批评呢?\n标语口号。\n受众会记住讨巧的标语口号，而不去质疑标语口号本身的意义——实际上，甚至不会思考标语口号的意义：美国——要么爱，要么走开。要爱情而不要战争。如果枪械是不合法的，那只有不法之徒才能拥有枪械。\n传递。\n这个技巧鼓励我们将情感传递下去。香烟广告经常使用这种技巧。香烟总是一成不变地设计在一些豪华的田园风光里，放在一片深绿之中。然后还有万宝路牛仔和维珍妮香烟女郎：“宝贝，你真是远道而来。”传递的技巧在于它了解我们对自己土地的自豪感，我们向往田园的美丽风光，我们崇拜粗犷的万宝路牛仔和苗条的维珍妮香烟女郎，它邀请我们将积极正面的情感传递至所推销的主体上。\n代言。\n这是传递策略的一种变式。重要或杰出的人物或组织为一个观念或者产品代言。我们仅仅因为杰出的人物为其代言，而被鼓励去支持这种观念或者产品。该理论如下：X是一位重要人物；除非X更杰出或者比我们更有见识，否则他不会如此重要；既然X如此重要，因此他更杰出或者比我们更有见识；因此，他知道自己在说什么；因此，我们应该相信他。我们被鼓励将对此人的肯定传递至他背书的观念或者产品。\n平民百姓。\n“我和你们一样。”鼓吹者有时候企图通过我们对他的身份认同，从而赢得我们的支持。他参加镇民大会，拜访医院，不拘礼节地摆姿势拍照片。吉米·卡特总统就使用过这种技巧，当他在电视上露面时，他穿便装毛衣而不穿正装。这里的技巧被用于高尚的目标：节约能源。如果总统都能通过明智地选择穿衣而节约能源，我们难道不应该这样吗?\n宣传鼓动可以用于不光彩的目的，也可以用于高尚的目标。因此我需要再重复一遍定义：宣传鼓动仅仅是一种说服手段。平民百姓策略背后的理论认为，如果我们认同某人，我们就会支持他的说法。该策略是传递策略的一种变式。\n讲究派头的诉求。\n另一方面，宣传鼓动可能利用人们对社会地位的需求，或者利用人们对特殊待遇的渴望：“适合具有独特鉴赏能力的人群”“并非所有人都能拥有”“品质专为有品位的人”“一探高雅”“为在意的人，奉献最好的”......\n缺少背景知识的统计数据。\n鼓吹者可能给你提供大量的统计数据，但很少会告诉你这些数据的背景知识。他几乎不会告诉你他是如何收集这些数据的，数据来自哪里，或者有多少人参与了投票。只要找对五个人，你几乎可以让任何事情都收获80%的支持率。\n大数字。\n这是随波逐流(乐队花车)策略的一种变式。欧莱雅染发剂广告宣称：“全世界超过25万名美发师相信欧莱雅染发剂适合你，还需要多说什么?欧莱雅，25万名美发师绝不会错。”\n**人为捏造的困难——坏人，替罪羊。\n鼓吹者人为捏造困难或者夸大困难，企图让你相信问题如何严重，然后通过将问题归咎于某人，或者暗示他的建议可以解决困难，来为你排忧解难。鼓吹者常常需要一个坏人，一个牺牲品或替罪羊，供其强烈谴责。他的义愤填膺使其听起来真诚可靠，也让他所谈及的问题听起来越发严重而紧急。\n彻底扭曲。\n有时候鼓吹者筛选信息以呈现片面的观点；有时候他甚至编造数据以达到个人目的；有时候他就直接撒谎。由于我们不知道事实真相，我们就无法质疑他。由于我们无能为力，就像他背对着我们洗牌，而他却能看到底牌；因此，这个策略有时候被称为作弊洗牌法。\n指挥命令。\n这种策略有危险，因为它很容易适得其反。有些人很乐意按照指令行事。当鼓吹者发出指令，他就在诉诸渴望权威的需求。\n再次说明，这一点必须着重强调，就像感性诉求并非本身有错一样，宣传鼓动也无本质错误。但是，我们必须认识到宣传鼓动的本质，拒绝任其摆布。\n[1]刻板印象主要指人们对某个事物形成一种概括固定的看法，并把这种看法推而广之，认为这个事物或整体都具有该特征，而忽视个体差异。——译者注\n","categories":["有毒的逻辑"]},{"title":"机器学习数学基础：线性代数","url":"/2022/01/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","content":"本章介绍线性代数中向量、内积、范数、矩阵、线性变换、二次型、矩阵分解等基本知识。\n1 行列式\n线性代数中，行列式是一个函数，和矩阵有一定的关系。几何上，行列式可以看作有向面积或体积的概念在一般的欧几里得空间中的推广。\n1.1 二阶与三阶行列式\n可用来解决线性方程求解的问题，同时注意对角线法则只适用于二阶和三阶的行列式。\n表达式 \\[\nD=a_{11}a_{22}-a_{12}a_{21}=\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12}\\\\\n   a_{21} &amp; a_{22} \n  \\end{matrix}\n  \\right]\n\\] 称为数表的二阶行列式，记作 \\(D=det(a_{ij})\\) .\n三阶行列式定义为 \\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}\n\\]\n1.2 全排列和对换\n全排列的定义：由 \\(1\\) 到 \\(n\\) 个数组成的一个有序数组称为一个n级全排列，通常用 $ P_n$ 表示。 \\[\nP_n=n\\times (n-1)\\times \\dots\\times3\\times2\\times1=n!\n\\] 逆序数的定义：在一个排列中，如果两个数（称为数对）的前后位置与大小顺序相反，即前面的数大于后面的数，那么称它们构成一个逆序（反序）。一个排列中所有逆序的总数称为此排列的逆序数。分别计算出排在 \\(1,2,\\dots,n-1,n\\) 前面比它大的数码之和。 \\[\nt=t_1+t_2+\\dots+t_n=\\sum_{i=1}^nt_i\n\\] 此外，还有奇排列和偶排列的概念，即奇排列为逆序数为奇数的排列。\n对换的定义：在排列中，将任意两个元素对调，其余元素不动，就得到另一个排列，这样的一个变换叫作对换。将相邻的两个元素对换，叫作相邻对换。其中，一个排列中任意两个元素对换，排列改变奇偶性。\n1.3 n阶行列式\n\\[\n\\left[\n \\begin{matrix}\n   a_{11} &amp; a_{12} &amp; a_{13} \\\\\n   a_{21} &amp; a_{22} &amp; a_{23} \\\\\n   a_{31} &amp; a_{32} &amp; a_{33}\n  \\end{matrix}\n  \\right]=\\sum(-1)^ta_{11}a_{22}a_{33}\n\\]\n可推广至n阶，其中 \\(t\\) 为列标排列的逆序数。\n1.4 几种特殊行列式的值\n上、下三角行列式，对角行列式，特殊行列式（类似反的下三角行列式）\n如果是计算的是主对角线的值，则直接连乘；如果是副对角线，则需加一个系数 \\((-1)^{\\frac{n(n-1)}{2}}\\).\n一些其他的见知乎：https://zhuanlan.zhihu.com/p/34685081。\n1.5 n阶行列式的性质\n\n性质1：行列式与它的转置行列式相等。\n性质2：互换行列式的两列，行列式变号。（推论：两行或两列相同，此行列式等于零）。\n性质3：行列式的某一行（列）中所有元素都乘同一数 \\(k\\)，等于用数 \\(k\\) 乘此行列式。\n性质4：行列式中如果有两行（列）元素成比例，则此行列式等于零。\n性质5：若行列式的某一列（行）的元素都是两数 之和，则该行列式等于两个行列式之和。\n性质6：把行列式的某一列（行）的各个元素乘同一个数，然后加到另一列（行）对应的元素上去，行列式的值不变。\n\n2 用向量描述空间\n2.1 向量及其运算\n\\(n\\) 维空间用 \\(\\pmb{R}^n\\) 表示，上标 \\(n\\) 表示空间的维度。\n2.2 向量组的线性组合\n若干个同纬度的列向量（或同纬度的行向量）所组成的集合叫作向量组。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和一组实数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，那么表达式 \\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)称为向量组 $ $ 的一个线性组合。\n给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) 和向量 \\(\\pmb{b}\\)，如果存在一组数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得 \\(\\pmb{b}=\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m\\)，则向量 \\(\\pmb{b}\\) 是向量组 \\(\\pmb{A}\\) 的线性组合，这时称向量 \\(\\pmb{b}\\) 能由向量组 \\(\\pmb{A}\\) 线性表示，也就是对应的方程组有解。\n2.3 向量组的线性相关性\n向量组的线性相关性的定义：给定向量组 \\(\\pmb{A}:\\pmb{a}_1,\\pmb{a}_2,\\dots,\\pmb{a}_m\\) ，如果存在不全为0的数 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_m\\)，使得\\(\\lambda_1\\pmb{a}_1+\\lambda_2\\pmb{a}_2,\\dots,\\lambda_m\\pmb{a}_m=0\\)，则称向量组 \\(\\pmb{A}\\) 是线性相关的。\n线性相关的充要条件是：向量组中至少有一个向量可以由其他所有向量线性表示。\n3 内积、正交向量组和范数\n3.1 内积\n向量之间的乘法可分为内积和外积，一般用内积比较多。内积的直接描述为某一向量在另一个向量方向上的投影长度。\n内积的定义：设有 \\(n\\) 维向量 \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，\\(\\pmb{y}=\\left(\\begin{matrix}  y_1 \\\\  y_2\\\\ \\vdots \\\\ y_n  \\end{matrix}\\right)\\)，令\\(（\\pmb{x},\\pmb{y}）=x_1y_1+x_2y_2+\\dots+x_ny_n\\)，\\(（\\pmb{x},\\pmb{y}）\\)称为向量 \\(\\pmb{x}\\) 和向量 \\(\\pmb{y}\\) 的内积，也可以表示为 \\(\\pmb{x·}\\pmb{y}\\).\n3.2 正交向量组和施密特正交化\n正交向量的定义：如果两向量的内积为零，则称它们正交。\n正交向量组的定义：如果向量组中任意两个向量都正交且不含零向量，则称为正交向量组，并且正交向量组是线性无关的。\n标准正交向量：向量组内向量彼此之间的点积为 \\(0\\)，与自身的点积为 \\(1\\)。\n施密特正交化详见：\n如何理解施密特（Schmidt）正交化：https://zhuanlan.zhihu.com/p/136627868。\n3.3 范数\nwiki——矩阵范数\n向量范数的定义：如果向量 \\(\\pmb{a} \\in \\pmb{R}^n\\) 的某个实值函数 $f()=|||| $ 满足\n\n非负性：\\(||\\pmb{a}||\\geq 0\\) ，且\\(||\\pmb{a}||=0\\) 当且仅当 \\(\\pmb{a}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{a}||=|\\lambda|||\\pmb{a}||\\)\n三角不等式：对于任意 \\(\\pmb{a,b}\\in\\pmb{R}^n\\)，都有 \\(||\\pmb{a+b}||\\leq||\\pmb{a}||+||\\pmb{b}||\\)\n\n常用的向量范数有 $ 1$ -范数、\\(2\\) -范数和 \\(\\infty\\) -范数。\n\n$ 1$ -范数：也称为曼哈顿距离 \\[\n  ||\\pmb{a}||_1=\\sum_i^n|\\pmb{a}_i|\n  \\]\n\\(2\\) -范数：也称为欧几里得范数\n\n\\[\n||\\pmb{a}||_2=\\sqrt{\\sum_{i=1}^n\\pmb{a}_i^2}\n\\]\n\n\\(\\infty\\) -范数：所有向量元素中的最大值 \\[\n  ||\\pmb{a}||_\\infty=\\max_i|a_i|\n  \\]\n\n矩阵范数的定义：如果矩阵 \\(\\pmb{A} \\in \\pmb{R}^{n\\times n}\\) ，若按某一确定的法则对应于一个非负实数 $|||| $ 满足\n\n非负性：\\(||\\pmb{A}||\\geq 0\\) ，且\\(||\\pmb{A}||=0\\) 当且仅当 \\(\\pmb{A}=0\\)\n齐次性：对于任意实数 \\(\\lambda\\)，都有 \\(||\\lambda\\pmb{A}||=|\\lambda|||\\pmb{A}||\\)\n三角不等式：对于任意 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{A+B}||\\leq||\\pmb{A}||+||\\pmb{B}||\\)\n相容性：对于任意的 \\(\\pmb{A，B}\\in\\pmb{R}^{n\\times n}\\)，都有 \\(||\\pmb{AB}||\\leq||\\pmb{A}||||\\pmb{B}||\\)\n\n常用的矩阵范数有 $ 1$ -范数、\\(2\\) -范数、 \\(\\infty\\) -范数和 \\(F\\) -范数。\n\n$ 1$ -范数：又称为列和范数。顾名思义，即矩阵列向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_1=\\max_j\\sum_i^m|a_{ij}|\n  \\]\n\\(2\\) -范数：又称为谱范数，计算方法为 \\(\\pmb{A^TA}\\) 矩阵的最大特征值开平方。\n\n\\[\n||\\pmb{A}||_2=\\sqrt{\\lambda_1}\n\\]\n\n\\(\\infty\\) -范数：又称为行和范数。顾名思义，即矩阵行向量中绝对值之和的最大值。 \\[\n  ||\\pmb{A}||_\\infty=\\max_i\\sum_j^n|a_{ij}|\n  \\]\n\\(F\\) -范数：又称为Frobenius范数，计算方法为矩阵元素的绝对值的平方和再开方。 \\[\n||\\pmb{A}||_F=\\sqrt{\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|}\n\\]\n\n习题：Python编程实现求向量范数和矩阵范数。\n# -*- coding: UTF-8 -*-import numpy as npa=np.array([2,4,5,8,-3])print(&#x27;向量a：&#x27;,a)print (&#x27;向量a的1-范数:&#x27;)print(np.linalg.norm(a,ord=1))print (&#x27;向量a的2-范数:&#x27;)print(np.linalg.norm(a,ord=2))print (&#x27;向量a的∞-范数:&#x27;)print(np.linalg.norm(a,ord=np.inf))# -*- coding: UTF-8 -*-import numpy as npA=np.arange(3,15).reshape(3,4)print(&#x27;矩阵A：&#x27;,A)print(&#x27;矩阵A的1-范数:&#x27;)print(np.linalg.norm(A,ord=1))print(&#x27;矩阵A的2-范数:&#x27;)print(np.linalg.norm(A,ord=2))print(&#x27;矩阵的∞-范数:&#x27;)print(np.linalg.norm(A,ord=np.inf))print(&#x27;矩阵A的F-范数:&#x27;)print(np.linalg.norm(A,ord=&#x27;fro&#x27;))print(&#x27;矩阵A列向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=0))print(&#x27;矩阵A行向量的2-范数:&#x27;)print(np.linalg.norm(A,ord=2,axis=1))\n4 矩阵和线性变换\n4.1 矩阵及其运算\n一些不想敲的概念：\n\n矩阵的定义。\n特殊的矩阵：行矩阵（也叫行向量）、列矩阵（也叫列向量）、方阵（\\(\\pmb{A}_n\\)），三角矩阵、单位矩阵、对称矩阵、对角矩阵、实对称矩阵、零矩阵、正交矩阵。\n矩阵的运算：加法、数乘、乘法、转置、行列式（\\(|\\pmb{A}|\\) 或 \\(det(\\pmb{A})\\)).\n\n4.2 逆矩阵\n对于 \\(n\\) 阶矩阵 \\(\\pmb{A}\\) ，如果有一个 \\(n\\) 阶矩阵 \\(\\pmb{B}\\) ，使得 \\(\\pmb{AB=BA=E}\\)，则称矩阵 \\(\\pmb{A}\\) 是可逆的，并把矩阵 \\(\\pmb{B}\\) 称为 \\(\\pmb{A}\\) 的逆矩阵，记作 \\(\\pmb{A}^{-1}\\) .\n\n若矩阵 \\(\\pmb{A}\\) 可逆，则 \\(|\\pmb{A}| \\neq 0\\) .\n若 \\(|\\pmb{A}| \\neq 0\\)，则矩阵 \\(\\pmb{A}\\) 可逆，且 \\(\\pmb{A}^{-1}=\\frac{1}{|\\pmb{A}|}\\pmb{A}^*\\)，其中 \\(\\pmb{A}^*\\) 为矩阵 \\(\\pmb{A}\\) 的伴随矩阵。\n\n4.3 矩阵的初等变换\n\n对调两行\n数乘\n数乘再相加\n\n4.4 标量对向量的导数、最小二乘法\n\nxxds\n\n详见：\n系列：机器学习中的矩阵向量求导\n单列一个：机器学习中的矩阵向量求导(二) 矩阵向量求导之定义法\n最小二乘法及python代码：最小二乘法（least sqaure method）\n4.5 线性变换\n线性变换的定义：设 \\(\\pmb{V}\\) 为一个线性空间，映射 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个变换，若 \\(f\\) 保持 \\(\\pmb{V}\\) 的加法与数乘运算，则称 \\(f:\\pmb{V}\\rightarrow\\pmb{V}\\) 为 \\(\\pmb{V}\\) 的一个线性变换。\n线性变换把一个向量空间里的向量映射到了另一个向量空间里的另一个向量，因此，我们可以把线性变换理解成输入一个向量，然后输出一个向量的特殊函数。\n它可以看成一个动态的过程，比如旋转、伸缩或者投影之类的升降维的操作。\n常见的线性变换还有：恒等变换（单位变换）、求微商（线性空间 \\(P[x]\\) 内）、求定积分。\n详见：线性变换（一）【直观理解线性变换】\n4.6 矩阵的秩\n一些概念：矩阵的秩、行秩、列秩和极大无关向量组。\n定理：设 \\(n\\) 元线性方程组 \\(\\pmb{Ax=b}\\) ，\\(R(\\pmb{A})\\) 表示系数矩阵 \\(\\pmb{A}\\) 的秩，\\(R(\\pmb{A,b})\\) 表示增广矩阵 \\(\\pmb{B=(A,b)}\\) 的秩，则该线性方程组\n\n无解的充要条件是 : \\(R(\\pmb{A})&lt;R(\\pmb{A,b})\\)；\n有唯一解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})=n\\)；\n有无限多解的充要条件是： \\(R(\\pmb{A})=R(\\pmb{A,b})&lt;n\\) .\n\n一些概念：线性方程组的解、方阵的特征值和特征向量\n习题：Python编程实现求逆矩阵、行列式的值、秩\nimport numpy as np# a=np.array([[1,4,7],[2,5,8],[3,6,9]])# a=np.array([[1,2,3],[4,5,6]])A=np.array([[1,4,9],[2,5,8],[3,6,9]])print(&quot;A矩阵为：&quot;)print(A)print(&#x27;*&#x27;*40)F = np.linalg.inv(A)print(&quot;A矩阵的逆矩阵为：&quot;)print(F)print(&#x27;*&#x27;*40)print(&quot;A矩阵与其逆矩阵乘积为：&quot;)print(np.dot(A,np.linalg.inv(A)))print(np.dot(A,np.linalg.inv(A)).astype(int))print(&#x27;*&#x27;*40)print(&quot;A矩阵的行列式的值为：&quot;)print(np.linalg.det(A))print(&#x27;*&#x27;*40)print(&quot;A矩阵的秩为：&quot;)print(np.linalg.matrix_rank(A))\n5 二次型\n5.1 二次型的定义\n即二次齐次函数（\\(x^2,x_1x_2,\\dots\\)，类似平方项展开加上系数）。二次型的标准型可理解为只含平方项的二次型。\n若 \\(\\pmb{A}\\) 为对称矩阵， \\(\\pmb{x}=\\left(\\begin{matrix}  x_1 \\\\  x_2\\\\ \\vdots \\\\ x_n  \\end{matrix}\\right)\\)，则 \\(f=\\pmb{x^TAx}\\) 也是二次型的一种形式，对成矩阵 \\(\\pmb{A}\\) 叫作二次型 \\(f\\) 的矩阵，也把 \\(f\\) 叫作对称矩阵 \\(\\pmb{A}\\) 的二次型。对称矩阵 \\(\\pmb{A}\\) 的秩就叫做二次型 \\(f\\) 的秩。\n5.2 用正交变换化二次型为标准型\n\n将二次型 \\(f=\\sum_\\limits{i=1}^n\\sum_\\limits{j=1}^na_{ij}x_ix_j\\)，写成矩阵形式 \\(f=\\pmb{x^TAx}\\) .\n由 \\(|\\pmb{A-\\lambda E}|=0\\)，求出 \\(\\pmb{A}\\) 的全部特征值。\n由 \\((\\pmb{A-\\lambda E})\\pmb{x}=0\\)，求出 \\(\\pmb{A}\\) 的特征向量。\n\n对于求出的不同特征值所对应的特征向量已正交，只需要单位化；对于 \\(k\\) 冲特征值 \\(\\lambda\\) 所对应的 \\(k\\) 个线性无关的特征向量，用施密特正交化方法把它们化成 \\(k\\) 个两两正交的单位向量。\n\n把求出的n个两两正交的单位向量拼成正交矩阵 \\(\\pmb{P}\\)，作正交变换 \\(\\pmb{x=Py}\\).\n用 \\(\\pmb{x=Py}\\) ，把 \\(f\\) 化成标准型 \\(f=\\lambda_1y_1^2+\\lambda_2y_2^2+\\dots+\\lambda_ny_n^2\\)，其中 \\(\\lambda_1,\\lambda_2,\\dots,\\lambda_n\\)是矩阵 \\(\\pmb{A}=(a_{ij})\\) 的特征值。\n\n5.3 二次型的正定型\n正定二次型、惯性定理、和赫尔维茨定理（后两个是判定定理）。\n麻省理工线性代数笔记（二十四）-正定矩阵\n6 矩阵分解\n矩阵分解有很多种，如 \\(LU\\) 分解、\\(QR\\) 分解、特征值分解（\\(EVD\\) ）和奇异值分解（\\(SVD\\) ）。\\(LU\\) 分解是将满秩矩阵分解为两个倒扣的三角形，即分解成下三角矩阵和上三角矩阵的乘积，它的意义在于求解大型方程组。QR分解经常用来解线性最小二乘法问题，它和机器学习的相关算法密切。特征值分解的方法也非常有效，但有一些局限性，即要求矩阵必须是方阵且能够被对角化。奇异值分解可以对任意形状的矩阵进行分解，实用性更广。\n麻省理工线性代数笔记（二十六）-奇异值分解\n【学长小课堂】什么是奇异值分解SVD--SVD如何分解时空矩阵\n\n\n\n李航统计学习之奇异值分解（SVD）\n习题：实现矩阵的QR分解\nimport numpy as npM= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)Q=np.zeros((4, 3))j = 0for a in M.T:    b = np.copy(a)    for i in range(0, j):        b = b - np.dot(np.dot(Q[:, i].T, a), Q[:, i])    e = b / np.linalg.norm(b)    Q[:, j] = e    j += 1R = np.dot(Q.T, M)np.set_printoptions(precision=3,suppress=True)print(&#x27;Gram-schmidt正交化变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))#方法二import numpy as npnp.set_printoptions(precision=4, suppress=True)M= np.array([[12,9,-45],[7,4,15],[6,-3,21],[6,18,5]],dtype=float)s = 4t = 3Q = np.identity(s)R = np.copy(M)for j in range(s - 1):    x = R[j:, j]    E = np.zeros((4, 3))    E = np.zeros_like(x)    b = x - E    d = b / np.linalg.norm(b)    Q_j = np.identity(s)    Q_j[j:, j:] -= 2.0 * np.outer(d, d)    R = np.dot(Q_j, R)    Q = np.dot(Q, Q_j)np.set_printoptions(precision=3,suppress=True)print(&#x27;Householder变换结果&#x27;)print(&#x27;Q矩阵：&#x27;)print(Q)print(&#x27;R矩阵：&#x27;)print(R)print(&#x27;矩阵的乘积：&#x27;)print(np.dot(Q,R))\nQ：奇异值分解的应用场景有哪些?\n\\(SVD\\) 的应用有很多，可以说，\\(SVD\\) 是矩阵分解、降维、压缩、特征学习的一个基础工具，所以 \\(SVD\\) 在机器学习领域相当的重要。\n\\(SVD\\) 在降维中作用如何呢？通过 \\(SVD\\) 的公式可以看出，原来矩阵 $ $ 的特征有 \\(n\\) 维，经过 \\(SVD\\) 后，可以用前 \\(r\\) 个非零奇异值对应的奇异向量表示矩阵\\(\\pmb{A}\\) 的主要特征，这样就把矩阵 $ $ 进行了降维。\n\\(SVD\\) 在压缩中作用如何呢？机器学习最基本和最有趣的特征之一是数据压缩概念的相关性。如果我们能提取有用的数据，我们就能用更少的比特位来表达数据。从信息论的观点来看，数据之间存在相关性，则有可压缩性。通过 \\(SVD\\) 的公式可以看出，矩阵 $ $ 经过 \\(SVD\\) 后，要表示原来的大矩阵 $ $ ，我们只需要存储 \\(\\pmb{U,\\Delta,V}\\) 三个较小的矩阵即可。而这 \\(3\\) 个较小规模的矩阵占用内存上也是远远小于原有矩阵 $ $ 的，这样 \\(SVD\\) 就起到了压缩的作用。\n\\(SVD\\) 和主成分分析有什么关系呢？\\(PCA\\) 即主成分分析方法，是一种使用最广泛的数据降维算法。\\(PCA\\) 的主要思想是将n维特征映射到 $ m$ 维上，这 \\(m\\) 维是全新的正交特征，也被称为主成分，是在原有 \\(n\\) 维特征的基础上重新构造出来的 \\(m\\) 维特征。\\(PCA\\) 的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。\\(PCA\\) 算法有两种实现方法，即基于特征值分解协方差矩阵实现 \\(PCA\\) 算法和基于 \\(SVD\\) 协方差矩阵实现 \\(PCA\\) 算法。所以，\\(SVD\\) 是 \\(PCA\\) 算法的一种实现方法。\n我们再来看一下潜在语义索引，它是一种简单实用的主题模型。潜在语义索引是一种利用 \\(SVD\\) 方法获得在文本中术语和概念之间关系的索引和获取方法。该方法的主要依据是在相同文章中的词语一般有类似的含义，可以从一篇文章中提取术语关系，从而建立起主要概念内容。潜在语义索引不同于 \\(PCA\\) ，至少不是实现了 \\(SVD\\) 就可以直接用的，但它也是一个高度依赖 \\(SVD\\) 的算法。\n","categories":["机器学习数学基础"]},{"title":"Bonuses","url":"/2022/02/18/Bonuses/","content":"Bonuses\nJohn wants to give a total bonus of $851 to his three employees taking fairly as possible into account their number of days of absence during the period under consideration. Employee A was absent 18 days, B 15 days, and C 12 days.\nThe more absences, the lower the bonus ...\nHow much should each employee receive? John thinks A should receive $230, B $276, C $345 since 230 * 18 = 276 * 15 = 345 * 12 and 230 + 276 + 345 = 851.\nTask\nGiven an array arr (numbers of days of absence for each employee) and a number s (total bonus) the function bonus(arr, s) will follow John's way and return an array of the fair bonuses of all employees in the same order as their numbers of days of absences.\ns and all elements of arr are positive integers.\nExamples\nbonus([18, 15, 12], 851) -&gt; [230, 276, 345]bonus([30, 27, 8, 14, 7], 34067) -&gt; [2772, 3080, 10395, 5940, 11880]\nNotes\n\nSee Example Test Cases for more examples.\nPlease ask before translating.\nIn some tests the number of elements of arr can be big.\n\nAnswer\ndef bonus(arr, s):    # your code    s=s/(sum(1/n for n in arr))    return [round(s/n) for n in arr]  def bonus2(arr, s):    ls=[]    d=sum([1/x for x in arr])    for i in arr:        ls.append(s/i/d)    return list(map(round, ls))\nTimeerror or Overflowerror\ndef bonus(arr, s):    mul = reduce(lambda x, y:x * y, arr)    denominator = 0    for i in arr:        denominator = denominator + mul//i     ls=[]    for i in arr:        ls.append(mul*s/i/denominator)    return list(map(round,ls))\nSomething else\n- inverse variation\nIn Maths, inverse variation is the relationships between variables that are represented in the form of y = k/x, where x and y are two variables and k is the constant value. It states if the value of one quantity increases, then the value of the other quantity decreases.\n\n\n\n- Overflowerror：integer division result too large for a float\nIn Python 3, number / 10 will try to return a float. However, floating point values can't be of arbitrarily large size in Python and if number is large an OverflowError will be raised.\nYou can find the maximum that Python floating point values can take on your system using the sys module:\n&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.float_info.max1.7976931348623157e+308\nTo get around this limitation, instead use // to get an integer back from the division of the two integers:\nnumber // 10\nThis will return the int floor value of number / 10 (it does not produce a float). Unlike floats, int values can be as large as you need them to be in Python 3 (within memory limits).\n- cyc（Cyclic Sum）\n\\[\n\\sum _{cyc}f(x_1,x_2,\\cdots,x_n)=f(x_1,x_2,\\cdots,x_{n-1},x_n)+f(x_2,x_3,\\cdots,x_{n},x_1)+\\cdots +f(x_n,x_1,\\cdots,x_{n-2},x_{n-1})\\\\\n\\sum_{cyc}{f(a,b,c)}=f(a,b,c)+f(b,c,a)+f(c,a,b)\n\\]\n- sym（Symmetric Sum）\n\\[\n\\sum _{sym}f(x_1,x_2,\\cdots,x_n)=\\sum _{\\sigma}f(x_{\\sigma{(1)}},x_{\\sigma{(2)}},\\cdots,x_{\\sigma{(n)}})\n\\\\ \\sum\\limits_{sym}{f(a,b,c)}=f(a,b,c)+f(b,c,a)+f(c,a,b)+f(b,a,c)+f(c,b,a)+f(a,c,b)\n\\]\nwhere \\(\\sigma\\) is the permutation of \\((1,2,...,n)\\).\n","categories":["题解"]},{"title":"Ugly Number","url":"/2022/02/18/Ugly-Number/","content":"Definition\n\n\\(ugly\\) \\(number\\)：把只包含质因子 \\(2\\)，\\(3\\) 和 \\(5\\) 的数称作丑数（\\(Ugly\\) \\(Number\\)）。例如 \\(6\\)、 \\(8\\) 都是丑数，但 \\(7\\) 、\\(14\\) 不是，因为它们包含质因子 \\(7\\) 。 习惯上我们把 \\(1\\) 当做是第一个丑数。\n\\(humble\\) \\(number\\)：对于一给定的素数集合 \\(S = {p_1, p_2, ..., p_K}\\) , 考虑一个正整数集合，该集合中任一元素的质因数全部属于 \\(S\\) 。这个正整数集合包括，\\(p_1、p_1*p_2、p_1*p_1、p_1*p_2*p_3...\\) 。该集合被称为 \\(S\\) 集合的 “丑数集合” 。\n\nLeetCode 263. Ugly Number\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\nExample 1\nInput: n = 6Output: trueExplanation: 6 = 2 × 3\nExample 2\nInput: n = 1Output: trueExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nExample 3\nInput: n = 14Output: falseExplanation: 14 is not ugly since it includes the prime factor 7. \nConstraints\n\n\\(-2^{31} &lt;= n &lt;= 2^{31} - 1\\)\n\nAnswer 1\n来源：LeetCode-Solution\n根据丑数的定义，0 和负整数一定不是丑数。\n当 \\(n&gt;0\\) 时，若 \\(n\\) 是丑数，则 \\(n\\) 可以写成 $n = 2^a ^b ^c $ 的形式，其中 \\(a,b,c\\) 都是非负整数。特别地，当 \\(a,b,c\\) 都是 \\(0\\) 时，\\(n=1\\)。\n为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5 ，直到 nn 不再包含质因数 2,3,5。若剩下的数等于 1，则说明 nn 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。\nclass Solution:    def isUgly(self, n: int) -&gt; bool:        if n &lt;= 0:            return False        factors = [2, 3, 5]        for factor in factors:            while n % factor == 0:                n //= factor                return n == 1\n复杂度分析\n时间复杂度：\\(O(\\log n)\\)。时间复杂度取决于对 \\(n\\) 除以 \\(2,3,5\\) 的次数，由于每次至少将 \\(n\\) 除以 \\(2\\)，因此除法运算的次数不会超过 \\(O(\\log n)\\)。\n空间复杂度：\\(O(1)\\)。\nAnswer 2\nclass Solution:    def isUgly(self, n: int) -&gt; bool:        if n &lt;= 0:            return False        while n % 2 == 0:            n //= 2        while n % 3 == 0:            n //= 3        while n % 5 == 0:            n //= 5        return n == 1\nLeetCode 264. Ugly Number II / 剑指 Offer 49. 丑数 LCOF\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.\nExample 1\nInput: n = 10Output: 12Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\nExample 2\nInput: n = 1Output: 1Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nConstraints\n\n\\(1 &lt;= n &lt;= 1690\\)\n\nAnswer\n来源：剑指 Offer 49. 丑数（动态规划，清晰图解）\nclass Solution:    def nthUglyNumber(self, n: int) -&gt; int:        dp, a, b, c = [1] * n, 0, 0, 0        for i in range(1, n):            n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5            dp[i] = min(n2, n3, n5)            if dp[i] == n2: a += 1            if dp[i] == n3: b += 1            if dp[i] == n5: c += 1        return dp[-1]\n","categories":["题解"]},{"title":"Look and say numbers","url":"/2022/02/19/Look-and-say-numbers/","content":"Look and say numbersThere exists a sequence of numbers that follows the pattern\n     1    11    21   1211  111221  312211 131122211113213211     .     .     .\nStarting with “1” the following lines are produced by “saying what you see”, so that line two is “one one”, line three is “two one(s)”, line four is “one two one one”.\nWrite a function that given a starting value as a string, returns the appropriate sequence as a list. The starting value can have any number of digits. The termination condition is a defined by the maximum number of iterations, also supplied as an argument.\nExampleexpected = [&#x27;11&#x27;, &#x27;21&#x27;, &#x27;1211&#x27;, &#x27;111221&#x27;, &#x27;312211&#x27;, &#x27;13112221&#x27;, &#x27;1113213211&#x27;, &#x27;31131211131221&#x27;, &#x27;13211311123113112211&#x27;, &#x27;11131221133112132113212221&#x27;]result = look_and_say(&#x27;1&#x27;, 10)test.assert_equals(result, expected)expected = [&#x27;111312&#x27;, &#x27;31131112&#x27;, &#x27;1321133112&#x27;, &#x27;11131221232112&#x27;, &#x27;31131122111213122112&#x27;, &#x27;13211321223112111311222112&#x27;, &#x27;1113122113121122132112311321322112&#x27;, &#x27;311311222113111221221113122112132113121113222112&#x27;]result = look_and_say(&#x27;132&#x27;, 8)test.assert_equals(result, expected)\nAnswer 1 - groupbyfrom itertools import groupbydef look_and_say(data=&#x27;1&#x27;, maxlen=5):    L = []    for i in range(maxlen):        data = &quot;&quot;.join(str(len(list(g)))+str(n) for n, g in groupby(data))        L.append(data)    return L\nfrom itertools import groupbydef look_and_say(data=&#x27;1&#x27;, maxlen=5):    data = &quot;&quot;.join(str(len(list(n))) + c for c, n in groupby(data))    return [data] + look_and_say(data, maxlen - 1) if maxlen else []\nAnswer 2 - two pointersdef say(string):  current, count, res = string[0], 0, &#x27;&#x27;  for char in string:    if char == current: count += 1    else:      res += str(count) + current      current, count = char, 1  res += str(count) + current  return resdef look_and_say(data=&#x27;1&#x27;, maxlen=5):  res = list()  for x in range(maxlen):    if x == 0: res.append(say(data))    else: res.append(say(res[x - 1]))  return res\ndef look_and_say(data=&#x27;1&#x27;, maxlen=5):    last = data[0]    cnt = 1    say = &quot;&quot;    for idx in range(1, len(data)):        if last != data[idx]:            say += str(cnt) + last            last = data[idx]            cnt = 1        else:            cnt += 1    say += str(cnt) + last    if maxlen == 1:        return [say]        return [say] + look_and_say(say, maxlen - 1)\ndef look_and_say(data=&#x27;1&#x27;, maxlen=5):    ls = list(data)    result = []    while maxlen:        num = ls[0]        s = &#x27;&#x27;        cnt = 0        while ls:            if ls[0] == num:                cnt += 1            else:                if cnt !=0:                    s = s + str(cnt) + num                num = ls[0]                cnt = 1            ls.pop(0)        if cnt !=0:            s = s + str(cnt) + num        maxlen -= 1        ls = list(s)        result.append(s)    return result #def look_and_say(data=&#x27;1&#x27;, maxlen=5):#     data_list = list(data)#     result = []#     for i in range(maxlen):#         if len(result) != 0:#             data_list = list(result[-1])#         str1 = 0#         ans = &#x27;&#x27;#         while str1 &lt; len(data_list):#             cnt = 1#             str2 = str1 + 1#             while str2 &lt; len(data_list):#                 if data_list[str1] == data_list[str2]:#                     cnt = cnt + 1#                     str2 = str2 + 1#                 else:#                     break#             ans = ans + str(cnt) + data_list[str1]#             str1 = str2#         result.append(ans)                    #     return result\nAnswer 3 - refrom re import subdef look_and_say(data=&#x27;1&#x27;, maxlen=5):    result = []    for _ in range(maxlen):        data = sub(r&#x27;(.)\\1*&#x27;, lambda m: str(len(m.group(0))) + m.group(1), data)        result.append(data)    return result\nimport redef look_and_say(data=&#x27;1&#x27;, maxlen=5):  l = [data]  for i in range(maxlen):    numstrs = re.findall(&#x27;1+|2+|3+|4+|5+|6+|7+|8+|9+&#x27;, l[i])    s = &#x27;&#x27;    for numstr in numstrs:      s += str(len(numstr)) + numstr[0]    l.append(s)  return l[1:]\nSomething else- itertools.groupby() in PythonPrerequisites: Python Itertools\nPython’s Itertool is a module that provides various functions that work on iterators to produce complex iterators. This module works as a fast, memory-efficient tool that is used either by themselves or in combination to form iterator algebra.\nItertools.groupby()This method calculates the keys for each element present in iterable. It returns key and iterable of grouped items.\nSyntax: itertools.groupby(iterable, key_func)Parameters:iterable: Iterable can be of any kind (list, tuple, dictionary).key: A function that calculates keys for each element present in iterable.Return type: It returns consecutive keys and groups from the iterable. If the key function is not specified or is None, key defaults to an identity function and returns the element unchanged.\nExample 1# Python code to demonstrate# itertools.groupby() methodimport itertoolsL = [(&quot;a&quot;, 1), (&quot;a&quot;, 2), (&quot;b&quot;, 3), (&quot;b&quot;, 4)]# guess L = [(&quot;a&quot;, 1),(&quot;b&quot;, 3),(&quot;b&quot;, 4),(&quot;a&quot;, 2)] , sort first？# Key functionkey_func = lambda x: x[0]for key, group in itertools.groupby(L, key_func):    print(key + &quot; :&quot;, list(group))\nOutputa : [(&#x27;a&#x27;, 1), (&#x27;a&#x27;, 2)]b : [(&#x27;b&#x27;, 3), (&#x27;b&#x27;, 4)]\nExample 2# Python code to demonstrate# itertools.groupby() methodimport itertoolsa_list = [(&quot;Animal&quot;, &quot;cat&quot;),          (&quot;Animal&quot;, &quot;dog&quot;),          (&quot;Bird&quot;, &quot;peacock&quot;),          (&quot;Bird&quot;, &quot;pigeon&quot;)]an_iterator = itertools.groupby(a_list, lambda x : x[0])for key, group in an_iterator:    key_and_group = &#123;key : list(group)&#125;    print(key_and_group)\nOutput&#123;&#x27;Animal&#x27;: [(&#x27;Animal&#x27;, &#x27;cat&#x27;), (&#x27;Animal&#x27;, &#x27;dog&#x27;)]&#125;&#123;&#x27;Bird&#x27;: [(&#x27;Bird&#x27;, &#x27;peacock&#x27;), (&#x27;Bird&#x27;, &#x27;pigeon&#x27;)]&#125;\n- RE (Regular Expression)YouTube：python基础 36 RegEx 正则表达式 (教学教程tutorial)\n- two pointersBlog：双指针算法模板和一些题目 \n","categories":["题解"]},{"title":"Magnitude","url":"/2022/02/19/Magnitude/","content":"Magnitude\nWe will represent complex numbers in either cartesian or polar form as an array/list, using the first element as a type tag; the normal tags are \"cart\" (for cartesian) and \"polar\". The forms of the tags depend on the language.\n\n['cart', 3, 4]represents the complex number3+4i\n['polar', 2, 3]represents the complex number with modulus (or magnitude)2and angle3\n\nIn the same way:\n\n['cart', 1, 2, 3, 4, 5, 6]includes the three complex numbers 1+2i, 3+4i, 5+6i\n['polar', 2, 1, 2, 2, 2, 3] represents the complex numbers (2, 1), (2, 2), (2, 3) in polar form where the magnitudes are 2, 2, 2 and the angles 1, 2, 3\n\nNote:\n\nThe polar form of a complex number z = a+bi is z = (r, θ) = r(cosθ+isinθ), where r = |z| = the (non-negative) square-root of a^2+b^2 is the modulus.\nIn the arrays/lists beginning by a tag all terms after the tag must be integers (no floats, no strings).\n\nTask\nGiven a sequence of complex numbers z in one of the previous forms we first calculate the sum s of the squared modulus of all complex elements of z if z is in correct form.\nOur function sqr-modulus returns an array/list of three elements; the form of the list will depend on the language:\n\nthe first element is a boolean:\n\n#t or True or true if z is in correct form as defined previously (correct type of numbers, correct tag)\n#f or False or false if z is not in correct form.\n\nthe second element is the sum s of the squared modulus of all complex numbers in z if the returned boolean is true, -1 if it is false.\nthe third element is the greatest number got by rearranging the digits of s. We will admit that the greatest number got from-1 is 1.\n\nExamples (in general form):\nSee the exact form of the return for your language in \"RUN SAMPLE TESTS\"\nsqr_modulus([&#x27;cart&#x27;, 3, 4]) -&gt; (True , 25, 52)sqr_modulus([&#x27;cart&#x27;, 3, 4, 3, 4]) -&gt; (True , 50, 50)sqr_modulus([&#x27;polar&#x27;, 2531, 3261]) -&gt; (True , 6405961, 9665410)sqr_modulus([&#x27;polar&#x27;, 2, 3, 2, 4]) -&gt; (True , 8, 8)sqr_modulus([&#x27;polar&#x27;, &quot;2&quot;, 3]) -&gt; (False , -1, 1)sqr_modulus([&#x27;polara&#x27;, 2, 3]) -&gt; (False , -1, 1)sqr_modulus([&#x27;cart&#x27;, 3, 4.1]) -&gt; (False , -1, 1)\nNotes:\n\nRacket: in Racket (integer? 2.0) returns #t\nPascal: The given input is a string; the first substring is the tag; other substrings represent integers or floats or strings. The first element of return is -1 for 'false' or 1 for true.\nShell: in this kata an object will be an integer if it contains only digits.\nPerl see \"Template Solution\".\n\nAnswer 1\ndef sqr_modulus(z):    # your code    for i in z[1:]:        if isinstance(i, int)!= True:            return (False , -1, 1)        isright = True    sz = 0    if z[0] == &#x27;cart&#x27;:        for i in z[1:]:            sz += i**2        return (True, sz,int(&#x27;&#x27;.join(sorted(str(sz)),reverse=True)))      # return (True, sz,int(&#x27;&#x27;.join(sorted(str(sz)[::-1]))))    elif z[0] == &#x27;polar&#x27;:        for i in z[1::2]:            sz += i**2        return (True, sz,int(&#x27;&#x27;.join(sorted(str(sz)),reverse=True)))    else:        return (False , -1, 1)\nAnswer 2\ndef sqr_modulus(*args):    arr = list(args)[0]    if arr[0] not in (&#x27;cart&#x27;, &#x27;polar&#x27;) or any(type(x) != int for x in arr[1:]):        return False, -1, 1        if arr[0] == &#x27;cart&#x27;:        s = sum(x**2 for x in arr[1:])    elif arr[0] == &#x27;polar&#x27;:        s = sum(x**2 for x in arr[1::2])            return True, s, int(&#x27;&#x27;.join(sorted(str(s))[::-1]))\n","categories":["题解"]},{"title":"Sums of Parts","url":"/2022/02/19/Sums-of-Parts/","content":"Sums of Parts\nLet us consider this example (array written in general format):\nls = [0, 1, 3, 6, 10]\nIts following parts:\nls = [0, 1, 3, 6, 10]ls = [1, 3, 6, 10]ls = [3, 6, 10]ls = [6, 10]ls = [10]ls = []\nThe corresponding sums are (put together in a list): [20, 20, 19, 16, 10, 0]\nThe function parts_sums (or its variants in other languages) will take as parameter a list ls and return a list of the sums of its parts as defined above.\nOther Examples\nls = [1, 2, 3, 4, 5, 6] parts_sums(ls) -&gt; [21, 20, 18, 15, 11, 6, 0]ls = [744125, 935, 407, 454, 430, 90, 144, 6710213, 889, 810, 2579358]parts_sums(ls) -&gt; [10037855, 9293730, 9292795, 9292388, 9291934, 9291504, 9291414, 9291270, 2581057, 2580168, 2579358, 0]\nNotes\n\nTake a look at performance: some lists have thousands of elements.\nPlease ask before translating.\n\nAnswer 1\ndef parts_sums(ls):    # your code    sum = 0    new_ls = [0]    for i in ls[::-1]:        sum += i         new_ls.append(sum)    return new_ls[::-1]\nAnswer 2\ndef parts_sums(ls):    result = [sum(ls)]    for item in ls:        result.append(result[-1]-item)    return result\nAnswer 3\nfrom itertools import accumulatedef parts_sums(ls):    return [0, *accumulate(reversed(ls))][::-1]\nfrom itertools import accumulatedef parts_sums(ls):    return list(accumulate(ls[::-1]))[::-1]+[0]\nSomething else\n- Python – Itertools.accumulate()\nPython itertools module is a collection of tools for handling iterators.\nAccording to the official documentation:\n\n“Module [that] implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML… Together, they form an ‘iterator algebra’ making it possible to construct specialized tools succinctly and efficiently in pure Python.” this basically means that the functions in itertools “operate” on iterators to produce more complex iterators.\n\nSimply put, iterators are data types that can be used in a for loop. The most common iterator in Python is the list.\nLet’s create a list of strings and named it colors. We can use a for loop to iterate the list like:\ncolors = [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;]# Iterating Listfor each in colors:    print(each)\nOutput\nredorangeyellowgreen\nThere are many different kinds of iterables but for now, we will be using lists and sets.\nRequirements to work with itertools\nMust import the itertools module before using. We have to also import the operator module because we want to work with operators.\nimport itertoolsimport operator ## only needed if want to play with operators\nItertools module is a collection of functions. We are going to explore one of these accumulate() function.\nNote: For more information, refer to Python Itertools\naccumulate()\nThis iterator takes two arguments, iterable target and the function which would be followed at each iteration of value in target. If no function is passed, addition takes place by default. If the input iterable is empty, the output iterable will also be empty.\n\nSyntax itertools.accumulate(iterable[, func]) –&gt; accumulate object\n\nThis function makes an iterator that returns the results of a function.\nParameters iterable &amp; function\nNow its enough of the theory portion lets play with the code\nCode 1\n# import the itertool module# to work with itimport itertools# import operator to work# with operatorimport operator# creating a list GFGGFG = [1, 2, 3, 4, 5]# using the itertools.accumulate()result = itertools.accumulate(GFG, operator.mul)# printing each item from listfor each in result:    print(each)\nOutput\n12624120\nExplanation \nThe operator.mul takes two numbers and multiplies them.\noperator.mul(1, 2)2operator.mul(2, 3)6operator.mul(6, 4)24operator.mul(24, 5)120\nNow in the next example, we will use the max function as it takes a function as a parameter also.\nCode 2\n# import the itertool module# to work with itimport itertools# import operator to work with# operatorimport operator# creating a list GFGGFG = [5, 3, 6, 2, 1, 9, 1]# using the itertools.accumulate()# Now here no need to import operator# as we are not using any operator# Try after removing it gives same resultresult = itertools.accumulate(GFG, max)# printing each item from listfor each in result:    print(each)\nOutput\n5566699\nExplanation\n5max(5, 3)5max(5, 6)6max(6, 2)6max(6, 1)6max(6, 9)9max(9, 1)9\nNote: The passing function is optional as if you will not pass any function items will be summed i.e. added by default.\nitertools.accumulate(set.difference) This return accumulate of items of difference between sets.\nCode to explain\n# import the itertool module to# work with itimport itertools# creating a set GFG1 and GFG2GFG1 = &#123; 5, 3, 6, 2, 1, 9 &#125;GFG2 =&#123; 4, 2, 6, 0, 7 &#125;# using the itertools.accumulate()# Now this will first give difference# and the give result by adding all# the element in result as by default# if no function passed it will add alwaysresult = itertools.accumulate(GFG2.difference(GFG1))# printing each item from listfor each in result:    print(each)\nOutput:\n0411\nsomething else\n前缀函数与 KMP 算法\n前缀和 &amp; 差分\n","categories":["题解"]},{"title":"Bayesian Networks","url":"/2022/02/22/Bayesian%20Networks/","content":"youtube：Bayesian Networks\n\n\n\n","categories":["数学基础"]},{"title":"four 7 kyu in codewars","url":"/2022/02/24/four%207%20kyu%20in%20codewars/","content":"Is n divisible by (...)?\nCreate a function isDivisible(n,...) that checks if the first argument n is divisible by all other arguments (return true if no other arguments)\nExample\nisDivisible(6,1,3)--&gt; true because 6 is divisible by 1 and 3isDivisible(12,2)--&gt; true because 12 is divisible by 2isDivisible(100,5,4,10,25,20)--&gt; trueisDivisible(12,7)--&gt; false because 12 is not divisible by 7\nThis kata is following kata: http://www.codewars.com/kata/is-n-divisible-by-x-and-y\nAnswer\ndef is_divisible(*arg):    ls = list(arg)    for i in ls[1:]:        if ls[0] % i == 0 :            pass        else:            return False    return True\ndef is_divisible(n, *args):    return all(not n % i for i in args)\ndef is_divisible(n, *args):  return all(n % a == 0 for a in args)\nDescending Order\nYour task is to make a function that can take any non-negative integer as an argument and return it with its digits in descending order. Essentially, rearrange the digits to create the highest possible number.\nExamples\nInput: 42145 Output: 54421\nInput: 145263 Output: 654321\nInput: 123456789 Output: 987654321\nAnswer\ndef descending_order(num):    # Bust a move right here    return int(&#x27;&#x27;.join(sorted(str(num))[::-1]))\ndef Descending_Order(num):    if isinstance(num, int) and num &gt;= 0:        return int(&#x27;&#x27;.join(sorted(str(num),reverse=True)))    else:        raise ValueError(&#x27;Non-negative integer expected&#x27;)\nWorking with arrays II (and why your code fails in some katas)\nn this kata the function returns an array/list like the one passed to it but with its nth element removed (with 0 &lt;= n &lt;= array/list.length - 1). The function is already written for you and the basic tests pass, but random tests fail. Your task is to figure out why and fix it.\nGood luck!\nSome good reading: Python Docs about lists\nAnswer\ndef remove_nth_element(lst, n):    # Fix it    lst_copy = lst.copy()    #import copy    #copy.deepcopy([1,2,3,4,4])    del lst_copy[n]    return lst_copy\ndef remove_nth_element(a, n):    return a[:n] + a[n+1:]\ndef remove_nth_element(lst, n):    # Fix it    lst_copy = lst[:]    del lst_copy[n]    return lst_copy\nsomething to read : https://www.codewars.com/kumite/5a7b4db7fd5777bf81000016?sel=5a84b63afd5777e6520001b8\nuser_ans = remove_nth_element(test_lst, test_n)my_ans = remove_nth_element_wYkP(test_lst, test_n)\nRobinson Crusoe\nRobinson Crusoe decides to explore his isle. On a sheet of paper he plans the following process.\nHis hut has coordinates origin = [0, 0]. From that origin he walks a given distance d on a line that has a given angle ang with the x-axis. He gets to a point A. (Angles are measured with respect to the x-axis)\nFrom that point A he walks the distance d multiplied by a constant distmult on a line that has the angle ang multiplied by a constant angmult and so on and on.\nWe have d0 = d, ang0 = ang; then d1 = d * distmult, ang1 = ang * angmult etc ...\nLet us suppose he follows this process n times. What are the coordinates lastx, lasty of the last point?\nThe function crusoe has parameters;\n\nn : numbers of steps in the process\nd : initial chosen distance\nang : initial chosen angle in degrees\ndistmult : constant multiplier of the previous distance\nangmult : constant multiplier of the previous angle\n\ncrusoe(n, d, ang, distmult, angmult) should return lastx, lasty as an array or a tuple depending on the language.\nExample:\ncrusoe(5, 0.2, 30, 1.02, 1.1) -&gt;\nThe successive x are : 0.0, 0.173205, 0.344294, 0.511991, 0.674744, 0.830674 (approximately)\nThe successive y are : 0.0, 0.1, 0.211106, 0.334292, 0.47052, 0.620695 (approximately)\nand\nlastx: 0.8306737544381833lasty: 0.620694691344071\nA drawing\n\n\n\nSuccessive points:\n\nx: 0.0, 0.9659..., 1.8319..., 2.3319..., 1.8319...\ny: 0.0, 0.2588..., 0.7588..., 1.6248..., 2.4908...\n\nNote\nPlease could you ask before translating?\nAnswer\nimport mathdef crusoe(n, d, ang, dist_mult, ang_mult):    # your code    lastx = 0    lasty = 0    ang = math.radians(ang)    for i in  range(1,n+1):        lasty += math.sin(ang) * d        lastx += math.cos(ang) * d        d = d * dist_mult        ang = ang * ang_mult    return lastx, lasty\nimport mathdef crusoe(n, d, ang, dist_mult, ang_mult):    x, y = 0, 0    for i in range(n):        x += d*dist_mult**i*math.cos(math.radians(ang*ang_mult**i))        y += d*dist_mult**i*math.sin(math.radians(ang*ang_mult**i))    return x, y\n","categories":["题解"]},{"title":"如何理解python的类与对象？——改自知乎答案","url":"/2022/02/25/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3python%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%9F%E2%80%94%E2%80%94%E6%94%B9%E8%87%AA%E7%9F%A5%E4%B9%8E%E7%AD%94%E6%A1%88/","content":"python教程\n来源：知乎答案\n\n类、对象在实际编程中有啥好处，为啥要用它们\n再给你解释怎么去理解它们\n\n1 类的好处\n\n方便复用（如果你用函数写，就要复制整块代码，增加了代码量，增加了出错率）\n方便扩展（函数写段代码，若要升级、扩展，都十分复杂，容易出错，用类来扩展，则方便清晰）\n方便维护（因为类是把抽象的东西映射成我们常见的，摸得到的东西，容易理解，维护也方便）\n\n\n举几个例子\n制作鸭子\n比如你是玩具厂的工程师，你要制作一个机器，可以批量制作鸭子形状的玩具，也许你的思路如下：\ndef makeDuckMouth():    #这里可以放其他制作细节    print(&#x27;鸭子嘴巴制作完毕&#x27;)def makeDuckEar():    #这里可以放其他制作细节    print(&#x27;鸭耳朵制作完毕&#x27;)def makeDuckEye():    #这里可以放其他制作细节    print(&#x27;鸭眼睛制作完毕&#x27;)def makeDuckHead():    #这里可以放其他制作细节    print(&#x27;鸭头制作完毕&#x27;)def makeDuckWing():    #这里可以放其他制作细节    print(&#x27;鸭翅膀制作完毕&#x27;)def makeDuckBody():    #这里可以放其他制作细节    print(&#x27;鸭身体制作完毕&#x27;)def makeDuckFoot():    #这里可以放其他制作细节    print(&#x27;鸭脚制作完毕&#x27;)def makeDuckMerge():    #这里可以放其他制作细节    print(&#x27;鸭子组装完毕&#x27;)makeDuckMoth() #制作鸭嘴巴makeDuckEar() #制作鸭耳朵makeDuckEye() #制作鸭眼睛makeDuckHead() #制作鸭头makeDuckWing()  #制作鸭翅膀，注意，猪是没有翅膀的makeDuckBody() #制作鸭身体makeDuckFoot() #制作鸭脚makeDuckMerge() #合并鸭子的各个部位，组装成最终鸭子\n你发现，自己好厉害，居然学会了整个鸭子的制作流程\n制作猪\n第二天，老板让你，制作猪形状的玩具，难道你的代码如下？\ndef makePigMouth():    #这里可以放其他制作细节    print(&#x27;猪嘴巴制作完毕&#x27;)def makePigEar():    #这里可以放其他制作细节    print(&#x27;猪耳朵制作完毕&#x27;)def makePigEye():    #这里可以放其他制作细节    print(&#x27;猪眼睛制作完毕&#x27;)def makePigHead():    #这里可以放其他制作细节    print(&#x27;猪头制作完毕&#x27;)def makePigBody():    #这里可以放其他制作细节    print(&#x27;猪身体制作完毕&#x27;)def makePigHand():    #这里可以放其他制作细节    print(&#x27;猪手制作完毕&#x27;)def makePigFoot():    #这里可以放其他制作细节    print(&#x27;4只猪脚制作完毕&#x27;)def makePigMerge():    #这里可以放其他制作细节    print(&#x27;猪组装完毕&#x27;)makePigMoth() #制作猪嘴巴makePigEar() #制作猪耳朵makePigEye() #制作猪眼睛makePigHead() #制作猪头makePigBody() #制作猪身体makePigFoot() #制作4只猪脚makePigMerge() #合并猪的各个部位，组装成最终猪\n这样来，你确实完成了工作，但有没有觉得 有点累？\n是不是觉得，猪和鸭子有很多相似之处？\n2 如何去理解类\n类就像是基因的制造图纸，我们人类，生的小孩，也是两只手，两只脚，一个嘴巴，除非变异，否则不会多出一只脚的，之所以这样有序的发展，是因为我们身体里，有基因这张图纸控制着我们的繁衍。\nAnimal\n现在我们给上面例子中的制作 鸭子、猪 建立一个通用的制作基因表，利用他们相似制作流程建立基因表。\nclass Animal(object):    &#x27;&#x27;&#x27;    猪和鸭子的基类（基因图纸表）    &#x27;&#x27;&#x27;    def __init__(self, name): # 实例化的时候传入要制作的东西名字，如猪、鸭子        self.name = name     def makeMouth(self):        #这里可以放其他制作细节          print(self.name+&#x27;的嘴巴 制作完毕&#x27;) #这里的self.name就是获取我们传入的name    def makeEar(self):        #这里可以放其他制作细节          print(self.name+&#x27;的耳朵 制作完毕&#x27;)     def makeEye(self):        #这里可以放其他制作细节          print(self.name+&#x27;的眼睛 制作完毕&#x27;)     def makeHead(self):        #这里可以放其他制作细节          print(self.name+&#x27;的头 制作完毕&#x27;)     def makeBody(self):        #这里可以放其他制作细节          print(self.name+&#x27;的身体 制作完毕&#x27;)     def makeFoot(self):        #这里可以放其他制作细节          print(self.name+&#x27;的脚 制作完毕&#x27;)     def makeMerge(self):        #这里可以放其他制作细节          print(self.name+&#x27;合并完毕&#x27;)     def makeAll(self):         # 一条龙。直接跑完整个流水线        self.makeMoth()        self.makeEar()        self.makeEye()        self.makeHead()        self.makeBody()        self.makeFoot()        self.makeMerge()\n你可以看到，上面的图纸里，我们没有放 makeWing() #制作翅膀，那是因为猪不会飞，我们只放猪和鸭子共有的、相同的东西。\nPig\n接下来，用这个类，继承给Pig，代码如下：\nclass Pig(Animal):  # 括号里写Animal，意思是Pig继承Animal的所有特性，类似你继承你老爸的基因    def makeMoth(self):        #这里加详细的猪嘴巴制作流程，如长嘴巴，有两个孔          print(self.name+&#x27;的嘴巴 制作完毕&#x27;)     def makeEar(self):        #耳朵大大的        print(self.name+&#x27;的耳朵 制作完毕&#x27;)     def makeEye(self):        #眼睛小小的         print(self.name+&#x27;的眼睛 制作完毕&#x27;)     def makeHead(self):        #很大的头         print(self.name+&#x27;的头 制作完毕&#x27;)     def makeBody(self):        #略         print(self.name+&#x27;的身体 制作完毕&#x27;)     def makeFoot(self):        #略          print(self.name+&#x27;的脚 制作完毕&#x27;)     def makeMerge(self):        #略          print(self.name+&#x27;合并完毕&#x27;) \n在class Pig中，如 makeMoth里面，只加入详细制作猪嘴巴的代码，不要把制作猪头的代码放这里哦\n你发现，class Pig中 没有了这2段代码，这是因为，如果你继承别的对象，如Animal后，若完全不修改某些方法属性，就可以不写出来（实际还是存在Pig中的）\ndef __init__(self, name):      self.name = name   def makeAll(self):       # 一条龙。直接跑完整个流水线      self.makeMoth()      self.makeEar()      self.makeEye()      self.makeHead()      self.makeBody()      self.makeFoot()      self.makeMerge()\n写出来意味着，你要覆盖以前代码块里的行为，如 我们写出了makeMoth，makeEar ...\n意味着我们要把makeMoth里的制作细节改成我们想要的，\n猪和鸭子的嘴巴长得不一样，制作细节肯定不同，对吧？\n最后我们用以下代码，让机器开始造猪\npig1 = Pig(&#x27;猪&#x27;)  #实例化，相当于怀孕pig1.makeAll()  # 开始造猪，相当于在子宫里形成整体\nDuck\n现在开始造鸭子的图纸，继承Animal，覆盖某些代码\nclass Duck(Animal):  #     def makeMoth(self):        #这里加详细的鸭子嘴巴制作流程，如长嘴巴，嘴巴硬         print(self.name+&#x27;的嘴巴 制作完毕&#x27;)     def makeEar(self):        #耳朵很小        print(self.name+&#x27;的耳朵 制作完毕&#x27;)     def makeEye(self):        #眼睛小小的         print(self.name+&#x27;的眼睛 制作完毕&#x27;)     def makeHead(self):        #头很小         print(self.name+&#x27;的头 制作完毕&#x27;)     def makeBody(self):        #略         print(self.name+&#x27;的身体 制作完毕&#x27;)     def makeFoot(self):        #略          print(self.name+&#x27;的脚 制作完毕&#x27;)         def makeMerge(self):        #略          print(self.name+&#x27;合并完毕&#x27;)     def makeWing(self): #增加翅膀的制作流程        #略          print(self.name+&#x27;的翅膀 制作完毕&#x27;)     def makeAll(self): #因为增加了翅膀，所以要覆写这个函数              self.makeMoth()        self.makeEar()        self.makeEye()        self.makeHead()        self.makeBody()        self.makeFoot()        self.makeWing()  #插入翅膀制作流程        self.makeMerge()\n然后用以下代码实例化，开始做鸭子\nduck1 = Duck(&#x27;鸭子&#x27;)duck1.makeAll()\n以后我们要狗、牛、企鹅，都可以从Animal继承， Animal给我们提供了一个框架，我们只需要在这个框架上，扩展，延伸 就可以很方便的做出任何东西，这就是类的魅力\nOther\n如果你要做个别的咋办？\n可以建立一个 足够通用基类，慢慢扩展， 类似人类的老祖宗，最开始是微生物，后来是猴子。\nclass Weishengwu(object):    &#x27;&#x27;&#x27;假设一开始的老祖宗只会吃东西&#x27;&#x27;&#x27;    def __init__(self, name):         self.name = name     def eat(self):        print(&#x27;吃东西&#x27;)#开始进化成鱼类class Fish(Weishengwu):    &#x27;&#x27;&#x27;在老祖宗只会吃的基础上，学会了移动&#x27;&#x27;&#x27;    def move(self):        print(&#x27;移动&#x27;)#开始进化成猴子class Houzi(Fish):    &#x27;&#x27;&#x27;在鱼的基础上学会了爬树&#x27;&#x27;&#x27;    def __init__(self, name, love):  # 以前只有名字，现在有了爱好，或许是吃桃子、或许是荡秋千        self.name = name         self.love = love     def eat(self):        #覆写，因为吃东西的方式可能和鱼类不一样了        print(&#x27;牙齿吃东西&#x27;)    def move(self):        #覆写，不是在水里移动了，是陆地上移动        print(&#x27;脚移动&#x27;)    def Pashu(self):        print(&#x27;爬树&#x27;)#你可以继续进化，继续给他增加任何功能\n在python中，一个对象的特征也称为属性（attribute）。它所具有的行为也称为方法（method）。\n结论：对象=属性（特征）+方法（行为）\n类：在python中，把具有相同属性和方法的对象归为一个类（class）。比如人类，动物，植物等等，这些都是类的概念。\n","categories":["数据结构"]},{"title":"从数据视角透析认知追踪：框架、问题及启示","url":"/2022/02/28/%E4%BB%8E%E6%95%B0%E6%8D%AE%E8%A7%86%E8%A7%92%E9%80%8F%E6%9E%90%E8%AE%A4%E7%9F%A5%E8%BF%BD%E8%B8%AA-%E6%A1%86%E6%9E%B6%E3%80%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%AF%E7%A4%BA/","content":"作者\n孙建文 栗大智 彭 晛 邹 睿 王 佩\n摘要\n认知追踪是一种数据驱动的学习者建模技术，被广泛应用于智能导学、智能课堂编排等系统。尤其是2015年深度神经网络被引入认知追踪任务以来，认知追踪成为智能教育领域的研究热点。针对当前研究普遍存在的“重模型、轻数据”以及数据处理不一致等问题，本研究基于近六年国内外35篇有关认知追踪的论文，全面梳理和分析其中被高频使用的数据集，提出以学生、知识、问题三个对象及六类交互关系为核心的认知追踪概念框架，为深层次理解数据内涵和统一数据操作提供指导。本研究还运用该框架对数据集特征进行分类，围绕数据重复、数据顺序、支架题目、技能缺失以及多技能题目等关键问题进行数据一致性分析，特别是针对多技能题目，提出了基于多热编码的表示方法。本研究最后从五方面讨论了认知追踪及未来智能教育的发展趋势:从个体自主学习到多模式混合学习、从单一学习行为到多模态数据融合、从深度学习算法黑箱到可解释分析、从数据驱动到数据与知识联合驱动，以及从技术意识垄断回归教育价值本位，为拓展认知追踪研究边界、促进智能教育创新突破提供参考与指引。\n一、引言\n教育情境可计算、学习主体可理解、学习服务可定制是个性化学习面临的三大挑战，其中，学习主体是教育系统的核心要素，对学习主体的精准洞察是开展“因材施教”的前提( 刘三女牙等，2020)。\n【定义与来源】\n认知追踪(Knowledge Tracing，KT)，也被译为“知识追踪”，本研究认为译作“认知追踪”更能表达其追踪对象是主体的人，而非客体的知识这一意蕴。\n认知追踪的思想源于美国著名心理学家阿特金森( Atkinson ＆ Paulson，1972) ，1995年被美国卡耐基梅隆大学科比特等(Corbett ＆ Anderson，1995) 引入智能导学系统，并提出贝叶斯认知追踪方法( Bayesian Knowledge Tracing，BKT) ，其任务是根据学生的答题记录，对学生的知识掌握状态进行建模，目标是预测学生答对下一道题的概率。\n【基本数据处理】\n问题：多项研究使用相同的数据集和模型，却得到不同的实验结果，原因是不同学者对数据集的处理操作不一，导致实验结果出现差异。\n普遍处理方法：威尔逊等( Wilsonet al.，2016) 对深度认知追踪方法的数据处理方法提出疑问，认为应删除数据集的重复记录，按照学习系统使用过程实际顺序进行排列。后续研究大多采纳了这一建议。\n【数据角度分析预测性能】\n有学者( Xiong et al. ，2016) 从数据角度就深度认知追踪方法大幅提升预测性能提出三点质疑，并从数据重复性、支架题目影响、多技能题目处理三方面，将数据分为三个子集，并通过实验证明数据处理方式对实验结果的显著影响。这对后续研究有较大的参考价值，如GIKT、qDKT 等模型均直接采用这一数据集划分方式( Yang et al. ，2020；Sonkar et al.，2020) 。近年，多位学者从不同角度讨论如何对数据进行更合理的操作( Zhang et al.，2017; Lee ＆ Yeung，2019; Xu ＆ Davenport，2020) 。\n【数据一致性挑战】\n\n研究偏好——重模型、轻数据\n人工智能与教育的交叉促进了认知追踪的发展，同时也沿袭了人工智能研究领域普遍存在的“重模型、轻数据”惯性。谷歌研究员桑巴希万等( Sambasivan et al. ，2021）指出，学者们往往青睐模型创新，很少专门围绕数据展开研究，但数据质量在很大程度上决定了模型及后续应用的成败，造成数据级联问题。\n数据认知\n人们对数据的操作是否合理很大程度源于对数据内涵的理解是否准确，而数据的含义通常由其逻辑和业务背景决定。\n\n不同的认知追踪数据集产生于不同的学习系统，背后有不同的教学设计与策略，由此带来数据一致性认知挑战。\n二、概念框架\n（一）数据集调研\n【收集方法及数据集分布结构】\n本研究聚焦于2015 年深度认知追踪提出以来，新模型不断涌现但数据处理不一致现象愈发严重这一问题展开调研。研究者以 2015—2021 年为文献检索时间范围，在中国知网、Springer、ACM、arXiv 和Web of Science 等数据库中，分别以“知识追踪”“认知追踪”“Knowledge Tracing”为关键词，搜得 93 篇文献，排除未明确描述数据集的文献，最终得到论文35 篇，涉及18 个数据集、29 个模型及改进算法( 见图1) ，包括ASSISTments 系列数据集( 50.5% ) 、Statics 数据集( 13.3% ) 、Algebra 系列数据集( 12.4% )和 Synthetic-5 数据集( 10.5% ) 。\n\n\n\n【1. ASSIS Tments系列】\nASSISTments是美国伍斯特理工学院开发的在线学习平台(Feng et al. ，2009) ，其数据集包含四个子集: ASSISTments2009-2010 ( ASS09) 、ASSISTments2012-2013( ASS12)、ASSISTments2014-2015 ( ASS15) 、ASSISTments Challenge。\n\n\n\n总体情况\n\n每一次发布任务有唯一assignment_id，每一次发布是从一个题库中抽取的题目，因此 共享一个sequence_id。\n每一大题（包括主要问题和脚手架问题）共享一个assistment_id。\n题目分为两类：main problem和scaffolding problem。\n在数据集中，main problem由字段original=1表示，scaffolding problem由字段original=0表示。\n不论是main problem还是scaffolding problem，都有唯一problem_id标识。\ncorrect：correct的值只与第一次操作有关，对1错0。\nattempt_count：尝试的次数。\nhint_count：点击提示的次数。\nfirst_action：进入新题的第一次操作。\n\n其他字段\n\nBottom_hint：\n0-学生没有用完所有hint\n1-学生用完了所有hint\n空白-没有用hint\nOpportunity：学生有多少次机会回答该问题\nOpportunity_original：只计算main problem有多少次机会回答\nms_first_response:学生从看到题目到第一次操作之间的时间\ntutor_mode：builder在设置题目时，可选择该题目是tutor模式还是test模式\nPosition：该题目在发布任务中的位置\nType：题目的展示方式，有linear，random，mastery三种\nBase_sequence_id：一个题库可能被发布多次，这里指向原始题库的id\nOverlap_time*：学生做题花费的时间\nTemplate_id：同一模板可生成相似的问题\nSkill_id*:题目包含技能的id\n\n\n\nASS09\n由2009—2010 年采集的数据构成，该数据集以题目—日志的形式收集学生数据，其中行是学生回答某道题的记录，内容包括学生和题目的交互特征，如是否回答正确、是否求助等。此外，数据集还记录了学校、班级等学生属性特征，以及题目编号、位置等题目特征。ASS09 由2009—2010 年采集的数据构成，被分成“非技能建构数据( Non-skill builder data) ”和“技能建构数据( Skill builder data) ”两部分，后者又被称为掌握学习数据，即学生必须连续正确回答三道题才算掌握了该项技能。从频次分布图看，该数据集使用最为广泛。\nASS12\n由 2012—2013 年采集的数据构成，在 ASS09 数据集基础上增加了挫折程度、困惑程度、注意力集中程度、厌倦程度等特征描述学生的情感状态。\nASS15\n由 2014—2015 年采集的数据构成，仅包含100 个单技能题目，没有支架题目，特征数较少。\nASSISTments Challenge\nASSISTments Challenge 源于2017 年国际数据挖掘竞赛，其特点是特征较为丰富，共82 个特征，但较少被使用。\n\n【2. Algebra 系列】\nAlgebra 是2010 年国际知识发现和数据挖掘竞赛 KDD Cup 发布的公开数据集( Stamper et al. ，2010) ，包含 Algebra Ⅰ 2005-2006、Algebra Ⅰ 2006-2007、Bridge to Algebra 2006-2007 等三个开发数据集，以及 Algebra Ⅰ 2008-2009、Bridge to Algebra2008-2009 两个挑战数据集。其中，开发数据集包含学生真实答题结果在内的所有完整信息，旨在帮助参赛者熟悉数据格式和训练模型。挑战数据集不含学生答题结果，需要参赛者给出预测结果并提交。多数研究只使用 Algebra 开发数据集。\n【3. Statics】\nStatics 是一门大学在线课程收集的数据，包含361092 条记录，涉及 335 名学生和 85 项技能，共包 含46 个特征( Steif ＆ Bier，2014; Koedinger et al.，2010)。\n【4. Synthetic-5】\nSynthetic-5( 又称为 Simulated-5) 是深度认知追踪方法的提出者皮希构造的模拟数据集，模拟了4000 名学生 50 道题的答题情况，且学生答题序列相同。题目从五个模拟技能中抽取，每道题对应一项技能，重复实验 20 次，最后评估平均准确度和标准误差。\n(二) 认知追踪概念框架\n综上，当前研究主要面向自主学习场景，以学生做题为主要学习活动，以预测学生的技能掌握状态或者答对下一题的概率为目标。从系统论角度看，学生、技能与题目构成了认知追踪问题域的三大核心要素，但认知追踪的适用场景并不限于此。随着智能教育技术的发展，认知追踪可广泛应用于多主体协作学习、多步骤问题解决、多层次知识能力诊断等更开放、复杂、高阶的学习场景。为了不失一般性，本研究将“知识”和“问题”分别作为“技能”和“题目”两个元素的泛化概念，建立了以“学生( Student) —知识( Knowledge) —问题( Problem) ”三个对象以及六类关系为核心的认知追踪概念框架( SKP，见图2) 。\n\n\n\n【1. 基本对象】\n学生、知识和问题构成了认知追踪数据处理过程的三个基本对象。其中：\n\n学生对象包括个人基本信息及其在不同学习场景留下的学习行为信息;\n知识对象包括知识名称、类型、层次等基本属性，以及知识描述等信息;\n问题对象包括问题类型、难度、区分度等基本属性，以及题干、答案、提示、解析等内容语义信息。\n\n【2. 交互关系**】\n认知追踪就是对三类对象之间关系的量化分析与建模。例如，学生知识掌握状态预测是利用“学生—问题”之间的交互和“问题—知识”之间的关联关系信息计算“学生—知识”之间的掌握概率。认知追踪概念框架包含的交互关系可分为两类:\n\n同类对象之间的交互，常被用作辅助信息融入认知追踪建模过程。其中，“学生—学生”交互关系主要体现在多主体协作学习场景，包括学生协作过程中形成的社交角色、互动行为和内容等信息;“知识—知识”交互主要用于描述知识结构或性质关系，包括知识图谱的上下位、先后修等关系，以及具有互逆性质的知识之间的关系等; “问题—问题”交互主要体现在问题序列背后的教学设计思想，如多个主干问题之间的递进关系、主干问题与支架问题之间的主次关系、多步骤问题之间的依赖关系等。\n不同对象之间的交互，是认知追踪建模过程使用的主要信息。其中，“学生—问题”交互主要用于描述学生回答或解决问题过程中产生的各类内容或行为信息，包括作答内容以及请求提示、查看答案或解析过程等行为信息; “问题—知识”交互主要用于描述问题与知识之间的关联关系，包括一对一、一对多、多对一和多对多等，如一对一表示一个问题仅关联一个知识点，一对多表示一个问题关联多个知识点; “学生—知识”交互用于描述学生对简单技能、高阶能力等不同层次知识的掌握状态。\n\n(三) 基于认知追踪概念框架的特征分类\n认知追踪数据集大多含有丰富的特征，对特征的概念化分类是对数据内涵理解及后续处理分析的认知基础。数据集虽然源于不同的学习平台和应用场景，其特征较为丰富，但均可按认知追踪概念框架统一分类，从而为在更高层次建立对特征含义的共识性理解提供可能。\n三、关键问题\n\n\n\n(一)数据重复\n表一中近一半的研究工作涉及数据去重处理。ASS09、Alge05等数据集均存在大量的学习行为重 复记录。虽然研究者无法从源头查证重复记录如何产生，但学生在学习平台的操作属于时序行为，学生不会在同一时间回答多个问题，产生多条记录。有研究( Xiong et al. ，2016) 表明，这些重复数据实为冗余信息，可直接删除。 一般而言，学生在学习平台上进行答题等操作后，后台数据库会生成语义丰富的学习行为记录，并在此基础上构建基于多特征的认知追踪模型( Sun et al. ，2021) ，这是提升学习者建模能力的有效途径。因此，数据采集的特征丰富性、记录完整性是保障数据质量的基本要求，也是影响模型性能的关键因素。对于开放、复杂的智能学习环境以及大规模用户使用场景，如何高保真、高效地记录海量学习者的并发行为，是智能教育系统设计与实现需解决的基础性问题。\n(二)数据顺序\n数据顺序指学习行为记录输入模型的先后。通常，认知追踪建模会以学生真实答题顺序组织数据，这有利于模型捕捉数据中蕴含的学生认知状态变化规律，从而获得精准的预测结果。但也有部分研究考虑模型输入的答题序列长度对齐、按相同技能或学生重组答题序列等因素对数据进行专门处理，截断或打乱学生答题行为数据的原始顺序。例如，表一的数据集 a-1，将题目对应技能按编号重新排序后再输入模型( Piech et al. ，2015)。\n从智能教育系统视角看，学生的学习行为序列可能蕴涵了特定的教学策略或设计思想。例如， ASSISTments 平台依据掌握学习理论设计和组织题目序列，学生按题目预设顺序作答反映了一种预期的认知状态变化模式或规律，即连续答对多道相同技能的题目意味着该生大概率掌握了该技能。其次，教育心理学研究发现( Ｒohrer et al. ，2015) ，学生做数学题的过程中，不同技能的题目交叉出现比连续出现更有助于提升学习效果。\n(三)支架题目\n支架题目( Xiong et al. ，2016) 的设计思想源于支架式教学理论，旨在帮助学生穿越最近发展区，把认知引到更高水平。在学习平台上，支架题目与主题目所考察的技能相同或相近，但通常难度较低。表一中，部分研究认为，认知追踪的建模过程不应同等对待支架题目，因此直接删除了支架题目( Xiong et al. ，2016; Liu et al. ，2020; Xu ＆ Davenport，2020; Sonkar et al. ，2020) 。实际上，支架题目作答行为是学生做题序列的有机组成部分，从数据真实性和完整性角度看，保留支架题目数据有利于更准确地建模学生认知状态的变化。\n对智能教育系统而言，支架是一种广泛用于多种学习场景的导学策略，其形式不限于题目，包括推进、提示、暗示等，目的是推动学生思考、保持学习动力。在认知追踪应用场景中，支架题目的设计也体现了这一思想。当学生遇到难题时，引导其解决支架类问题可有效促进学习。因此，支架题目作答行为数据通常隐含了学生认知水平提升这一重要信息。以 ASSISTments 平台为例，若学生答题记录既包含主题目，又包含支架题目，且连续答对多个支架题目，这意味着学生经历了最近发展区的认知发展过程，并从支架题目的引导中掌握了相应的技能。\n(四)技能缺失\n针对部分答题记录缺失对应的技能信息，相关研究一般直接删除记录( Zhang et al. ，2017; Ha et al. ，2018; Abdelrahman ＆ Wang，2019; Lee ＆ Ye-ung，2019; Ghosh et al. ，2020; Gan et al. ，2020) ，或填充一个固定值( Piech et al. ，2015; Khajah et al. ，2016; Wilson et al. ，2016) 。前者虽然保证了数据的真实性，但会丢失大量有用信息，尤其是缺失记录占比较高对模型性能影响较大。后者为了处理简单，把所有技能缺失记录填充为一个新值，这会带来大量数据噪声，导致模型学到更多的错误模式。\n技能缺失折射出智能教育领域普遍存在的一个难题———智能化知识组织与资源标注。对学科知识的精细化组织，以及资源内容的深层次加工和语义化标注，是构建智能教育知识基础设施的核心任务。教育知识图谱正是该方向的研究热点，即在传统人工构建知识体系、标注知识资源的基础上，利用数据和知识双向驱动的方式往半自动或自动化方向发展。因此，对于技能缺失问题，简单删除记录或者填充固定值的做法都不合理，应考虑如何有效利用数据集的已有信息，运用相应策略补全缺失值。\n( 五) 多技能题目\n【1. 问题描述】\n在智能导学、自适应学习等认知追踪应用场景中，一道题通常不只关联一项技能，而是关联多项技能，此类题目可被称为多技能题目( Xiong et al. ，2016)。例如，一道求矩阵点积的题目可能关联向量运算、多项式运算等技能。认知追踪建模首先需要对特征进行编码，研究者通常采用机器学习领域主流的独热编码方式处理单技能题目( one-hot encoding) ，但对多技能题目的编码尚未达成共识。\n【2. 典型方法】\n\n\n\n多技能题目的编码方法可分为两种: 一是使用拆分策略，即将“一条包含多技能的记录”拆成“多条只含单技能的记录”;二是采取组合策略，即将“同一道题目包含的多个技能”组合为“一个新的技能”并重新编码。以两条答题记录为例( 见图 3左) : 第一行记录了某学生回答第 11 题的信息，该题与编号为 21、22 号的两项技能相关，学生回答正确; 第二行记录了该生回答第 12 题的信息，该题对应编号为21、22 和23 等三项技能，学生回答错误。\n若按拆分策略处理，研究者会得到拆分格式数据，原始样本数据第一行记录被拆分为两行，除技能编号不同外，其余信息都相同。同理，拆分原始样本数据第二行可得到三行数据( 见图 3 右上) 。若按组合策略处理，研究者会得到组合格式数据，原始样本数据第一行技能( 21，22) 被视为一种新的技能，并被编码为31。同理，第二行技能被编码为 32( 见图3 右下) 。\n对于拆分格式数据，以深度神经网络为代表的模型容易学到两项技能交替出现的模式，由此带来额外且显著的性能优势( Khajah et al. ，2016) ，但同时也造成数据冗余，因此近年的研究逐渐转向组合方式( Nakagawa et al. ，2018; Choffin et al. ，2019; Xu Davenport，2020; Sonkar et al. ，2020) 。组合格式数据虽然保证了一条记录描述一道题，但同时也造成技能间关联信息的缺失。例如，两个组合而成的新技能31 和32，虽然都包含了技能 21 和 22，但重新编码后无法体现这一关联信息。\n【3. 多热编码方法**】\n从模型输入编码角度，以上两种数据处理方法均采用基于技能编号的独热编码。为解决这两种方法存在的固有弊端，研究者提出多热编码方法( multi-hot encoding) ，即通过构建一个矩阵，保存题目和技能之间的交互关系，然后通过内积运算得到题目对应的多热编码，模型输出可采用多个技能对应预测概率的平均值。 多热编码方法的优势包括: 一是既保存了题目和多个技能的原始对应关系，又可以表示不同题目与多个技能之间的关联性，有助于模型发现组合技能和其他技能的关系，更具可解释性; 二是每个时间步只需输入一道题的记录，而不是用多个时间步处理同一道题，更符合认知追踪序列化建模的内在逻辑; 三是减少数据重复出现的同时保证了信息的完整性，并能够与拆分、组合两种格式的数据相互转换。\n四、启示\n( 一) 场景拓展: 从自主学习到多模式混合学习\n( 二) 模态跨越: 从单一学习行为到多模态数据融合\n( 三) 模型白化: 从深度学习算法黑箱到可解释分析\n( 四) 范式转变: 从数据驱动到数据与知识联合驱动\n( 五) 价值回归: 从技术意识垄断回归教育价值本位\n","categories":["Knowledge Tracing"]},{"title":"1 Machine Learning","url":"/2022/02/28/1-Machine-Learning/","content":"Machine Learning\n\n\nTypes of ML\n\n\nModel Selection in Machine Learning\n\n\n","categories":["bert huang Fall 2015 Machine Learning"]},{"title":"2 Probability and Naive Bayes","url":"/2022/02/28/2-Probability-and-Naive-Bayes/","content":"Probability and Naive Bayes\n\n\n","categories":["bert huang Fall 2015 Machine Learning"]},{"title":"17 Probabilistic Graphical Models and Bayesian Networks","url":"/2022/02/28/17-Probabilistic-Graphical-Models-and-Bayesian-Networks/","content":"Probabilistic Graphical Models and Bayesian Networks\n\n\n\n","categories":["bert huang Fall 2015 Machine Learning"]},{"title":"双指针","url":"/2022/03/04/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"双指针双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。\n换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。\n双向双指针/对撞指针881. Boats to Save PeopleYou are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1:\nInput: people = [1,2], limit = 3Output: 1Explanation: 1 boat (1, 2)\nExample 2:\nInput: people = [3,2,2,1], limit = 3Output: 3Explanation: 3 boats (1, 2), (2) and (3)\nExample 3:\nInput: people = [3,5,3,4], limit = 5Output: 4Explanation: 4 boats (3), (3), (4), (5)\nConstraints:\n\n1 &lt;= people.length &lt;= 5 * 104\n1 &lt;= people[i] &lt;= limit &lt;= 3 * 104\n\nAnswerclass Solution:    def numRescueBoats(self, people: List[int], limit: int) -&gt; int:        #如果最重的，重到连最轻的都加不上去，那它只能自己一个人一条船。        ans = 0        people.sort()        light, heavy = 0, len(people) - 1        while light &lt;= heavy:            if people[light] + people[heavy] &gt; limit:                heavy -= 1            else:                light += 1                heavy -= 1            ans += 1        return ans\n同向双指针/快慢指针快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。\n141. Linked List CycleGiven head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\nExample 1:\n\nInput: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\nExample 2:\n\nInput: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\nExample 3:\n\nInput: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list.\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 104].\n-105 &lt;= Node.val &lt;= 105\npos is -1 or a valid index in the linked-list.\n\nAnswer# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def hasCycle(self, head: ListNode) -&gt; bool:        # 空链表或链表只有一个节点，无环        if not head or head.next == None:            return False        # 初始化快慢指针        fast = slow = head        # 如果不存在环，肯定 fast 先指向 null        # 细节：fast 每次走 2 步，所以要确定 fast 和 fast.next 不为空，不然会报执行出错。        while fast and fast.next:            # 快指针移动 2 步，慢指针移动 1 步            fast = fast.next.next            slow = slow.next            # 快慢指针相遇，有环            if fast == slow:                return True        return False\n26. Remove Duplicates from Sorted ArrayGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123;    assert nums[i] == expectedNums[i];&#125;\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\n1 &lt;= nums.length &lt;= 3 * 104\n-100 &lt;= nums[i] &lt;= 100\nnums is sorted in non-decreasing order.\n\nAnswer1class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        left = 0        for right in range(len(nums)):            # 如果相等, 说明right指向的元素是重复元素，不保留            if nums[right] == nums[left]:                continue            # 如果不相等, 说明right指向的元素不是重复元素，保留，然后右移left一个单位，再把right的值赋给left            left += 1            nums[left] = nums[right]        return left + 1\nAnswer2class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        if not nums:            return 0                n = len(nums)        fast = slow = 1        while fast &lt; n:            if nums[fast] != nums[fast - 1]:                nums[slow] = nums[fast]                slow += 1            fast += 1                return slow\n1. 两数之和\n剑指 Offer 48. 最长不含重复字符的子字符串\n参考：\n数据结构和算法-双指针法\n","categories":["数据结构"]},{"title":"面向对象 —— 数据结构 Python语言描述","url":"/2022/02/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"定义\n\n类（class）用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。Python里的数据类型都是类。\n数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。\n方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n局部变量：定义在方法中的变量，只作用于当前实例的类。\n继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。\n实例化：创建一个类的实例，类的具体对象。\n方法：类中定义的函数。\n对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n父类（parent class）的名称是可选的，在默认情况下，它会是object。所有Python类属于一个以object作为根节点的层次结构。在object里，Python定义了几种方法：__str__和__eq__，因此所有子类会自动继承这些方法。稍后你将看到，这些方法为任何新的类都提供了最基础的一些默认行为。\n实例方法（instance method）是在类的对象上运行的。它们包含用来访问或修改实例变量的代码。\n实例变量（instance variable）是指由单个对象所拥有的存储信息。在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。\n类变量（class variable）是指由类的所有对象存储所有的信息。类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n\n\n类可以理解为一种类型，对象是类中的一种实例。用类创建对象的过程叫做实例化。\n最常见的举例是：\n类Class：鸟\n类的方法（函数）：（鸟）会飞\n类的属性（变量）：爪子，翅膀\n实例：\n对象：麻雀，是（类Class）鸟 的一种\n对象方法（函数）：麻雀会飞\n对象的变量：麻雀有2个爪子，一对翅膀\n\n创建类\n使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:\nclass ClassName:   &#x27;类的帮助信息&#x27;   #类文档字符串   class_suite  #类体\n类的帮助信息可以通过ClassName.__doc__查看。\nclass_suite 由类成员，方法，数据属性组成。\n实例\n以下是一个简单的 Python 类的例子:\nclass Employee:   &#x27;所有员工的基类&#x27;   empCount = 0    def __init__(self, name, salary):      self.name = name      self.salary = salary      Employee.empCount += 1      def displayCount(self):     print(&quot;Total Employee&quot;, Employee.empCount)    def displayEmployee(self):      print (&quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary)\n\nempCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。\n第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法\nself 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。\n\nself代表类的实例，而非类\n类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。\nclass Test:    def prt(self):        print(self)        print(self.__class__) t = Test()t.prt()\n以上实例执行结果为：\n&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test\n从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 **self.__class__** 则指向类。\nself 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的。\n创建实例对象\n实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。\n以下使用类的名称 Employee 来实例化，并通过 init 方法接收参数。\n&quot;创建 Employee 类的第一个对象&quot;emp1 = Employee(&quot;Zara&quot;, 2000)&quot;创建 Employee 类的第二个对象&quot;emp2 = Employee(&quot;Manni&quot;, 5000)\n访问属性\n您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量:\nemp1.displayEmployee()emp2.displayEmployee()print(&quot;Total Employee %d&quot; % Employee.empCount)\n完整\nclass Employee:   &#x27;所有员工的基类&#x27;   empCount = 0    def __init__(self, name, salary):      self.name = name      self.salary = salary      Employee.empCount += 1      def displayCount(self):     print(&quot;Total Employee %d&quot; % Employee.empCount)    def displayEmployee(self):      print(&quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary) &quot;创建 Employee 类的第一个对象&quot;emp1 = Employee(&quot;Zara&quot;, 2000)&quot;创建 Employee 类的第二个对象&quot;emp2 = Employee(&quot;Manni&quot;, 5000)emp1.displayEmployee()emp2.displayEmployee()print(&quot;Total Employee %d&quot; % Employee.empCount)\n你可以添加，删除，修改类的属性，如下所示：\nemp1.age = 7  # 添加一个 &#x27;age&#x27; 属性emp1.age = 8  # 修改 &#x27;age&#x27; 属性del emp1.age  # 删除 &#x27;age&#x27; 属性\n你也可以使用以下函数的方式来访问属性：\n\ngetattr(obj, name[, default]) : 访问对象的属性。\nhasattr(obj,name) : 检查是否存在一个属性。\nsetattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。\ndelattr(obj, name) : 删除属性。\n\nhasattr(emp1, &#x27;age&#x27;)    # 如果存在 &#x27;age&#x27; 属性返回 True。getattr(emp1, &#x27;age&#x27;)    # 返回 &#x27;age&#x27; 属性的值setattr(emp1, &#x27;age&#x27;, 8) # 添加属性 &#x27;age&#x27; 值为 8delattr(emp1, &#x27;age&#x27;)    # 删除属性 &#x27;age&#x27;\n类的继承\n面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。\n通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。\n继承语法\nclass 派生类名(基类名)    ...\n在python中继承中的一些特点：\n\n1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。\n2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数\n3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。\n\n如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" 。\n语法：\n派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：\nclass Parent:        # 定义父类   parentAttr = 100   def __init__(self):      print(&quot;调用父类构造函数&quot;)    def parentMethod(self):      print(&#x27;调用父类方法&#x27;)    def setAttr(self, attr):      Parent.parentAttr = attr    def getAttr(self):      print(&quot;父类属性 :&quot;, Parent.parentAttr) class Child(Parent): # 定义子类   def __init__(self):      print(&quot;调用子类构造方法&quot;)    def childMethod(self):      print(&#x27;调用子类方法&#x27;) c = Child()          # 实例化子类c.childMethod()      # 调用子类的方法c.parentMethod()     # 调用父类方法c.setAttr(200)       # 再次调用父类的方法 - 设置属性值c.getAttr()          # 再次调用父类的方法 - 获取属性值\n你可以继承多个类\nclass A:        # 定义类 A.....class B:         # 定义类 B.....class C(A, B):   # 继承类 A 和 B.....\n方法重写\n如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：\nclass Parent:        # 定义父类   def myMethod(self):      print &#x27;调用父类方法&#x27; class Child(Parent): # 定义子类   def myMethod(self):      print &#x27;调用子类方法&#x27; c = Child()          # 子类实例c.myMethod()         # 子类调用重写方法\n基础重载方法\n下表列出了一些通用的功能，你可以在自己的类重写：\n\n\n\n序号\n方法, 描述 &amp; 简单的调用\n\n\n\n\n1\ninit ( self [,args...] ) 构造函数 简单的调用方法: obj = className(args)\n\n\n2\ndel( self ) 析构方法, 删除一个对象 简单的调用方法 : del obj\n\n\n3\nrepr( self ) 转化为供解释器读取的形式 简单的调用方法 : repr(obj)\n\n\n4\nstr( self ) 用于将值转化为适于人阅读的形式 简单的调用方法 : str(obj)\n\n\n5\ncmp ( self, x ) 对象比较 简单的调用方法 : cmp(obj, x)\n\n\n\n运算符重载\nPython同样支持运算符重载，实例如下：\nclass Vector:   def __init__(self, a, b):      self.a = a      self.b = b    def __str__(self):      return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b)      def __add__(self,other):      return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print(v1 + v2)\n类属性与方法\n类的私有属性\n**__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs**。\n类的方法\n在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数\n类的私有方法\n\n**__private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods**\nclass JustCounter:    __secretCount = 0  # 私有变量    publicCount = 0    # 公开变量     def count(self):        self.__secretCount += 1        self.publicCount += 1        print self.__secretCount counter = JustCounter()counter.count()counter.count()print(counter.publicCount)print(counter.__secretCount)  # 报错，实例不能访问私有变量\n单下划线、双下划线、头尾双下划线说明：\n\nfoo: 定义的是特殊方法，一般是系统定义名字 ，类似 init() 之类的。\n**_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import ***\n**__foo**: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。\n\n为了说明这些概念，我们将探讨定义Counter（计数器）类的代码。顾名思义，计数器对象会跟踪一个整数的计数。计数器的值最初为0，也可以随时重置为0。你可以对计数器进行递增或者递减、获取其当前的整数值、获取其字符串表达式以及比较两个计数器是否相等。相应代码如下。\nclass Counter(object):    &quot;&quot;&quot;Models a counter.&quot;&quot;&quot;    # Class variable    instances = 0    # Constructor    def __init__(self):        &quot;&quot;&quot;Sets up the counter.&quot;&quot;&quot;        Counter.instances += 1        self.reset()    # Mutator methods    def reset(self):        &quot;&quot;&quot;Sets the counter to 0.&quot;&quot;&quot;        self.value = 0    def increment(self, amount = 1):        &quot;&quot;&quot;Adds amount to the counter.&quot;&quot;&quot;        self.value += amount    def decrement(self, amount = 1):        &quot;&quot;&quot;Subtracts amount from the counter.&quot;&quot;&quot;        self.value -= amount    # Accessor methods    def getValue(self):        &quot;&quot;&quot;Returns the counter&#x27;s value.&quot;&quot;&quot;        return self.value    def __str__(self):        &quot;&quot;&quot;Returns the string representation of the counter.&quot;&quot;&quot;        return str(self._value)     def __eq__(self, other):        &quot;&quot;&quot;Returns True if self equals other        or False otherwise.&quot;&quot;&quot;        if self is other: return True        if type(self) != type(other): return False        return self.value == other.value\n在Python的Shell窗口里对计数器对象的操作结果如下。\n&gt;&gt;&gt; from counter import Counter&gt;&gt;&gt; c1 = Counter()&gt;&gt;&gt; print(c1)0&gt;&gt;&gt; c1.getValue()0&gt;&gt;&gt; str(c1)&#x27;0&#x27;&gt;&gt;&gt; c1.increment()&gt;&gt;&gt; print(c1)1&gt;&gt;&gt; c1.increment(5)&gt;&gt;&gt; print(c1)6&gt;&gt;&gt; c1.reset()&gt;&gt;&gt; print(c1)0&gt;&gt;&gt; c2 = Counter()&gt;&gt;&gt; Counter.instances2&gt;&gt;&gt; c1 == c1True&gt;&gt;&gt; c1 == 0False&gt;&gt;&gt; c1 == c2True&gt;&gt;&gt; c2.increment()&gt;&gt;&gt; c1 == c2False\n​ Counter类是object的子类。类变量instances会跟踪已创建的计数器对象的数量。除了对它进行最初赋值，类变量必须以类名作为前缀进行访问。\n定义实例方法的语法和定义函数的语法是类似的。但是实例方法会有一个名为self的额外的参数，并且这个参数总是出现在参数列表的开头。在方法定义的上下文里，self是指在运行时这个方法的对象本身。\n​ 创建Counter的实例之后，实例方法__init__（也称为构造函数）将自动运行。这个方法用来初始化实例变量，并且对类变量进行更新。可以看到，__init__通过语法self.reset()调用reset实例方法，从而对单个实例变量进行初始化。\n​ 其他实例方法可以分为两种：变异器（mutator）和访问器（accessor）。变异器会通过修改对象的实例变量对其内部状态进行修改或更改。访问器则只会查看或使用对象的实例变量的值，而不会去修改它们。\n​ 在reset实例方法被首次调用时，它引入了实例变量self.value。之后，对这个方法的任何其他调用，都会将这个变量的值修改为0。\n​ 使用实例变量都会加上前缀self。和参数或临时变量不同的地方是，实例变量在类的任何方法里是可见的。\n​ increment和decrement方法都包含默认参数，从而为程序员提供了指定数目的可能性。\n​ Counter类的__str__方法将覆盖object类里的这个方法。当把这个对象作为参数传递给str函数时，Python会调用对象的__str__方法。在运行对象上的方法时，Python会先在这个对象自己的类里查找相应方法的代码。如果找不到这个方法，那么Python将在它的父类里查找，以此类推。如果在最后（在查看object类之后）还是找不到这个方法的代码，Python就会引发异常。\n​ 当Python的print函数接收到一个参数时，这个参数的__str__方法将自动运行，从而得到它的字符串表达式，以便用来输出。我们鼓励程序员为每个新定义的类实现__str__方法，从而对调试提供帮助。\n​ 当看到==运算符时，Python将运行__eq__方法。在object类里，这个方法的默认定义是运行is运算符。这个运算符会对两个操作数的对象标识进行比较。在本例中，对于两个不同的计数器对象，只要它们具有相同的值，就应该被视为相等。==的第二个操作数可以是任意对象，因此__eq__方法会在访问实例变量之前先判断操作数的类型是否相同。注意，你可以通过对象上的点运算符访问它的实例变量。\n参考：\n\nPython 面向对象\n数据结构 Python语言描述 第2版\n\n","categories":["数据结构"]},{"title":"LSTM","url":"/2022/03/10/LSTM/","content":"\n\n\n\n\n\n\n参考：\n\n57 长短期记忆网络（LSTM）【动手学深度学习v2】\n【LSTM长短期记忆网络】3D模型一目了然，带你领略算法背后的逻辑\n【重温经典】大白话讲解LSTM长短期记忆网络 如何缓解梯度消失，手把手公式推导反向传播\n\n","categories":["动手学深度学习v2"]},{"title":"Learning Process-consistent Knowledge Tracing","url":"/2022/03/10/Learning-Process-consistent-Knowledge-Tracing/","content":"作者\nShuanghong Shen, Qi Liu, Enhong Chen, Zhenya Huang, Wei Huang, Yu Yin, Yu Su, Shijin Wang\n摘要\n知识追踪（Knowledge tracing，KT）旨在追踪学生在学习过程中不断变化的知识状态，提高了学生在在线学习系统中的学习效率。近年来，KT因其在教育中的重要意义而引起了人们的广泛关注。然而，现有的KT方法大多追求学生成绩预测的高精度，却忽视了学生知识状态变化与学习过程的一致性。在本文中，我们探索了一种新的KT任务范式，并提出了一种新的学习过程一致性知识追踪（LPKT）模型，该模型通过直接建模学生的学习过程来监控学生的知识状态。具体来说，我们首先将基本学习单元形式化为元组练习-回答时间-回答。然后，我们从当前和以前的学习单元的差异、它们的间隔时间和学生的相关知识状态来深入衡量学习增益及其多样性。我们还设计了一个学习门控来区分学生对知识的吸收能力。此外，我们设计了一个遗忘门来模拟学生知识随时间的衰减，该遗忘门基于学生之前的知识状态、当前的学习收益和间隔时间。在三个公共数据集上的大量实验结果表明，LPKT可以获得更合理的知识状态，符合学习过程。此外，LPKT在预测学生成绩方面也优于最先进的KT方法。我们的工作为KT指出了一个潜在的未来研究方向，即高解释性和高精度。\n简介\n最近 COVID-19 的威胁引发了在线学习的爆发 [26]，其各种形式（如智能辅导系统和大规模开放在线课程）在最大限度地减少对教育的干扰方面发挥着不可或缺的作用 [25, 32]。知识追踪（KT）[4]是在线学习中的一个新兴研究领域，它利用机器学习序列模型能够使用教育相关数据来监控学生不断变化的知识状态。近几十年来，KT 得到了广泛的应用，并越来越受到科学界的关注 [17, 30, 34, 37]。\n一般来说，由于学生在每次学习交互中的真实知识状态很难被明确地记录和量化，他们在练习中的表现几乎是推断他们知识状态的唯一方法。因此，大多数现有的 KT 模型都是通过最小化预测答案和学生实际答案的交叉熵对数损失来优化的。有一个默认假设，即未来性能预测的更高准确度被近似认为等于对知识状态的更好估计。\n\n按照上述思路，现有的 KT 模型在学生成绩预测方面取得了令人瞩目的成果。例如，贝叶斯知识跟踪 (BKT) [4]、性能因素分析 (PFA) [29]、深度知识跟踪 (DKT) [31] 和运动感知知识跟踪 [16]。然而，在我们的实验中，我们注意到，仅仅追求未来表现预测的高精度可能会导致学生的知识状态与他们的学习过程不一致。为了更好地说明，我们在图 1 中给出了 DKT 追踪的知识状态的可视化案例。DKT 是一种基于 RNN 或 LSTM [10] 的流行模型，用于 KT 任务，并取得了令人印象深刻的性能 [2, 31]。图中，学生在回答 3 个不同知识概念的 15 道习题时，DKT 不断追踪他/她的知识状态并描绘出变化的过程。我们从图中发现一个常见但不合理的观察结果，即一旦学生回答错误，DKT 认为他/她对相应知识概念的知识状态会下降。虽然这种错误后学生知识状态的下降趋势可能会带来未来表现预测的高精度，但不符合认知理论，因为学生即使得到错误答案也能获得知识。先前的研究指出，错误被视为学习过程的自然要素[13]，学生可以从错误中学习，并通过有利的错误氛围促进学习进步[35]。\n为此，我们认为在知识追踪中保持学生学习过程的一致性，对正确和错误的学习互动并重，而不是仅仅追求学生表现预测的高精度是有价值的。换句话说，我们应该更多地关注知识追踪结果的质量。在本文中，我们通过直接模拟学生的学习过程来探索 KT 任务的新范式。然而，沿着这条路线有许多挑战需要解决。首先，如何定义学习过程并将其转换为适当的建模形式。其次，学习增益，即学生在学习中获得的知识，在学习过程中是隐含的、可变的。虽然Mao [20] 应用二进制量化学习增益（QLG）将学生的学习增益实例化为高或低，但这种简单的学习增益实例化不足以捕捉其多样性。例如，即使学生在相同的练习中表现相同，他们也可能获得不同的学习收获。第三，与学习增益相比，学生的知识也会随着时间的推移而减少，这通常表现为遗忘，这也是KT任务中需要考虑的因素。\n为了克服上述挑战，我们提出了一种名为学习过程一致知识追踪（LPKT）的新方法，该方法通过对学生的学习过程进行建模来达到我们评估学生知识状态的目标。具体来说，由于学习过程可以看作是学生在时间轴上的学习序列，我们首先将学习过程中的基本学习单元定义为一个元组练习—回答时间—回答，相邻单元之间被间隔时间隔开。值得注意的是，学习单元与学习交互（即练习—答案）的不同之处在于前者包含了学生在回答练习上所花费的时间。因此，学习单元更能反映完整的学习过程。然后，为了衡量学习增益，它广泛地代表学生在两个时间点的表现差异，我们直接从当前和以前的学习单元的差异中计算它们。此外，为了捕捉学习收益的多样性，我们还对另外两个因素进行了建模，分别是两个连续学习单元之间的间隔时间和学生的相关知识状态。在 LPKT 中，学习增益设置为始终为正，以便学生可以在每次学习互动中始终如一地获得知识。此外，考虑到并非所有的学习收益都可以转化为学生知识的增长，我们在 LPKT 中设计了一个学习门来控制学生对知识的吸收能力。最后，针对学习过程中普遍存在的遗忘现象，我们在 LPKT 中设计了一个遗忘门来判断知识状态随时间的减少。因此，LPKT 实现了一种通过对学习过程建模来评估学生知识状态的新方法。在三个公开的真实世界数据集上进行的大量实验表明，LPKT 根据学生的认知过程获得了更合理的知识状态。此外，LPKT 在学生表现预测方面也可以显着优于现有的 KT 模型。我们通过建模学生的学习过程来解决 KT 问题的想法表明了一个潜在的未来研究方向，即具有高可解释性和高精度。我们还进行了一个案例研究，以表明 LPKT 可以自动学习有意义的练习表示。\n相关工作\n知识追踪\n现有的大部分知识追踪模型可以分为传统的概率模型、逻辑模型和基于深度学习的方法。贝叶斯知识追踪 (BKT) [4] 是经典且广泛使用的 KT 概率模型，可以看作是隐马尔可夫模型 (HMM) 的一个特例。逻辑模型是一大类基于逻辑函数的模型，它利用逻辑函数来估计知识状态的概率[30]，例如性能因子分析（PFA）[29]。 DKT 首次将深度学习引入 KT [31]。 DKT 将学习序列作为 RNN 或其变体 LSTM 的输入，并通过隐藏状态表示学生的知识状态。动态键值记忆网络 (DKVMN) [39] 将记忆增强神经网络引入 KT。它定义了一个名为 key 的静态矩阵来存储潜在的知识概念，以及一个名为 value 的动态矩阵来存储和更新知识掌握 [39]。运动感知知识跟踪 [16] 引入文本内容以提高 KT 任务的性能。卷积知识追踪（CKT）[33]应用卷积窗口来模拟学生在几个连续学习交互中的个性化学习率。知识追踪的自注意力模型（SAKT）[27]首次直接将变换器呈现为知识追踪。 Pandey 和 Srivastava [28] 提出了一个关系感知自我注意层，它结合了用于知识追踪的上下文信息。Ghosh等人 [6] 提出了一种用于 KT 的上下文感知注意力知识追踪 (AKT) 模型，该模型利用了练习和知识获取的上下文表示，并将注意力机制与认知和心理测量模型相结合。\n学习增益\n学习增益广义上是指两个时间点的技能、能力、内容知识和个人发展之间的差异[22]。学习增益与学习成果的不同之处在于，学习增益比较了两个时间点的表现，而学习成果集中在单个时间点的输出水平上。例如，即使学生在练习中表现良好，他/她也可能不会从练习中受益。Luckin等人 [19] 将学习增益计算为\\(LG =post-pre\\), 其中 pre 和 post 指的是学生的前测和后测分数。归一化学习增益 (NLG) [8] 是一种广泛使用的调整度量：\\(NLG=\\frac{post-pre}{1-pre}\\) ，其中 1 是前测和后测的最高分数。然而，在某些情况下，NLG 可能会出现问题，例如，如果学生的前测分数很高，即使后测分数从前测中小幅下降也会导致 NLG 的很大负面影响。Mao [20] 提出了一种称为量化学习增益（QLG)的定性测量，它是对学生从前测到后测的学习增益的二元定性测量： 高或低。他们首先根据学生的分数将学生分成三组，然后，如果一个学生从表现较低的组转到表现较高的组，他/她就是高 QLG，相反，他/她将是低 QLG，但是这种学习增益的简单实例化仍然不足以捕捉其多样性。\n遗忘效应\n在真实的学习环境中，遗忘是不可避免的[21]。 艾宾浩斯遗忘曲线理论表明，学生的知识水平可能会因遗忘因素而下降[11]。 Nedungadi 和 Remya [24] 基于所学知识随时间呈指数衰减的假设 [18] 结合了遗忘。 他们利用指数衰减函数来更新知识掌握水平。 Huang等人 [11] 提出了知识熟练度追踪（KPT）模型，通过学习和遗忘理论对学生的知识熟练度进行建模，动态捕捉学生熟练度水平随时间的变化。 Nagatani等人[23] 尝试通过考虑遗忘效应来改进 DKT，但他们仅通过合并多种类型的时间或计数信息来扩展 DKT。\n准备工作\n在本节中，我们将学生的学习过程形式化，并简要介绍知识追踪的定义。 此外，我们还介绍了 LPKT 中的一些重要嵌入。\n问题定义\n在智能辅导系统中，假设有：\n\n学生集合 $ S ={s_1, s_2, ..., s_i , ..., s_I}$\n习题集 \\(E = \\{e_1, e_2, ..., e_j, ..., e_J\\}\\)\n知识概念集合 \\(K = \\{k_1, k_2, ..., k_m, ..., k_M\\}\\)，\n\n其中每个练习都与特定的知识概念相关。 由 0 和 1 组成的 \\(Q\\) 矩阵 $Q ∈ R_J×M $ 表示练习和知识概念之间的关系，如果练习 \\(e_j\\) 需要知识概念 \\(k_m\\)，则 \\(Q_{jm} = 1\\)，否则 \\(Q_{jm} = 0\\)。\n一般来说，当学生分配一个练习时，他/她会根据他/她所学的知识花费一定的时间来回答它。 学习过程在不同的练习中不断重复上述回答行为，其中相邻回答交互之间存在间隔时间。\n因此，我们将一个学生的学习过程表示为 $ x ={(e_1, at_1, a_1), it_1, (e_2, at_2, a_2), it_2, ..., (e_t, at_t, a_t ), it_t}$，其中元组 \\((e_t, at_t, a_t )\\)表示学习过程中的基本学习单元，\\(e_t\\) 是练习，\\(at_t\\) 是学生在回答 \\(e_t\\) 上花费的回答时间，\\(a_t\\) 表示二进制正确性标签（1 表示正确，0 表示错误 ），\\(it_t\\) 表示学习单元之间的间隔时间。\n问题定义。 给定学生的学习序列 \\(x = \\{(e_1, at_1, a_1), it_1, (e_2, at_2, a_2), it_2, ..., (e_t, at_t, a_t ), it_t \\}\\)，KT 任务旨在监控学生在学习过程中改变知识状态并预测他们在下一个学习步骤 $ t + 1$ 的未来表现，这可以进一步应用于个性化学生的学习方案并最大限度地提高他们的学习效率。\n嵌入\n在LPKT中，为了实现我们对学生学习过程进行建模的目标，我们考虑了以下要素: 练习，答题时间，答案，间隔时间，知识概念和知识状态。我们将学习过程的基本单元定义为元组练习-答题时间-答案，并且每个学习单元都由间隔时间分隔。为了在介绍LPKT的细节之前更好地理解LPKT的整体结构，我们从以下三个类别简单介绍了这些元素的嵌入。\n时间嵌入\n时间嵌入是指答题时间和间隔时间的嵌入。通常，作答时间和间隔时间都是学习过程中的重要因素，在一定程度上会影响学生的学习收益和遗忘效果。Nagatani等[23] 以 log2 比例将所有时间特征离散化，并将其表示为单热向量。还引入了遗忘曲线理论来模拟学生随着时间的推移而递减的知识状态 [11,18]。\n在LPKT中，由于间隔时间可能比答题时间长得多，因此我们将前者离散化为分钟，将后者离散化为秒。此外，我们将所有超过一个月的间隔时间都设置为一个月。然后，我们用 \\(\\pmb{at} ∈ \\mathbb{R}^{d_{at} × d_k}\\) 的嵌入矩阵表示离散化的答题时间，离散化的间隔时间类似地用嵌入矩阵 \\(\\pmb{it} ∈ \\mathbb{R}^{d_{it} × d_k}\\) 表示，其中 \\(d_{at}\\) 和 $ d_{it}$ 分别是离散化的答题时间和间隔时间的数量。然后，学习交互 \\(x_t\\) 中的 \\(at_t\\) 和 \\(it_t\\) 将表示为向量 \\(\\pmb{at_t} ∈ \\mathbb{R}^{d_k}\\)和 \\(\\pmb{it_t} ∈ \\mathbb{R}^{d_k}\\)。\n\n\\(\\pmb{at} ∈ \\mathbb{R}^{d_{at} × d_k}\\) ：离散化的答题时间；\n\\(\\pmb{it} ∈ \\mathbb{R}^{d_{it} × d_k}\\) ：离散化的间隔时间；\n\\(d_{at}\\) 和 $ d_{it}$ 分别是离散化的答题时间和间隔时间的数量\n\n学习嵌入\n学习嵌入是基本学习细胞的嵌入，是学生学习处理并描述他们通过回答练习获得的知识的主要部分。我们首先用一个嵌入矩阵来表示练习集 \\(\\pmb{E}∈ \\mathbb{R}^{J×d_e}\\)，其中 \\(J\\) 是练习次数，\\(d_e\\)是维度。然后，学习单元 \\(x_t\\) 中的每个练习 \\(e_t\\) 将表示为向量 \\(e_t∈ \\mathbb{R}^{d_e}\\)。对于0或1的答案 \\(a_t\\)，我们将其展开为0或1的向量 \\(\\pmb{a_t} ∈ \\mathbb{R}^{d_a}\\) ，\\(d_a\\) 也是维度。最后，用于获得基本学习单元 \\(（e_t、at_t、a_t）\\) 的学习嵌入 \\(I_t \\in \\mathbb{R}^{d_k}\\)，我们将\\(\\pmb{e}_t、\\pmb{at}_t\\)和\\(\\pmb{a}_t\\) 连接在一起，并应用多层感知器（MLP）将练习嵌入、回答时间嵌入和回答嵌入深度融合，如下所示： \\[\n\\pmb{l}_t =\\pmb{W}^T_1 [\\pmb{e}_t ⊕ \\pmb{at}_t ⊕ \\pmb{a}_t ] +b_1\n\\] 其中⊕ 是级联的操作, \\(\\pmb{W}_1 ∈ \\mathbb{R}^{(d_e+d_k+d_a)×d_k}\\) 是权重矩阵, \\(b_1 ∈ \\mathbb{R}^{d_k}\\) 是偏置项，\\(d_k\\)是纬度。\n\n学习单元 \\(（e_t、at_t、a_t）\\) 的学习嵌入 \\(I_t \\in \\mathbb{R}^{d_k}\\) ：\\(\\pmb{l}_t =\\pmb{W}^T_1 [\\pmb{e}_t ⊕ \\pmb{at}_t ⊕ \\pmb{a}_t ] +b_1\\)\n\\(e_t\\) ：学习单元中的练习；\n\\(at_t\\) ：离散化的答题时间；\n\\(a_t\\) ：学生的答案是否正确，一个1或0的向量。\n\n知识嵌入\n知识嵌入用于在学习过程中存储和更新学生的知识状态。在 LPKT 中，知识嵌入被初始化为嵌入矩阵 \\(\\pmb{h} ∈ \\mathbb{R}^{M×d_k}\\)，其中M是知识概念的数量。因此，矩阵h的每一行代表对相应知识概念的知识掌握。在每次学习交互中，由LPKT建模的每个知识概念的学习增益被更新到知识嵌入中，遗忘效应也同时包含在其中。\n\n\\(\\pmb{h} ∈ \\mathbb{R}^{M×d_k}\\) ：知识嵌入矩阵\n\\(M\\) ：知识概念的数量\n\nQ-matrix表示练习和知识概念之间的关系，它控制在回答相关练习后知识嵌入中的更新行。\nLPKT模型\n\n在本节中，我们将详细介绍LPKT模型。如图2所示，LPKT在每个学习步骤由三个模块组成 :( 1) 学习模块，(2) 遗忘模块和 (3) 预测模块。具体来说，在学生回答了一个练习后，学习模块会模拟他/她与以前的学习互动相比的学习收益。遗忘模块用于测量随着时间的流逝会忘记多少知识。然后，将利用学习收获和遗忘的知识来更新学生以前的知识状态，以实现他们的最新知识状态。最后，提出了预测模块，以根据学生的最新知识状态预测学生在下一个练习中的表现。\n学习模块\n正如我们在为 KT 任务建模学习过程的主要目标中提到的，在将学习过程形式化为基本学习单元和间隔时间之后，下一个问题是测量隐式和动态学习增益。传统上讲，学习增益可以定义为“距离旅行”[22]，它代表学生在两个时间点的表现差异。为了精确地建模学习收益，我们应该考虑学生在两次连续学习互动中学生表现的差异。在 LPKT 中，我们通过连接学生之前的学习嵌入 \\(l_{t-1}\\) 和将学习嵌入 \\(l_t\\) 作为 LPKT 中的基本输入元素来实现学习增益的建模。然而，虽然我们可以通过两个连续学习嵌入来捕捉学生表现的差异，但无法捕捉到学习过程中学习收益的多样性。例如，即使他们在部分重叠学习序列（即相同的连续学习嵌入）上具有相同的表现，也并非所有学生都共享相同的学习收益。因此，我们考虑了LPKT学习增益的两个影响因素，分别是间隔时间和学生以前的知识状态。一方面，两个学习单元之间的间隔时间是学习过程中的一个关键因素，它可以反映学习成果的差异。一般来说，学生倾向于以更短的时间获得更多的知识，这意味着他们的学习过程是紧凑和连续的。另一方面，以前的知识状态也会影响学生的学习成绩，比如掌握不好的学生有更大的提高的可能性。因此，我们将上述两个因素结合到LPKT中，用于建模学习收益的演化。\n具体来说，对于间隔时间，我们在两个连续学习嵌入之间的时间轴上将 \\(it_t\\)连接到基本输入元素。对于先前的知识状态，为了将知识状态集中在本练习的相关知识概念上，我们首先将 $h_{t-1} $与当前练习的知识概念向量 \\(q_{e_t}\\) 相乘，得到:\n**相关的知识状态 $_{t-1} $** \\[\n\\pmb{\\widetilde{h}}_{t-1} = \\pmb{q}_{e_t} · \\pmb{h}_{t-1}\n\\] 学习收益 \\(\\pmb{lg}_t\\)： \\[\n\\pmb{lg}_t = tanh(\\pmb{W}^T_2 [\\pmb{l}_{t−1} ⊕ \\pmb{it}_t ⊕ \\pmb{l}_t ⊕ \\pmb{\\widetilde{h}}_{t−1}] +b_2),\n\\] 考虑到并非所有的学习收获都可以完全转化为学生知识的增长，我们进一步设计了一个学习门 \\(\\Gamma^l_t\\) 来控制学生的知识吸收能力: \\[\n\\Gamma^l_t = σ(\\pmb{W}^T_3 [\\pmb{l}_{t−1} ⊕ \\pmb{it}_t ⊕ \\pmb{l}_t ⊕ \\pmb{\\widetilde{h}}_{t−1}] +b_3),\n\\] 相乘得到实际的学习收益，同样的，相乘的到相关的学习收益： \\[\nLG_t = Γ^l_t · ((lg_t + 1)/2)\\\\\n\\widetilde{LG}_t = q_{e_t}· LG_t\n\\] tanh 的输出范围是 (-1, 1)，我们应用线性变换将（-1，1）投影到（0，1），使学习增益始终为正，这符合我们的假设——学生可以在每次学习互动中不断地获取知识。\n遗忘模块\n计算学习增益在学生的知识状态中起到了增强作用，但相反的遗忘现象影响了随着时间的推移会有多少知识被遗忘。根据遗忘曲线理论 [18]，随着时间的推移，被记忆的学习材料的数量呈指数衰减。然而，一个简单的人工设计的指数衰减函数不足以捕获知识状态和间隔时间之间的复杂关系。\n遗忘效果和三个因素相关：\n\n学生以前的知识状态\n学生现在的知识增益\n间隔时间\n\n\\[\nΓ^f_t = σ(W^T_4 [h_{t−1} ⊕ LG_t ⊕ it_t ]) +b_4)\n\\]\n然后，我们可以通过将 $ Γ^f_t$ 乘以 \\(h_{t-1}\\) 来消除遗忘的影响，并且学生完成第 \\(t\\) 次学习交互后的知识状态 \\(h_t\\) 将更新如下： \\[\nh_t = \\widetilde{LG}_t + Γ^f_t· h_{t−1}\n\\]\n预测模块\n通过对学习过程中的学习增益和遗忘效应进行建模，得到了学生学习后的知识状态−学习互动。在这一部分中，我们将使用 \\(h_t\\) 预测学生在下一个练习 \\(e_{t+1}\\) 中的表现。\n在一个真实的学习环境中，如果给学生提供 \\(e_{t+1}\\)，他/她会尝试通过将自己的知识应用到相应的知识概念中来解决这个问题。因此，我们使用相关知识状态 \\(\\widetilde{h}_t\\) 来推断学生在 $e_{t+1} $上的表现。我们首先将嵌入 \\(\\widetilde{h}_t\\) 和et+1的练习连接起来，然后通过一个sigmoid激活的全连接网络将它们投射到输出层： \\[\ny_{t+1} = σ(W^T_5 [e_{t+1} ⊕ \\widetilde{h}_t ] +b_5)\n\\]\n目标函数\n为了学习LPKT中的所有参数，我们还选择预测y和实际答案a之间的交叉熵对数损失作为目标函数： \\[\nL(θ) = −\\sum^T_{t=1}(a_t \\text{log }y_t + (1 − a_t ) \\text{log}(1 −y_t )) + λ_θ ||θ||^2\n\\]\n实验\n数据集\nASSISTments 2012，ASSISTments Challenge，EdNet-KT1\n结果\n\n\n\n\n原文链接\nPaper：Learning Process-consistent Knowledge Tracing\ncode：github\n","categories":["Knowledge Tracing"]},{"title":"3 Decision Tree","url":"/2022/03/22/3-Decision-Tree/","content":"Decision Tree\n\n\n","categories":["bert huang Fall 2015 Machine Learning"]},{"title":"Dynamic Bayesian Networks for Student Modeling","url":"/2022/03/12/Dynamic-Bayesian-Networks-for-Student-Modeling/","content":"作者\nTanja K€aser , Severin Klingler, Alexander G. Schwing, and Markus Gross\n摘要\n智能教学系统使课程适应学生个人的需求。因此，学生知识的准确表达和预测至关重要。贝叶斯知识追踪（BKT）是一种流行的学生建模方法。然而，BKT模型的结构使其无法表示学习领域不同技能之间的层次结构和关系。另一方面，动态贝叶斯网络（DBN）能够在一个模型中联合表示多种技能。在这项工作中，我们建议使用DBN进行学生建模。我们引入了一种约束优化算法来学习这类模型的参数。我们在数学、拼写学习和物理等不同学习领域的五个大规模数据集上广泛评估和解释了我们方法的预测准确性。此外，我们还提供了与以往学生建模方法的比较，并分析了不同学生建模技术对教学策略的影响。我们证明，我们的方法在预测所有学习领域的未知数据的准确性方面优于以前的技术，并产生有意义的教学策略。\n1 简介\n建模和预测学生知识是智能辅导系统 (ITS) 的基本组成部分。 在这些系统中，下一步要处理的挑战的选择是基于学生模型对学生当前知识的估计和预测。 学生模型的预测准确性和行为直接影响系统的教学策略 [1]，进而影响教学决策的质量。 因此，准确的学生模型对于个性化至关重要，即学习内容和难度级别对每个学生的适应。 在建模方面进行了大量的研究，即构建准确的学生模型，在评估方面，即定义适当的误差度量来评估学生模型的预测准确性。\n","categories":["Knowledge Tracing"]},{"title":"latex及markdown","url":"/2022/01/09/latex%E5%8F%8Amarkdown/","content":"\n关于Hexo添加Mathjax相关问题及解决方法：https://d-veda.top/2018/11/11/Hexo-with-Mathjax/\nmarkdown中希腊字母加粗：https://blog.csdn.net/qq_28714865/article/details/103717900\n让公式中的某些数学符号加粗显示，可以使用\"​\"，比如 \\(\\mathbf{0123456789}\\) . 加粗希腊字母（比如书写向量或者矩阵时），使用\"\"，比如 \\(\\pmb{\\lambda}\\) .\nLaTeX\n\n输入单个点：\n横向多个点：\n竖向多个点：\n斜向多个点：\n上^号 ：或 \n上横线： \n上波浪线 \n上点 \n上两个点\n\n使用Markdown写矩阵：https://blog.csdn.net/qq_38228254/article/details/79469727\n\n","categories":["tools解决方案"]},{"title":"jupyter","url":"/2022/03/22/jupyter/","content":"\nJupyter notebook 运行时出现 “服务似乎挂掉了，但是会立刻重启的”：\n\nimport osos.environ[&#x27;KMP_DUPLICATE_LIB_OK&#x27;] = &#x27;TRUE&#x27;\n\nJupyterNotebook 输出窗口的显示效果调整\n\n\n\nJupyter Notebook中的漂亮打印\n\nimport pprintpp = pprint.PrettyPrinter(indent=2)pp.pprint(myTree)\n\n\n\n","categories":["tools解决方案"]},{"title":"分类任务及一点决策树","url":"/2022/03/22/%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E5%8F%8A%E4%B8%80%E7%82%B9%E5%86%B3%E7%AD%96%E6%A0%91/","content":"\n\n\n\n\n\n\n\n一些链接：\n\n【机器学习】决策树（上）——ID3、C4.5、CART（非常详细）\n【决策树算法1】ID3算法 数据挖掘 期末考试 计算题 详细步骤讲解\n什么是决策树（Decision Tree）？【知多少】\n\n","categories":["机器学习小记"]},{"title":"KPT","url":"/2022/03/23/KPT/","content":"\n\n\n\n\n","categories":["Knowledge Tracing"]},{"title":"树——概念","url":"/2022/03/26/%E6%A0%91/","content":"多项集的另一种主要类别在第2章里被称为分层（hierarchical），它由各种类型的树结构组成。大多数编程语言不会把树纳入标准类型。但是，树结构有非常广泛的应用。它们可以非常自然地表示文件目录结构或书的目录等对象的多项集。树还可以用来实现其他需要高效搜索操作的多项集，例如有序集合和有序字典，这些多项集需要在元素上添加某些优先级顺序的多项集（如优先队列）。本章将介绍让树成为非常有用的数据结构的相关属性，并探讨树在实现几种类型的多项集里的作用。\n1　树的概述\n到目前为止，我们所研究的都是线性数据结构（链表、栈等）。其中，第一个元素之外的其他元素都有一个不同的前驱；最后一个元素之外的其他元素都有一个不同的后继。在树结构里，前驱和后继的这种关系被父节点（parent）和子节点（child）的关系所取代。\n树有两个主要特征：其一，每个元素可以有多个子节点；其二，除了一个名为根节点（root）的特殊元素，其他元素都有且只有一个父节点。根节点没有父节点。\n1　树的术语\n\n\n\n\n\n\n\n术语\n定义\n\n\n\n\n节点（node）\n存储在树里的元素\n\n\n根节点（root）\n树最上层的节点。唯一没有父节点的节点\n\n\n子节点（child）\n在某个给定节点的下方直接连接的节点。一个节点可以有多个子节点，并且它的子节点在查看的时候会按照从左到右的顺序进行组织。最左边的子节点称为第一个子节点，最右边的子节点称为最后一个子节点\n\n\n父节点（parent）\n在某个给定节点的上方直接连接的节点。一个节点只能有一个父节点\n\n\n兄弟节点（siblings）\n拥有共同父节点的一些子节点\n\n\n叶节点（leaf）\n没有子节点的节点\n\n\n内部节点（interior node）\n至少包含一个子节点的节点\n\n\n边/分支/链接（edge/branch/link）\n连接父节点和子节点的线\n\n\n后代（descendant）\n节点的子节点，子节点的子节点，以此类推，直到叶节点为止\n\n\n祖先（ancestor）\n节点的父节点，父节点的父节点，以此类推，直到根节点为止\n\n\n路径（path）\n连接节点和其中一个后代的一系列的边\n\n\n路径长度（path length）\n路径里边的数目\n\n\n深度或层数（depth or level）\n节点的深度或层数等于把它连接到根节点的路径长度。因此，根节点的深度或层数为0。它的子节点的层数是1，以此类推\n\n\n高度（height）\n树里最长路径的长度；换句话说，也是树里叶节点的最大层数\n\n\n子树（subtree）\n由一个节点和它的所有后代形成的树\n\n\n\n\n\n\n可以看到，树的高度和它所包含的节点数是不同的。只包含一个节点的树的高度为0，按照惯例，空树的高度为−1。\n1.2　普通树和二叉树\n上图所示的树有时称为普通树（general tree），故可以把它和二叉树（binary tree）区分开来。在二叉树里，每个节点最多有两个子节点，即左子节点（left child）和右子节点（right child）。在二叉树里，如果一个节点只有一个子节点，仍然可以把它区分为左子节点或右子节点。因此，图所示的是两棵树。如果把它们当作二叉树，那么就并不相同。但是若将其视为普通树，它们是相同的。\n\n\n\n\n普通树——普通树要么为空，要么就是由有限的一组节点组成的。其中节点和其他所有节点都不同，被称为根节点。除此之外，集合 \\(T-\\{r\\}\\) 被分成了若干个不相交的子集，每个子集都是一棵普通树。\n二叉树——二叉树要么为空，要么就是由根节点加上左子树和右子树组成的，并且这些子树也都是二叉树。\n\n\n\n\n2　用树结构的原因\n前文提到，树能够很好地表示层次结构。解析（parsing）是指分析语言里特定句子的语法的过程。解析树（parse tree）根据句子的组成部分（如名词短语或动词短语）来描述句子的句法结构。图展示了句子“The girl hit the ball with a bat”的解析树。\n\n\n\n这棵树的根节点被标记为“句子”，用来表示这个结构里最顶层的解析。它的两个子节点分别被标记为“名词短语”和“动词短语”，代表了这个句子的组成部分。标记为“介词短语”的节点是“动词短语”的子节点，因此介词短语“with a bat”是用来修饰动词“hit”的而不是修饰名词短语“the ball”的。在最底层，“ball”这样的叶节点表示解析过程中的单词。\n文件系统结构也是树状的。如图所示，其中目录（现在通常称为文件夹）被标记为“D”，文件则被标记为“F”。\n\n\n\n一些有序多项集也可以表示为树状结构，这种树称为二叉查找树（Binary Search Tree，BST）。这种树的左子树里每个节点的值都小于根节点的值，并且右子树里每个节点的值都大于根节点的值。图展示了包含字母A～G的有序多项集表示的二叉查找树。\n\n\n\n上面3个例子表明，树的最重要和最有用的特征并不是树里元素的位置，而是父节点与子节点之间的关系。这些关系对于树结构里的数据具有非常重要的意义。它们可能会用来表示字母的顺序、短语的结构、子目录之间的包含关系，或者给定问题里的任何一对多关系。树中数据的处理基于数据之间的父/子关系。\n3　二叉树的形状\n自然界里的树有各种形状和大小，数据结构里的树也有各种形状和大小。简单地说，有些树是藤蔓状的且几乎是线性的，而另一些树则是茂密的。这些形状的两个极端如图所示。\n\n\n\n高度为 \\(H\\) 的满二叉树里包含的节点数 \\(N\\) 是多少？要用 \\(H\\) 来表示 \\(N\\)，可以从根节点（1个节点）开始，添加它的子节点（2个节点），再添加子节点的子节点（4个节点)，以此类推：\\(N=2^{H+1}-1\\)。那么，具有 \\(N\\) 个节点的满二叉树的高度 \\(H\\) 是 \\(H=log_2(N+1)-1\\)。\n但并不是所有茂密的树都是满二叉树，比如，完美平衡二叉树（perfectly balanced binary tree）是除了最后一层其他每一层的节点都被填满的树。它足够茂密，并且也支持最坏情况下对叶节点在对数时间内的访问。另一个例子是完全二叉树（complete binary tree）。它是完美平衡二叉树的一个特例，会像满二叉树那样从左到右填充最后一层的节点。图总结了这些类型的二叉树形状，并给出了一些示例。\n一般而言，二叉树越平衡，访问、插入和删除操作的性能越高。\n\n\n\n\n一棵满二叉树的高度为5，它包含多少个节点？\n一棵完全二叉树包含125个节点，它的高度是多少？\n在满二叉树里，第\\(L\\)层上有多少个节点？用 \\(L\\)表示答案。\n\n4　二叉树的遍历\n在前面的章节里，我们介绍了如何通过for循环或迭代器来遍历线性多项集里的元素。二叉树的遍历有4种标准类型：前序、中序、后序以及层次遍历。每种遍历在访问树中的节点时都遵循特定的路径和方向。接下来我们将展示在二叉查找树上的遍历。遍历算法的相关内容参见后文。\n4.1　前序遍历\n前序遍历（preorder traversal）算法会先访问树的根节点，然后以相同的方式分别遍历它的左子树和右子树。前序遍历访问的节点序列如图所示。\n\n\n\n4.2　中序遍历\n中序遍历（inorder traversal）算法先遍历左子树，然后访问根节点，最后遍历右子树。在对节点进行访问之前，这个过程先从树的最左侧开始。中序遍历访问的节点序列如图所示。\n\n\n\n4.3　后序遍历\n后序遍历（postorder traversal）算法先遍历左子树，然后遍历右子树，最后访问根节点。后序遍历所经过的路径如图所示。\n\n\n\n4.4 层序遍历\n层次遍历（level order traversal）算法从第0层开始按照从左到右的顺序访问每一层里的节点。层次遍历所经过的路径如图所示。\n\n\n\n可以看到，中序遍历可以按照排序顺序访问二叉树里的元素。表达式树的前序、中序和后序遍历可以分别用来生成前缀、中缀以及后缀形式的表达式。\n5　二叉树的3种常见应用\n前文提到，树强调的是父子节点之间的关系，这就能够让用户根据位置以外的标准对数据进行排序。本节介绍二叉树的3种特殊用法：堆、二叉查找树和表达式树。这些特殊用法都对它们的数据加上了顺序。\n5.1 堆\n二叉树里的数据通常都取自有序集合，其中的元素是可以相互比较的。最小堆（min-heap）就是一个特殊的二叉树，其中每个节点的值都小于或等于它的两个子节点。最大堆（max-heap）把更大的节点放在更靠近根节点的位置。这两种对节点顺序的约束都称为堆属性（heap property）。这里提到的堆和计算机用来管理动态内存的堆并不一样，请勿混淆。图展示了两个最小堆的示例。\n就像图里展示的，最小的元素会在根节点处，最大的元素在叶节点里。可以看到，根据前面给出的定义，图里的堆都具有完全二叉树的形状。堆中的这种数据布局提供了一种被称为堆排序（heap sort）的高效排序方法。堆排序方法会先把一组数据构建成一个堆，然后不断地删除根节点的元素，并把它添加到列表的末尾。堆还可以实现优先队列。我们将在本章后面开发堆的实现。\n\n\n\n5.2 二叉查找树\n前文提到，BST在它的节点上添加了有序的顺序。这种方式和堆的方式是不一样的。在BST里，给定节点左子树里的节点会小于给定节点，而右子树里的节点会大于给定节点。当BST的形状接近完美平衡二叉树的形状时，在最坏情况下，搜索和插入操作的复杂度都是 \\(O(logn)\\).\n图展示了在有序列表上二分搜索使用的所有可能的搜索路径，但是在实际搜索过程中只会用到其中一条路径。在每个子列表里，为了比较而访问的元素会加上阴影。\n\n\n\n如图所示，最长的搜索路径（元素4—7—8—9）需要在包含8个元素的列表里进行4次比较。因为列表是有序的，所以搜索算法在每次比较后都会把搜索空间减少一半。二叉树形式：\n\n\n\n5.3 表达式树\n在第 7 章，我们介绍了如何使用栈来把中缀表达式转换为后缀表达式，介绍了如何使用栈计算后缀表达式，还为算术表达式语言开发了解释器和计算器。在一种语言里翻译句子过程也被称为解析（parsing）。另一种处理句子的方法是在解析过程中构建解析树（parse tree）。对于表达式语言来说，这个结构也被称为表达式树（expression tree）。图展示了几个通过解析中缀表达式得到的表达式树。\n\n\n\n对于表达式树，需要注意以下几点。\n\n表达式树永远不会为空。\n每个内部节点都代表一个复合表达式，由一个运算符及其操作数组成。每个内部节点都恰好有两个子节点，它们代表这个运算符的操作数。\n每个叶节点都代表一个原子的数字操作数。\n优先级较高的运算符通常出现在树的底部附近，除非它们在源表达式里被括号改变了优先级。\n画出下面这些表达式的表达式树图：\n\n　　a．3*5 + 6\n　　b．3 + 5*6\n　　c．3*5*6\n\n\n","categories":["数据结构"]}]